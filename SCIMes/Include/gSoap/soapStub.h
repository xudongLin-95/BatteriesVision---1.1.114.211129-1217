/* soapStub.h
   Generated by gSOAP 2.8.108 for mes_cc2_1.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208108
# error "GSOAP VERSION 208108 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__ArrayOfAlarm;	/* mes_cc2_1.h:162 */
class ns1__BaseApiRequestByScada;	/* mes_cc2_1.h:166 */
class ns1__BaseApiResponseForScada;	/* mes_cc2_1.h:170 */
class ns1__LoginSoapHeader;	/* mes_cc2_1.h:172 */
class ns1__ArrayOfBindContainerSFC;	/* mes_cc2_1.h:176 */
class ns1__BindContainerSFC;	/* mes_cc2_1.h:178 */
class ns1__ArrayOfString;	/* mes_cc2_1.h:182 */
class ns1__ArrayOfCCDFileUploadCompleteSFC;	/* mes_cc2_1.h:186 */
class ns1__CCDFileUploadCompleteSFC;	/* mes_cc2_1.h:188 */
class ns1__ArrayOfDownReason;	/* mes_cc2_1.h:190 */
class ns1__ArrayOfParamDTO;	/* mes_cc2_1.h:196 */
class ns1__ParamDTO;	/* mes_cc2_1.h:198 */
class ns1__ArrayOfEquipmentProductProcessParamSFC;	/* mes_cc2_1.h:202 */
class ns1__EquipmentProductProcessParamSFC;	/* mes_cc2_1.h:204 */
class ns1__ArrayOfApiResponseSFCForScada;	/* mes_cc2_1.h:210 */
class ns1__InboundInTwoInjectionForEqu;	/* mes_cc2_1.h:236 */
class ns1__ArrayOfOutboundSFC;	/* mes_cc2_1.h:250 */
class ns1__OutboundSFC;	/* mes_cc2_1.h:252 */
class ns1__ArrayOfRecipeParam;	/* mes_cc2_1.h:256 */
class ns1__RecipeParam;	/* mes_cc2_1.h:258 */
class ns1__RecipeGetForEqu;	/* mes_cc2_1.h:264 */
class ns1__ArrayOfRecipeGetParamForEqu;	/* mes_cc2_1.h:266 */
class ns1__RecipeGetParamForEqu;	/* mes_cc2_1.h:268 */
class ns1__ArrayOfRecipeListGetForEqu;	/* mes_cc2_1.h:274 */
class ns1__RecipeListGetForEqu;	/* mes_cc2_1.h:276 */
class _ns1__Alarm;	/* mes_cc2_1.h:288 */
class _ns1__AlarmResponse;	/* mes_cc2_1.h:290 */
class _ns1__BindContainer;	/* mes_cc2_1.h:292 */
class _ns1__BindContainerResponse;	/* mes_cc2_1.h:294 */
class _ns1__BindSFC;	/* mes_cc2_1.h:296 */
class _ns1__BindSFCResponse;	/* mes_cc2_1.h:298 */
class _ns1__CCDFileUploadComplete;	/* mes_cc2_1.h:300 */
class _ns1__CCDFileUploadCompleteResponse;	/* mes_cc2_1.h:302 */
class _ns1__DownReason;	/* mes_cc2_1.h:304 */
class _ns1__DownReasonResponse;	/* mes_cc2_1.h:306 */
class _ns1__EquipmentProcessParam;	/* mes_cc2_1.h:308 */
class _ns1__EquipmentProcessParamResponse;	/* mes_cc2_1.h:310 */
class _ns1__EquipmentProductProcessParam;	/* mes_cc2_1.h:312 */
class _ns1__EquipmentProductProcessParamResponse;	/* mes_cc2_1.h:314 */
class _ns1__ExamineExists;	/* mes_cc2_1.h:316 */
class _ns1__ExamineExistsResponse;	/* mes_cc2_1.h:318 */
class _ns1__Feeding;	/* mes_cc2_1.h:320 */
class _ns1__FeedingResponse;	/* mes_cc2_1.h:322 */
class _ns1__FeedingDJInLaminating;	/* mes_cc2_1.h:324 */
class _ns1__FeedingDJInLaminatingResponse;	/* mes_cc2_1.h:326 */
class _ns1__FillingData;	/* mes_cc2_1.h:328 */
class _ns1__FillingDataResponse;	/* mes_cc2_1.h:330 */
class _ns1__GenerateCellSFC;	/* mes_cc2_1.h:332 */
class _ns1__GenerateCellSFCResponse;	/* mes_cc2_1.h:334 */
class _ns1__Heartbeat;	/* mes_cc2_1.h:336 */
class _ns1__HeartbeatResponse;	/* mes_cc2_1.h:338 */
class _ns1__Inbound;	/* mes_cc2_1.h:340 */
class _ns1__InboundResponse;	/* mes_cc2_1.h:342 */
class _ns1__InboundInContainer;	/* mes_cc2_1.h:344 */
class _ns1__InboundInContainerResponse;	/* mes_cc2_1.h:346 */
class _ns1__InboundInSFCContainer;	/* mes_cc2_1.h:348 */
class _ns1__InboundInSFCContainerResponse;	/* mes_cc2_1.h:350 */
class _ns1__InboundInTwoInjection;	/* mes_cc2_1.h:352 */
class _ns1__InboundInTwoInjectionResponse;	/* mes_cc2_1.h:354 */
class _ns1__InboundMore;	/* mes_cc2_1.h:356 */
class _ns1__InboundMoreResponse;	/* mes_cc2_1.h:358 */
class _ns1__OperatorLogin;	/* mes_cc2_1.h:360 */
class _ns1__OperatorLoginResponse;	/* mes_cc2_1.h:362 */
class _ns1__Outbound;	/* mes_cc2_1.h:364 */
class _ns1__OutboundResponse;	/* mes_cc2_1.h:366 */
class _ns1__OutboundInLaminating;	/* mes_cc2_1.h:368 */
class _ns1__OutboundInLaminatingResponse;	/* mes_cc2_1.h:370 */
class _ns1__OutboundInSFCOutputQty;	/* mes_cc2_1.h:372 */
class _ns1__OutboundInSFCOutputQtyResponse;	/* mes_cc2_1.h:374 */
class _ns1__OutboundMore;	/* mes_cc2_1.h:376 */
class _ns1__OutboundMoreResponse;	/* mes_cc2_1.h:378 */
class _ns1__Recipe;	/* mes_cc2_1.h:380 */
class _ns1__RecipeResponse;	/* mes_cc2_1.h:382 */
class _ns1__GetRecipe;	/* mes_cc2_1.h:384 */
class _ns1__GetRecipeResponse;	/* mes_cc2_1.h:386 */
class _ns1__GetRecipeList;	/* mes_cc2_1.h:388 */
class _ns1__GetRecipeListResponse;	/* mes_cc2_1.h:390 */
class _ns1__RecipeVersionExamine;	/* mes_cc2_1.h:392 */
class _ns1__RecipeVersionExamineResponse;	/* mes_cc2_1.h:394 */
class _ns1__State;	/* mes_cc2_1.h:396 */
class _ns1__StateResponse;	/* mes_cc2_1.h:398 */
class _ns1__ToolBind;	/* mes_cc2_1.h:400 */
class _ns1__ToolBindResponse;	/* mes_cc2_1.h:402 */
class _ns1__ToolLife;	/* mes_cc2_1.h:404 */
class _ns1__ToolLifeResponse;	/* mes_cc2_1.h:406 */
class _ns1__UnBindSFC;	/* mes_cc2_1.h:408 */
class _ns1__UnBindSFCResponse;	/* mes_cc2_1.h:410 */
class ns1__Alarm;	/* mes_cc2_1.h:164 */
class ns1__ApiResponseForScada;	/* mes_cc2_1.h:168 */
class ns1__BindContainer;	/* mes_cc2_1.h:174 */
class ns1__BindSFCByScadaDTO;	/* mes_cc2_1.h:180 */
class ns1__CCDFileUploadComplete;	/* mes_cc2_1.h:184 */
class ns1__DownReason;	/* mes_cc2_1.h:192 */
class ns1__EquipmentProcessParam;	/* mes_cc2_1.h:194 */
class ns1__EquipmentProductProcessParam;	/* mes_cc2_1.h:200 */
class ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada;	/* mes_cc2_1.h:206 */
class ns1__ApiResponseSFCForScada;	/* mes_cc2_1.h:208 */
class ns1__ExamineExistsByScadaDTO;	/* mes_cc2_1.h:212 */
class ns1__FeedingByScadaDTO;	/* mes_cc2_1.h:214 */
class ns1__FeedingDJInLaminatingByScadaDTO;	/* mes_cc2_1.h:216 */
class ns1__FillingData;	/* mes_cc2_1.h:218 */
class ns1__GenerateCellSFC;	/* mes_cc2_1.h:220 */
class ns1__ApiResponseDataForScadaOfString;	/* mes_cc2_1.h:222 */
class ns1__Heartbeat;	/* mes_cc2_1.h:224 */
class ns1__Inbound;	/* mes_cc2_1.h:226 */
class ns1__InboundInContainer;	/* mes_cc2_1.h:228 */
class ns1__InboundInSFCContainer;	/* mes_cc2_1.h:230 */
class ns1__InboundInTwoInjection;	/* mes_cc2_1.h:232 */
class ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu;	/* mes_cc2_1.h:234 */
class ns1__InboundMore;	/* mes_cc2_1.h:238 */
class ns1__OperatorLogin;	/* mes_cc2_1.h:240 */
class ns1__Outbound;	/* mes_cc2_1.h:242 */
class ns1__OutboundInLaminating;	/* mes_cc2_1.h:244 */
class ns1__OutboundInSFCOutputQty;	/* mes_cc2_1.h:246 */
class ns1__OutboundMore;	/* mes_cc2_1.h:248 */
class ns1__Recipe;	/* mes_cc2_1.h:254 */
class ns1__RecipeGet;	/* mes_cc2_1.h:260 */
class ns1__ApiResponseDataForScadaOfRecipeGetForEqu;	/* mes_cc2_1.h:262 */
class ns1__RecipeListGet;	/* mes_cc2_1.h:270 */
class ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu;	/* mes_cc2_1.h:272 */
class ns1__RecipeVersionExamine;	/* mes_cc2_1.h:278 */
class ns1__State;	/* mes_cc2_1.h:280 */
class ns1__ToolBind;	/* mes_cc2_1.h:282 */
class ns1__ToolLife;	/* mes_cc2_1.h:284 */
class ns1__UnBindSFCByScadaDTO;	/* mes_cc2_1.h:286 */
struct __ns1__Alarm;	/* mes_cc2_1.h:3921 */
struct __ns1__Alarm_;	/* mes_cc2_1.h:4026 */
struct __ns1__BindContainer;	/* mes_cc2_1.h:4131 */
struct __ns1__BindContainer_;	/* mes_cc2_1.h:4236 */
struct __ns1__BindSFC;	/* mes_cc2_1.h:4341 */
struct __ns1__BindSFC_;	/* mes_cc2_1.h:4446 */
struct __ns1__CCDFileUploadComplete;	/* mes_cc2_1.h:4551 */
struct __ns1__CCDFileUploadComplete_;	/* mes_cc2_1.h:4656 */
struct __ns1__DownReason;	/* mes_cc2_1.h:4761 */
struct __ns1__DownReason_;	/* mes_cc2_1.h:4866 */
struct __ns1__EquipmentProcessParam;	/* mes_cc2_1.h:4971 */
struct __ns1__EquipmentProcessParam_;	/* mes_cc2_1.h:5076 */
struct __ns1__EquipmentProductProcessParam;	/* mes_cc2_1.h:5181 */
struct __ns1__EquipmentProductProcessParam_;	/* mes_cc2_1.h:5286 */
struct __ns1__ExamineExists;	/* mes_cc2_1.h:5391 */
struct __ns1__ExamineExists_;	/* mes_cc2_1.h:5496 */
struct __ns1__Feeding;	/* mes_cc2_1.h:5601 */
struct __ns1__Feeding_;	/* mes_cc2_1.h:5706 */
struct __ns1__FeedingDJInLaminating;	/* mes_cc2_1.h:5811 */
struct __ns1__FeedingDJInLaminating_;	/* mes_cc2_1.h:5916 */
struct __ns1__FillingData;	/* mes_cc2_1.h:6021 */
struct __ns1__FillingData_;	/* mes_cc2_1.h:6126 */
struct __ns1__GenerateCellSFC;	/* mes_cc2_1.h:6231 */
struct __ns1__GenerateCellSFC_;	/* mes_cc2_1.h:6336 */
struct __ns1__Heartbeat;	/* mes_cc2_1.h:6441 */
struct __ns1__Heartbeat_;	/* mes_cc2_1.h:6546 */
struct __ns1__Inbound;	/* mes_cc2_1.h:6651 */
struct __ns1__Inbound_;	/* mes_cc2_1.h:6756 */
struct __ns1__InboundInContainer;	/* mes_cc2_1.h:6861 */
struct __ns1__InboundInContainer_;	/* mes_cc2_1.h:6966 */
struct __ns1__InboundInSFCContainer;	/* mes_cc2_1.h:7071 */
struct __ns1__InboundInSFCContainer_;	/* mes_cc2_1.h:7176 */
struct __ns1__InboundInTwoInjection;	/* mes_cc2_1.h:7281 */
struct __ns1__InboundInTwoInjection_;	/* mes_cc2_1.h:7386 */
struct __ns1__InboundMore;	/* mes_cc2_1.h:7491 */
struct __ns1__InboundMore_;	/* mes_cc2_1.h:7596 */
struct __ns1__OperatorLogin;	/* mes_cc2_1.h:7701 */
struct __ns1__OperatorLogin_;	/* mes_cc2_1.h:7806 */
struct __ns1__Outbound;	/* mes_cc2_1.h:7911 */
struct __ns1__Outbound_;	/* mes_cc2_1.h:8016 */
struct __ns1__OutboundInLaminating;	/* mes_cc2_1.h:8121 */
struct __ns1__OutboundInLaminating_;	/* mes_cc2_1.h:8226 */
struct __ns1__OutboundInSFCOutputQty;	/* mes_cc2_1.h:8331 */
struct __ns1__OutboundInSFCOutputQty_;	/* mes_cc2_1.h:8436 */
struct __ns1__OutboundMore;	/* mes_cc2_1.h:8541 */
struct __ns1__OutboundMore_;	/* mes_cc2_1.h:8646 */
struct __ns1__Recipe;	/* mes_cc2_1.h:8751 */
struct __ns1__Recipe_;	/* mes_cc2_1.h:8856 */
struct __ns1__GetRecipe;	/* mes_cc2_1.h:8961 */
struct __ns1__GetRecipe_;	/* mes_cc2_1.h:9066 */
struct __ns1__GetRecipeList;	/* mes_cc2_1.h:9171 */
struct __ns1__GetRecipeList_;	/* mes_cc2_1.h:9276 */
struct __ns1__RecipeVersionExamine;	/* mes_cc2_1.h:9381 */
struct __ns1__RecipeVersionExamine_;	/* mes_cc2_1.h:9486 */
struct __ns1__State;	/* mes_cc2_1.h:9591 */
struct __ns1__State_;	/* mes_cc2_1.h:9696 */
struct __ns1__ToolBind;	/* mes_cc2_1.h:9801 */
struct __ns1__ToolBind_;	/* mes_cc2_1.h:9906 */
struct __ns1__ToolLife;	/* mes_cc2_1.h:10011 */
struct __ns1__ToolLife_;	/* mes_cc2_1.h:10116 */
struct __ns1__UnBindSFC;	/* mes_cc2_1.h:10221 */
struct __ns1__UnBindSFC_;	/* mes_cc2_1.h:10326 */

/* mes_cc2_1.h:162 */
#ifndef SOAP_TYPE_ns1__ArrayOfAlarm
#define SOAP_TYPE_ns1__ArrayOfAlarm (10)
/* complex XML schema type 'ns1:ArrayOfAlarm': */
class SOAP_CMAC ns1__ArrayOfAlarm {
      public:
        /// Optional element 'ns1:Alarm' of XML schema type 'ns1:Alarm'
        std::vector<ns1__Alarm *> Alarm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfAlarm
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfAlarm; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfAlarm, default initialized and not managed by a soap context
        virtual ns1__ArrayOfAlarm *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfAlarm); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfAlarm() : Alarm(), soap() { }
        virtual ~ns1__ArrayOfAlarm() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfAlarm(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfAlarm * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAlarm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:166 */
#ifndef SOAP_TYPE_ns1__BaseApiRequestByScada
#define SOAP_TYPE_ns1__BaseApiRequestByScada (12)
/* complex XML schema type 'ns1:BaseApiRequestByScada': */
class SOAP_CMAC ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ResourceCode' of XML schema type 'xsd:string'
        wchar_t *ResourceCode;
        /// Optional element 'ns1:EquipmentCode' of XML schema type 'xsd:string'
        wchar_t *EquipmentCode;
        /// Required element 'ns1:LocalTime' of XML schema type 'xsd:dateTime'
        time_t LocalTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BaseApiRequestByScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BaseApiRequestByScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BaseApiRequestByScada, default initialized and not managed by a soap context
        virtual ns1__BaseApiRequestByScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BaseApiRequestByScada); }
      public:
        /// Constructor with default initializations
        ns1__BaseApiRequestByScada() : ResourceCode(), EquipmentCode(), LocalTime(), soap() { }
        virtual ~ns1__BaseApiRequestByScada() { }
        /// Friend allocator used by soap_new_ns1__BaseApiRequestByScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__BaseApiRequestByScada * SOAP_FMAC2 soap_instantiate_ns1__BaseApiRequestByScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:170 */
#ifndef SOAP_TYPE_ns1__BaseApiResponseForScada
#define SOAP_TYPE_ns1__BaseApiResponseForScada (14)
/* complex XML schema type 'ns1:BaseApiResponseForScada': */
class SOAP_CMAC ns1__BaseApiResponseForScada {
      public:
        /// Required element 'ns1:Code' of XML schema type 'xsd:int'
        int Code;
        /// Optional element 'ns1:Msg' of XML schema type 'xsd:string'
        wchar_t *Msg;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BaseApiResponseForScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BaseApiResponseForScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BaseApiResponseForScada, default initialized and not managed by a soap context
        virtual ns1__BaseApiResponseForScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BaseApiResponseForScada); }
      public:
        /// Constructor with default initializations
        ns1__BaseApiResponseForScada() : Code(), Msg(), soap() { }
        virtual ~ns1__BaseApiResponseForScada() { }
        /// Friend allocator used by soap_new_ns1__BaseApiResponseForScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__BaseApiResponseForScada * SOAP_FMAC2 soap_instantiate_ns1__BaseApiResponseForScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:172 */
#ifndef SOAP_TYPE_ns1__LoginSoapHeader
#define SOAP_TYPE_ns1__LoginSoapHeader (15)
/* complex XML schema type 'ns1:LoginSoapHeader': */
class SOAP_CMAC ns1__LoginSoapHeader {
      public:
        /// Optional element 'ns1:EquUserID' of XML schema type 'xsd:string'
        wchar_t *EquUserID;
        /// Optional element 'ns1:EquPassword' of XML schema type 'xsd:string'
        wchar_t *EquPassword;
        /// Optional element 'ns1:OperatorUserID' of XML schema type 'xsd:string'
        wchar_t *OperatorUserID;
        /// Optional element 'ns1:OperatorPassword' of XML schema type 'xsd:string'
        wchar_t *OperatorPassword;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LoginSoapHeader
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__LoginSoapHeader; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LoginSoapHeader, default initialized and not managed by a soap context
        virtual ns1__LoginSoapHeader *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__LoginSoapHeader); }
      public:
        /// Constructor with default initializations
        ns1__LoginSoapHeader() : EquUserID(), EquPassword(), OperatorUserID(), OperatorPassword(), __anyAttribute(), soap() { }
        virtual ~ns1__LoginSoapHeader() { }
        /// Friend allocator used by soap_new_ns1__LoginSoapHeader(struct soap*, int)
        friend SOAP_FMAC1 ns1__LoginSoapHeader * SOAP_FMAC2 soap_instantiate_ns1__LoginSoapHeader(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:176 */
#ifndef SOAP_TYPE_ns1__ArrayOfBindContainerSFC
#define SOAP_TYPE_ns1__ArrayOfBindContainerSFC (17)
/* complex XML schema type 'ns1:ArrayOfBindContainerSFC': */
class SOAP_CMAC ns1__ArrayOfBindContainerSFC {
      public:
        /// Optional element 'ns1:BindContainerSFC' of XML schema type 'ns1:BindContainerSFC'
        std::vector<ns1__BindContainerSFC *> BindContainerSFC;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfBindContainerSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfBindContainerSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfBindContainerSFC, default initialized and not managed by a soap context
        virtual ns1__ArrayOfBindContainerSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfBindContainerSFC); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfBindContainerSFC() : BindContainerSFC(), soap() { }
        virtual ~ns1__ArrayOfBindContainerSFC() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfBindContainerSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfBindContainerSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfBindContainerSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:178 */
#ifndef SOAP_TYPE_ns1__BindContainerSFC
#define SOAP_TYPE_ns1__BindContainerSFC (18)
/* complex XML schema type 'ns1:BindContainerSFC': */
class SOAP_CMAC ns1__BindContainerSFC {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Optional element 'ns1:Location' of XML schema type 'xsd:string'
        wchar_t *Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BindContainerSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BindContainerSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BindContainerSFC, default initialized and not managed by a soap context
        virtual ns1__BindContainerSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BindContainerSFC); }
      public:
        /// Constructor with default initializations
        ns1__BindContainerSFC() : SFC(), Location(), soap() { }
        virtual ~ns1__BindContainerSFC() { }
        /// Friend allocator used by soap_new_ns1__BindContainerSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__BindContainerSFC * SOAP_FMAC2 soap_instantiate_ns1__BindContainerSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:182 */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (20)
/* complex XML schema type 'ns1:ArrayOfString': */
class SOAP_CMAC ns1__ArrayOfString {
      public:
        /// Optional element 'ns1:string' of XML schema type 'xsd:string'
        std::vector<std::wstring> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfString
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfString, default initialized and not managed by a soap context
        virtual ns1__ArrayOfString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfString); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfString() : string(), soap() { }
        virtual ~ns1__ArrayOfString() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfString(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:186 */
#ifndef SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC
#define SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC (22)
/* complex XML schema type 'ns1:ArrayOfCCDFileUploadCompleteSFC': */
class SOAP_CMAC ns1__ArrayOfCCDFileUploadCompleteSFC {
      public:
        /// Optional element 'ns1:CCDFileUploadCompleteSFC' of XML schema type 'ns1:CCDFileUploadCompleteSFC'
        std::vector<ns1__CCDFileUploadCompleteSFC *> CCDFileUploadCompleteSFC;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfCCDFileUploadCompleteSFC, default initialized and not managed by a soap context
        virtual ns1__ArrayOfCCDFileUploadCompleteSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfCCDFileUploadCompleteSFC); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfCCDFileUploadCompleteSFC() : CCDFileUploadCompleteSFC(), soap() { }
        virtual ~ns1__ArrayOfCCDFileUploadCompleteSFC() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfCCDFileUploadCompleteSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:188 */
#ifndef SOAP_TYPE_ns1__CCDFileUploadCompleteSFC
#define SOAP_TYPE_ns1__CCDFileUploadCompleteSFC (23)
/* complex XML schema type 'ns1:CCDFileUploadCompleteSFC': */
class SOAP_CMAC ns1__CCDFileUploadCompleteSFC {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Passed' of XML schema type 'xsd:int'
        int *Passed;
        /// Optional element 'ns1:URI' of XML schema type 'xsd:string'
        wchar_t *URI;
        /// Required element 'ns1:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CCDFileUploadCompleteSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CCDFileUploadCompleteSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CCDFileUploadCompleteSFC, default initialized and not managed by a soap context
        virtual ns1__CCDFileUploadCompleteSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CCDFileUploadCompleteSFC); }
      public:
        /// Constructor with default initializations
        ns1__CCDFileUploadCompleteSFC() : SFC(), Passed(), URI(), Timestamp(), soap() { }
        virtual ~ns1__CCDFileUploadCompleteSFC() { }
        /// Friend allocator used by soap_new_ns1__CCDFileUploadCompleteSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__CCDFileUploadCompleteSFC * SOAP_FMAC2 soap_instantiate_ns1__CCDFileUploadCompleteSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:190 */
#ifndef SOAP_TYPE_ns1__ArrayOfDownReason
#define SOAP_TYPE_ns1__ArrayOfDownReason (24)
/* complex XML schema type 'ns1:ArrayOfDownReason': */
class SOAP_CMAC ns1__ArrayOfDownReason {
      public:
        /// Optional element 'ns1:DownReason' of XML schema type 'ns1:DownReason'
        std::vector<ns1__DownReason *> DownReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfDownReason
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfDownReason; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfDownReason, default initialized and not managed by a soap context
        virtual ns1__ArrayOfDownReason *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfDownReason); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfDownReason() : DownReason(), soap() { }
        virtual ~ns1__ArrayOfDownReason() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfDownReason(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfDownReason * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDownReason(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:196 */
#ifndef SOAP_TYPE_ns1__ArrayOfParamDTO
#define SOAP_TYPE_ns1__ArrayOfParamDTO (27)
/* complex XML schema type 'ns1:ArrayOfParamDTO': */
class SOAP_CMAC ns1__ArrayOfParamDTO {
      public:
        /// Optional element 'ns1:ParamDTO' of XML schema type 'ns1:ParamDTO'
        std::vector<ns1__ParamDTO *> ParamDTO;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfParamDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfParamDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfParamDTO, default initialized and not managed by a soap context
        virtual ns1__ArrayOfParamDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfParamDTO); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfParamDTO() : ParamDTO(), soap() { }
        virtual ~ns1__ArrayOfParamDTO() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfParamDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfParamDTO * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfParamDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:198 */
#ifndef SOAP_TYPE_ns1__ParamDTO
#define SOAP_TYPE_ns1__ParamDTO (28)
/* complex XML schema type 'ns1:ParamDTO': */
class SOAP_CMAC ns1__ParamDTO {
      public:
        /// Optional element 'ns1:ParamCode' of XML schema type 'xsd:string'
        wchar_t *ParamCode;
        /// Optional element 'ns1:ParamValue' of XML schema type 'xsd:string'
        wchar_t *ParamValue;
        /// Required element 'ns1:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ParamDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ParamDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ParamDTO, default initialized and not managed by a soap context
        virtual ns1__ParamDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ParamDTO); }
      public:
        /// Constructor with default initializations
        ns1__ParamDTO() : ParamCode(), ParamValue(), Timestamp(), soap() { }
        virtual ~ns1__ParamDTO() { }
        /// Friend allocator used by soap_new_ns1__ParamDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__ParamDTO * SOAP_FMAC2 soap_instantiate_ns1__ParamDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:202 */
#ifndef SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC
#define SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC (30)
/* complex XML schema type 'ns1:ArrayOfEquipmentProductProcessParamSFC': */
class SOAP_CMAC ns1__ArrayOfEquipmentProductProcessParamSFC {
      public:
        /// Optional element 'ns1:EquipmentProductProcessParamSFC' of XML schema type 'ns1:EquipmentProductProcessParamSFC'
        std::vector<ns1__EquipmentProductProcessParamSFC *> EquipmentProductProcessParamSFC;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfEquipmentProductProcessParamSFC, default initialized and not managed by a soap context
        virtual ns1__ArrayOfEquipmentProductProcessParamSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfEquipmentProductProcessParamSFC); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfEquipmentProductProcessParamSFC() : EquipmentProductProcessParamSFC(), soap() { }
        virtual ~ns1__ArrayOfEquipmentProductProcessParamSFC() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfEquipmentProductProcessParamSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:204 */
#ifndef SOAP_TYPE_ns1__EquipmentProductProcessParamSFC
#define SOAP_TYPE_ns1__EquipmentProductProcessParamSFC (31)
/* complex XML schema type 'ns1:EquipmentProductProcessParamSFC': */
class SOAP_CMAC ns1__EquipmentProductProcessParamSFC {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquipmentProductProcessParamSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EquipmentProductProcessParamSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquipmentProductProcessParamSFC, default initialized and not managed by a soap context
        virtual ns1__EquipmentProductProcessParamSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EquipmentProductProcessParamSFC); }
      public:
        /// Constructor with default initializations
        ns1__EquipmentProductProcessParamSFC() : SFC(), ParamList(), soap() { }
        virtual ~ns1__EquipmentProductProcessParamSFC() { }
        /// Friend allocator used by soap_new_ns1__EquipmentProductProcessParamSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquipmentProductProcessParamSFC * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProductProcessParamSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:210 */
#ifndef SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada
#define SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada (34)
/* complex XML schema type 'ns1:ArrayOfApiResponseSFCForScada': */
class SOAP_CMAC ns1__ArrayOfApiResponseSFCForScada {
      public:
        /// Optional element 'ns1:ApiResponseSFCForScada' of XML schema type 'ns1:ApiResponseSFCForScada'
        std::vector<ns1__ApiResponseSFCForScada *> ApiResponseSFCForScada;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfApiResponseSFCForScada, default initialized and not managed by a soap context
        virtual ns1__ArrayOfApiResponseSFCForScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfApiResponseSFCForScada); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfApiResponseSFCForScada() : ApiResponseSFCForScada(), soap() { }
        virtual ~ns1__ArrayOfApiResponseSFCForScada() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfApiResponseSFCForScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfApiResponseSFCForScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:236 */
#ifndef SOAP_TYPE_ns1__InboundInTwoInjectionForEqu
#define SOAP_TYPE_ns1__InboundInTwoInjectionForEqu (47)
/* complex XML schema type 'ns1:InboundInTwoInjectionForEqu': */
class SOAP_CMAC ns1__InboundInTwoInjectionForEqu {
      public:
        /// Required element 'ns1:BeforeWeight' of XML schema type 'xsd:double'
        double BeforeWeight;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InboundInTwoInjectionForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InboundInTwoInjectionForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InboundInTwoInjectionForEqu, default initialized and not managed by a soap context
        virtual ns1__InboundInTwoInjectionForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InboundInTwoInjectionForEqu); }
      public:
        /// Constructor with default initializations
        ns1__InboundInTwoInjectionForEqu() : BeforeWeight(), soap() { }
        virtual ~ns1__InboundInTwoInjectionForEqu() { }
        /// Friend allocator used by soap_new_ns1__InboundInTwoInjectionForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__InboundInTwoInjectionForEqu * SOAP_FMAC2 soap_instantiate_ns1__InboundInTwoInjectionForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:250 */
#ifndef SOAP_TYPE_ns1__ArrayOfOutboundSFC
#define SOAP_TYPE_ns1__ArrayOfOutboundSFC (54)
/* complex XML schema type 'ns1:ArrayOfOutboundSFC': */
class SOAP_CMAC ns1__ArrayOfOutboundSFC {
      public:
        /// Optional element 'ns1:OutboundSFC' of XML schema type 'ns1:OutboundSFC'
        std::vector<ns1__OutboundSFC *> OutboundSFC;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfOutboundSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfOutboundSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfOutboundSFC, default initialized and not managed by a soap context
        virtual ns1__ArrayOfOutboundSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfOutboundSFC); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfOutboundSFC() : OutboundSFC(), soap() { }
        virtual ~ns1__ArrayOfOutboundSFC() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfOutboundSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfOutboundSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfOutboundSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:252 */
#ifndef SOAP_TYPE_ns1__OutboundSFC
#define SOAP_TYPE_ns1__OutboundSFC (55)
/* complex XML schema type 'ns1:OutboundSFC': */
class SOAP_CMAC ns1__OutboundSFC {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Passed' of XML schema type 'xsd:int'
        int *Passed;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
        /// Optional element 'ns1:BindFeedingCodes' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindFeedingCodes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OutboundSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OutboundSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OutboundSFC, default initialized and not managed by a soap context
        virtual ns1__OutboundSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OutboundSFC); }
      public:
        /// Constructor with default initializations
        ns1__OutboundSFC() : SFC(), Passed(), ParamList(), BindFeedingCodes(), soap() { }
        virtual ~ns1__OutboundSFC() { }
        /// Friend allocator used by soap_new_ns1__OutboundSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__OutboundSFC * SOAP_FMAC2 soap_instantiate_ns1__OutboundSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:256 */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeParam
#define SOAP_TYPE_ns1__ArrayOfRecipeParam (57)
/* complex XML schema type 'ns1:ArrayOfRecipeParam': */
class SOAP_CMAC ns1__ArrayOfRecipeParam {
      public:
        /// Optional element 'ns1:RecipeParam' of XML schema type 'ns1:RecipeParam'
        std::vector<ns1__RecipeParam *> RecipeParam;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfRecipeParam
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfRecipeParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfRecipeParam, default initialized and not managed by a soap context
        virtual ns1__ArrayOfRecipeParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfRecipeParam); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfRecipeParam() : RecipeParam(), soap() { }
        virtual ~ns1__ArrayOfRecipeParam() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfRecipeParam(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfRecipeParam * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:258 */
#ifndef SOAP_TYPE_ns1__RecipeParam
#define SOAP_TYPE_ns1__RecipeParam (58)
/* complex XML schema type 'ns1:RecipeParam': */
class SOAP_CMAC ns1__RecipeParam {
      public:
        /// Optional element 'ns1:ParamCode' of XML schema type 'xsd:string'
        wchar_t *ParamCode;
        /// Optional element 'ns1:ParamUpper' of XML schema type 'xsd:string'
        wchar_t *ParamUpper;
        /// Optional element 'ns1:ParamLower' of XML schema type 'xsd:string'
        wchar_t *ParamLower;
        /// Optional element 'ns1:ParamValue' of XML schema type 'xsd:string'
        wchar_t *ParamValue;
        /// Required element 'ns1:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeParam
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeParam, default initialized and not managed by a soap context
        virtual ns1__RecipeParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeParam); }
      public:
        /// Constructor with default initializations
        ns1__RecipeParam() : ParamCode(), ParamUpper(), ParamLower(), ParamValue(), Timestamp(), soap() { }
        virtual ~ns1__RecipeParam() { }
        /// Friend allocator used by soap_new_ns1__RecipeParam(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeParam * SOAP_FMAC2 soap_instantiate_ns1__RecipeParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:264 */
#ifndef SOAP_TYPE_ns1__RecipeGetForEqu
#define SOAP_TYPE_ns1__RecipeGetForEqu (61)
/* complex XML schema type 'ns1:RecipeGetForEqu': */
class SOAP_CMAC ns1__RecipeGetForEqu {
      public:
        /// Optional element 'ns1:Version' of XML schema type 'xsd:string'
        wchar_t *Version;
        /// Required element 'ns1:LastUpdateOnTime' of XML schema type 'xsd:dateTime'
        time_t LastUpdateOnTime;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfRecipeGetParamForEqu'
        ns1__ArrayOfRecipeGetParamForEqu *ParamList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeGetForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeGetForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeGetForEqu, default initialized and not managed by a soap context
        virtual ns1__RecipeGetForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeGetForEqu); }
      public:
        /// Constructor with default initializations
        ns1__RecipeGetForEqu() : Version(), LastUpdateOnTime(), ParamList(), soap() { }
        virtual ~ns1__RecipeGetForEqu() { }
        /// Friend allocator used by soap_new_ns1__RecipeGetForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeGetForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:266 */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu
#define SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu (62)
/* complex XML schema type 'ns1:ArrayOfRecipeGetParamForEqu': */
class SOAP_CMAC ns1__ArrayOfRecipeGetParamForEqu {
      public:
        /// Optional element 'ns1:RecipeGetParamForEqu' of XML schema type 'ns1:RecipeGetParamForEqu'
        std::vector<ns1__RecipeGetParamForEqu *> RecipeGetParamForEqu;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfRecipeGetParamForEqu, default initialized and not managed by a soap context
        virtual ns1__ArrayOfRecipeGetParamForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfRecipeGetParamForEqu); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfRecipeGetParamForEqu() : RecipeGetParamForEqu(), soap() { }
        virtual ~ns1__ArrayOfRecipeGetParamForEqu() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfRecipeGetParamForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfRecipeGetParamForEqu * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeGetParamForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:268 */
#ifndef SOAP_TYPE_ns1__RecipeGetParamForEqu
#define SOAP_TYPE_ns1__RecipeGetParamForEqu (63)
/* complex XML schema type 'ns1:RecipeGetParamForEqu': */
class SOAP_CMAC ns1__RecipeGetParamForEqu {
      public:
        /// Optional element 'ns1:ParamCode' of XML schema type 'xsd:string'
        wchar_t *ParamCode;
        /// Optional element 'ns1:ParamUpper' of XML schema type 'xsd:string'
        wchar_t *ParamUpper;
        /// Optional element 'ns1:ParamLower' of XML schema type 'xsd:string'
        wchar_t *ParamLower;
        /// Optional element 'ns1:ParamValue' of XML schema type 'xsd:string'
        wchar_t *ParamValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeGetParamForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeGetParamForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeGetParamForEqu, default initialized and not managed by a soap context
        virtual ns1__RecipeGetParamForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeGetParamForEqu); }
      public:
        /// Constructor with default initializations
        ns1__RecipeGetParamForEqu() : ParamCode(), ParamUpper(), ParamLower(), ParamValue(), soap() { }
        virtual ~ns1__RecipeGetParamForEqu() { }
        /// Friend allocator used by soap_new_ns1__RecipeGetParamForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeGetParamForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeGetParamForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:274 */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu
#define SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu (66)
/* complex XML schema type 'ns1:ArrayOfRecipeListGetForEqu': */
class SOAP_CMAC ns1__ArrayOfRecipeListGetForEqu {
      public:
        /// Optional element 'ns1:RecipeListGetForEqu' of XML schema type 'ns1:RecipeListGetForEqu'
        std::vector<ns1__RecipeListGetForEqu *> RecipeListGetForEqu;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfRecipeListGetForEqu, default initialized and not managed by a soap context
        virtual ns1__ArrayOfRecipeListGetForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfRecipeListGetForEqu); }
      public:
        /// Constructor with default initializations
        ns1__ArrayOfRecipeListGetForEqu() : RecipeListGetForEqu(), soap() { }
        virtual ~ns1__ArrayOfRecipeListGetForEqu() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfRecipeListGetForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfRecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeListGetForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:276 */
#ifndef SOAP_TYPE_ns1__RecipeListGetForEqu
#define SOAP_TYPE_ns1__RecipeListGetForEqu (67)
/* complex XML schema type 'ns1:RecipeListGetForEqu': */
class SOAP_CMAC ns1__RecipeListGetForEqu {
      public:
        /// Optional element 'ns1:RecipeCode' of XML schema type 'xsd:string'
        wchar_t *RecipeCode;
        /// Optional element 'ns1:Version' of XML schema type 'xsd:string'
        wchar_t *Version;
        /// Optional element 'ns1:ProductCode' of XML schema type 'xsd:string'
        wchar_t *ProductCode;
        /// Required element 'ns1:LastUpdateOnTime' of XML schema type 'xsd:dateTime'
        time_t LastUpdateOnTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeListGetForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeListGetForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeListGetForEqu, default initialized and not managed by a soap context
        virtual ns1__RecipeListGetForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeListGetForEqu); }
      public:
        /// Constructor with default initializations
        ns1__RecipeListGetForEqu() : RecipeCode(), Version(), ProductCode(), LastUpdateOnTime(), soap() { }
        virtual ~ns1__RecipeListGetForEqu() { }
        /// Friend allocator used by soap_new_ns1__RecipeListGetForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeListGetForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:288 */
#ifndef SOAP_TYPE__ns1__Alarm
#define SOAP_TYPE__ns1__Alarm (73)
/* complex XML schema type 'ns1:Alarm': */
class SOAP_CMAC _ns1__Alarm {
      public:
        /// Optional element 'ns1:modelList' of XML schema type 'ns1:ArrayOfAlarm'
        ns1__ArrayOfAlarm *modelList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Alarm
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Alarm; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Alarm, default initialized and not managed by a soap context
        virtual _ns1__Alarm *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Alarm); }
      public:
        /// Constructor with default initializations
        _ns1__Alarm() : modelList(), soap() { }
        virtual ~_ns1__Alarm() { }
        /// Friend allocator used by soap_new__ns1__Alarm(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Alarm * SOAP_FMAC2 soap_instantiate__ns1__Alarm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:290 */
#ifndef SOAP_TYPE__ns1__AlarmResponse
#define SOAP_TYPE__ns1__AlarmResponse (74)
/* complex XML schema type 'ns1:AlarmResponse': */
class SOAP_CMAC _ns1__AlarmResponse {
      public:
        /// Optional element 'ns1:AlarmResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *AlarmResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AlarmResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__AlarmResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AlarmResponse, default initialized and not managed by a soap context
        virtual _ns1__AlarmResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__AlarmResponse); }
      public:
        /// Constructor with default initializations
        _ns1__AlarmResponse() : AlarmResult(), soap() { }
        virtual ~_ns1__AlarmResponse() { }
        /// Friend allocator used by soap_new__ns1__AlarmResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AlarmResponse * SOAP_FMAC2 soap_instantiate__ns1__AlarmResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:292 */
#ifndef SOAP_TYPE__ns1__BindContainer
#define SOAP_TYPE__ns1__BindContainer (75)
/* complex XML schema type 'ns1:BindContainer': */
class SOAP_CMAC _ns1__BindContainer {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:BindContainer'
        ns1__BindContainer *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindContainer
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindContainer, default initialized and not managed by a soap context
        virtual _ns1__BindContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindContainer); }
      public:
        /// Constructor with default initializations
        _ns1__BindContainer() : model(), soap() { }
        virtual ~_ns1__BindContainer() { }
        /// Friend allocator used by soap_new__ns1__BindContainer(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindContainer * SOAP_FMAC2 soap_instantiate__ns1__BindContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:294 */
#ifndef SOAP_TYPE__ns1__BindContainerResponse
#define SOAP_TYPE__ns1__BindContainerResponse (76)
/* complex XML schema type 'ns1:BindContainerResponse': */
class SOAP_CMAC _ns1__BindContainerResponse {
      public:
        /// Optional element 'ns1:BindContainerResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *BindContainerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindContainerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindContainerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindContainerResponse, default initialized and not managed by a soap context
        virtual _ns1__BindContainerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindContainerResponse); }
      public:
        /// Constructor with default initializations
        _ns1__BindContainerResponse() : BindContainerResult(), soap() { }
        virtual ~_ns1__BindContainerResponse() { }
        /// Friend allocator used by soap_new__ns1__BindContainerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__BindContainerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:296 */
#ifndef SOAP_TYPE__ns1__BindSFC
#define SOAP_TYPE__ns1__BindSFC (77)
/* complex XML schema type 'ns1:BindSFC': */
class SOAP_CMAC _ns1__BindSFC {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:BindSFCByScadaDTO'
        ns1__BindSFCByScadaDTO *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindSFC
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindSFC, default initialized and not managed by a soap context
        virtual _ns1__BindSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindSFC); }
      public:
        /// Constructor with default initializations
        _ns1__BindSFC() : model(), soap() { }
        virtual ~_ns1__BindSFC() { }
        /// Friend allocator used by soap_new__ns1__BindSFC(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindSFC * SOAP_FMAC2 soap_instantiate__ns1__BindSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:298 */
#ifndef SOAP_TYPE__ns1__BindSFCResponse
#define SOAP_TYPE__ns1__BindSFCResponse (78)
/* complex XML schema type 'ns1:BindSFCResponse': */
class SOAP_CMAC _ns1__BindSFCResponse {
      public:
        /// Optional element 'ns1:BindSFCResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *BindSFCResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindSFCResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindSFCResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindSFCResponse, default initialized and not managed by a soap context
        virtual _ns1__BindSFCResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindSFCResponse); }
      public:
        /// Constructor with default initializations
        _ns1__BindSFCResponse() : BindSFCResult(), soap() { }
        virtual ~_ns1__BindSFCResponse() { }
        /// Friend allocator used by soap_new__ns1__BindSFCResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__BindSFCResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:300 */
#ifndef SOAP_TYPE__ns1__CCDFileUploadComplete
#define SOAP_TYPE__ns1__CCDFileUploadComplete (79)
/* complex XML schema type 'ns1:CCDFileUploadComplete': */
class SOAP_CMAC _ns1__CCDFileUploadComplete {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:CCDFileUploadComplete'
        ns1__CCDFileUploadComplete *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CCDFileUploadComplete
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CCDFileUploadComplete; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CCDFileUploadComplete, default initialized and not managed by a soap context
        virtual _ns1__CCDFileUploadComplete *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CCDFileUploadComplete); }
      public:
        /// Constructor with default initializations
        _ns1__CCDFileUploadComplete() : model(), soap() { }
        virtual ~_ns1__CCDFileUploadComplete() { }
        /// Friend allocator used by soap_new__ns1__CCDFileUploadComplete(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate__ns1__CCDFileUploadComplete(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:302 */
#ifndef SOAP_TYPE__ns1__CCDFileUploadCompleteResponse
#define SOAP_TYPE__ns1__CCDFileUploadCompleteResponse (80)
/* complex XML schema type 'ns1:CCDFileUploadCompleteResponse': */
class SOAP_CMAC _ns1__CCDFileUploadCompleteResponse {
      public:
        /// Optional element 'ns1:CCDFileUploadCompleteResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *CCDFileUploadCompleteResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CCDFileUploadCompleteResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CCDFileUploadCompleteResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CCDFileUploadCompleteResponse, default initialized and not managed by a soap context
        virtual _ns1__CCDFileUploadCompleteResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CCDFileUploadCompleteResponse); }
      public:
        /// Constructor with default initializations
        _ns1__CCDFileUploadCompleteResponse() : CCDFileUploadCompleteResult(), soap() { }
        virtual ~_ns1__CCDFileUploadCompleteResponse() { }
        /// Friend allocator used by soap_new__ns1__CCDFileUploadCompleteResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CCDFileUploadCompleteResponse * SOAP_FMAC2 soap_instantiate__ns1__CCDFileUploadCompleteResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:304 */
#ifndef SOAP_TYPE__ns1__DownReason
#define SOAP_TYPE__ns1__DownReason (81)
/* complex XML schema type 'ns1:DownReason': */
class SOAP_CMAC _ns1__DownReason {
      public:
        /// Optional element 'ns1:modelList' of XML schema type 'ns1:ArrayOfDownReason'
        ns1__ArrayOfDownReason *modelList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DownReason
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DownReason; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DownReason, default initialized and not managed by a soap context
        virtual _ns1__DownReason *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DownReason); }
      public:
        /// Constructor with default initializations
        _ns1__DownReason() : modelList(), soap() { }
        virtual ~_ns1__DownReason() { }
        /// Friend allocator used by soap_new__ns1__DownReason(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DownReason * SOAP_FMAC2 soap_instantiate__ns1__DownReason(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:306 */
#ifndef SOAP_TYPE__ns1__DownReasonResponse
#define SOAP_TYPE__ns1__DownReasonResponse (82)
/* complex XML schema type 'ns1:DownReasonResponse': */
class SOAP_CMAC _ns1__DownReasonResponse {
      public:
        /// Optional element 'ns1:DownReasonResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *DownReasonResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DownReasonResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DownReasonResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DownReasonResponse, default initialized and not managed by a soap context
        virtual _ns1__DownReasonResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DownReasonResponse); }
      public:
        /// Constructor with default initializations
        _ns1__DownReasonResponse() : DownReasonResult(), soap() { }
        virtual ~_ns1__DownReasonResponse() { }
        /// Friend allocator used by soap_new__ns1__DownReasonResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DownReasonResponse * SOAP_FMAC2 soap_instantiate__ns1__DownReasonResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:308 */
#ifndef SOAP_TYPE__ns1__EquipmentProcessParam
#define SOAP_TYPE__ns1__EquipmentProcessParam (83)
/* complex XML schema type 'ns1:EquipmentProcessParam': */
class SOAP_CMAC _ns1__EquipmentProcessParam {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:EquipmentProcessParam'
        ns1__EquipmentProcessParam *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EquipmentProcessParam
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__EquipmentProcessParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EquipmentProcessParam, default initialized and not managed by a soap context
        virtual _ns1__EquipmentProcessParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__EquipmentProcessParam); }
      public:
        /// Constructor with default initializations
        _ns1__EquipmentProcessParam() : model(), soap() { }
        virtual ~_ns1__EquipmentProcessParam() { }
        /// Friend allocator used by soap_new__ns1__EquipmentProcessParam(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:310 */
#ifndef SOAP_TYPE__ns1__EquipmentProcessParamResponse
#define SOAP_TYPE__ns1__EquipmentProcessParamResponse (84)
/* complex XML schema type 'ns1:EquipmentProcessParamResponse': */
class SOAP_CMAC _ns1__EquipmentProcessParamResponse {
      public:
        /// Optional element 'ns1:EquipmentProcessParamResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *EquipmentProcessParamResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EquipmentProcessParamResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__EquipmentProcessParamResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EquipmentProcessParamResponse, default initialized and not managed by a soap context
        virtual _ns1__EquipmentProcessParamResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__EquipmentProcessParamResponse); }
      public:
        /// Constructor with default initializations
        _ns1__EquipmentProcessParamResponse() : EquipmentProcessParamResult(), soap() { }
        virtual ~_ns1__EquipmentProcessParamResponse() { }
        /// Friend allocator used by soap_new__ns1__EquipmentProcessParamResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EquipmentProcessParamResponse * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProcessParamResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:312 */
#ifndef SOAP_TYPE__ns1__EquipmentProductProcessParam
#define SOAP_TYPE__ns1__EquipmentProductProcessParam (85)
/* complex XML schema type 'ns1:EquipmentProductProcessParam': */
class SOAP_CMAC _ns1__EquipmentProductProcessParam {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:EquipmentProductProcessParam'
        ns1__EquipmentProductProcessParam *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EquipmentProductProcessParam
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__EquipmentProductProcessParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EquipmentProductProcessParam, default initialized and not managed by a soap context
        virtual _ns1__EquipmentProductProcessParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__EquipmentProductProcessParam); }
      public:
        /// Constructor with default initializations
        _ns1__EquipmentProductProcessParam() : model(), soap() { }
        virtual ~_ns1__EquipmentProductProcessParam() { }
        /// Friend allocator used by soap_new__ns1__EquipmentProductProcessParam(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProductProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:314 */
#ifndef SOAP_TYPE__ns1__EquipmentProductProcessParamResponse
#define SOAP_TYPE__ns1__EquipmentProductProcessParamResponse (86)
/* complex XML schema type 'ns1:EquipmentProductProcessParamResponse': */
class SOAP_CMAC _ns1__EquipmentProductProcessParamResponse {
      public:
        /// Optional element 'ns1:EquipmentProductProcessParamResult' of XML schema type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada'
        ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *EquipmentProductProcessParamResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EquipmentProductProcessParamResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__EquipmentProductProcessParamResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EquipmentProductProcessParamResponse, default initialized and not managed by a soap context
        virtual _ns1__EquipmentProductProcessParamResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__EquipmentProductProcessParamResponse); }
      public:
        /// Constructor with default initializations
        _ns1__EquipmentProductProcessParamResponse() : EquipmentProductProcessParamResult(), soap() { }
        virtual ~_ns1__EquipmentProductProcessParamResponse() { }
        /// Friend allocator used by soap_new__ns1__EquipmentProductProcessParamResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EquipmentProductProcessParamResponse * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProductProcessParamResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:316 */
#ifndef SOAP_TYPE__ns1__ExamineExists
#define SOAP_TYPE__ns1__ExamineExists (87)
/* complex XML schema type 'ns1:ExamineExists': */
class SOAP_CMAC _ns1__ExamineExists {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:ExamineExistsByScadaDTO'
        ns1__ExamineExistsByScadaDTO *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExamineExists
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ExamineExists; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExamineExists, default initialized and not managed by a soap context
        virtual _ns1__ExamineExists *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ExamineExists); }
      public:
        /// Constructor with default initializations
        _ns1__ExamineExists() : model(), soap() { }
        virtual ~_ns1__ExamineExists() { }
        /// Friend allocator used by soap_new__ns1__ExamineExists(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExamineExists * SOAP_FMAC2 soap_instantiate__ns1__ExamineExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:318 */
#ifndef SOAP_TYPE__ns1__ExamineExistsResponse
#define SOAP_TYPE__ns1__ExamineExistsResponse (88)
/* complex XML schema type 'ns1:ExamineExistsResponse': */
class SOAP_CMAC _ns1__ExamineExistsResponse {
      public:
        /// Optional element 'ns1:ExamineExistsResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *ExamineExistsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExamineExistsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ExamineExistsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExamineExistsResponse, default initialized and not managed by a soap context
        virtual _ns1__ExamineExistsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ExamineExistsResponse); }
      public:
        /// Constructor with default initializations
        _ns1__ExamineExistsResponse() : ExamineExistsResult(), soap() { }
        virtual ~_ns1__ExamineExistsResponse() { }
        /// Friend allocator used by soap_new__ns1__ExamineExistsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExamineExistsResponse * SOAP_FMAC2 soap_instantiate__ns1__ExamineExistsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:320 */
#ifndef SOAP_TYPE__ns1__Feeding
#define SOAP_TYPE__ns1__Feeding (89)
/* complex XML schema type 'ns1:Feeding': */
class SOAP_CMAC _ns1__Feeding {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:FeedingByScadaDTO'
        ns1__FeedingByScadaDTO *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Feeding
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Feeding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Feeding, default initialized and not managed by a soap context
        virtual _ns1__Feeding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Feeding); }
      public:
        /// Constructor with default initializations
        _ns1__Feeding() : model(), soap() { }
        virtual ~_ns1__Feeding() { }
        /// Friend allocator used by soap_new__ns1__Feeding(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Feeding * SOAP_FMAC2 soap_instantiate__ns1__Feeding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:322 */
#ifndef SOAP_TYPE__ns1__FeedingResponse
#define SOAP_TYPE__ns1__FeedingResponse (90)
/* complex XML schema type 'ns1:FeedingResponse': */
class SOAP_CMAC _ns1__FeedingResponse {
      public:
        /// Optional element 'ns1:FeedingResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *FeedingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FeedingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__FeedingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FeedingResponse, default initialized and not managed by a soap context
        virtual _ns1__FeedingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__FeedingResponse); }
      public:
        /// Constructor with default initializations
        _ns1__FeedingResponse() : FeedingResult(), soap() { }
        virtual ~_ns1__FeedingResponse() { }
        /// Friend allocator used by soap_new__ns1__FeedingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FeedingResponse * SOAP_FMAC2 soap_instantiate__ns1__FeedingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:324 */
#ifndef SOAP_TYPE__ns1__FeedingDJInLaminating
#define SOAP_TYPE__ns1__FeedingDJInLaminating (91)
/* complex XML schema type 'ns1:FeedingDJInLaminating': */
class SOAP_CMAC _ns1__FeedingDJInLaminating {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:FeedingDJInLaminatingByScadaDTO'
        ns1__FeedingDJInLaminatingByScadaDTO *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FeedingDJInLaminating
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__FeedingDJInLaminating; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FeedingDJInLaminating, default initialized and not managed by a soap context
        virtual _ns1__FeedingDJInLaminating *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__FeedingDJInLaminating); }
      public:
        /// Constructor with default initializations
        _ns1__FeedingDJInLaminating() : model(), soap() { }
        virtual ~_ns1__FeedingDJInLaminating() { }
        /// Friend allocator used by soap_new__ns1__FeedingDJInLaminating(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FeedingDJInLaminating * SOAP_FMAC2 soap_instantiate__ns1__FeedingDJInLaminating(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:326 */
#ifndef SOAP_TYPE__ns1__FeedingDJInLaminatingResponse
#define SOAP_TYPE__ns1__FeedingDJInLaminatingResponse (92)
/* complex XML schema type 'ns1:FeedingDJInLaminatingResponse': */
class SOAP_CMAC _ns1__FeedingDJInLaminatingResponse {
      public:
        /// Optional element 'ns1:FeedingDJInLaminatingResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *FeedingDJInLaminatingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FeedingDJInLaminatingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__FeedingDJInLaminatingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FeedingDJInLaminatingResponse, default initialized and not managed by a soap context
        virtual _ns1__FeedingDJInLaminatingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__FeedingDJInLaminatingResponse); }
      public:
        /// Constructor with default initializations
        _ns1__FeedingDJInLaminatingResponse() : FeedingDJInLaminatingResult(), soap() { }
        virtual ~_ns1__FeedingDJInLaminatingResponse() { }
        /// Friend allocator used by soap_new__ns1__FeedingDJInLaminatingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FeedingDJInLaminatingResponse * SOAP_FMAC2 soap_instantiate__ns1__FeedingDJInLaminatingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:328 */
#ifndef SOAP_TYPE__ns1__FillingData
#define SOAP_TYPE__ns1__FillingData (93)
/* complex XML schema type 'ns1:FillingData': */
class SOAP_CMAC _ns1__FillingData {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:FillingData'
        ns1__FillingData *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FillingData
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__FillingData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FillingData, default initialized and not managed by a soap context
        virtual _ns1__FillingData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__FillingData); }
      public:
        /// Constructor with default initializations
        _ns1__FillingData() : model(), soap() { }
        virtual ~_ns1__FillingData() { }
        /// Friend allocator used by soap_new__ns1__FillingData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FillingData * SOAP_FMAC2 soap_instantiate__ns1__FillingData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:330 */
#ifndef SOAP_TYPE__ns1__FillingDataResponse
#define SOAP_TYPE__ns1__FillingDataResponse (94)
/* complex XML schema type 'ns1:FillingDataResponse': */
class SOAP_CMAC _ns1__FillingDataResponse {
      public:
        /// Optional element 'ns1:FillingDataResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *FillingDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FillingDataResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__FillingDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FillingDataResponse, default initialized and not managed by a soap context
        virtual _ns1__FillingDataResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__FillingDataResponse); }
      public:
        /// Constructor with default initializations
        _ns1__FillingDataResponse() : FillingDataResult(), soap() { }
        virtual ~_ns1__FillingDataResponse() { }
        /// Friend allocator used by soap_new__ns1__FillingDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FillingDataResponse * SOAP_FMAC2 soap_instantiate__ns1__FillingDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:332 */
#ifndef SOAP_TYPE__ns1__GenerateCellSFC
#define SOAP_TYPE__ns1__GenerateCellSFC (95)
/* complex XML schema type 'ns1:GenerateCellSFC': */
class SOAP_CMAC _ns1__GenerateCellSFC {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:GenerateCellSFC'
        ns1__GenerateCellSFC *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GenerateCellSFC
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GenerateCellSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GenerateCellSFC, default initialized and not managed by a soap context
        virtual _ns1__GenerateCellSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GenerateCellSFC); }
      public:
        /// Constructor with default initializations
        _ns1__GenerateCellSFC() : model(), soap() { }
        virtual ~_ns1__GenerateCellSFC() { }
        /// Friend allocator used by soap_new__ns1__GenerateCellSFC(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate__ns1__GenerateCellSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:334 */
#ifndef SOAP_TYPE__ns1__GenerateCellSFCResponse
#define SOAP_TYPE__ns1__GenerateCellSFCResponse (96)
/* complex XML schema type 'ns1:GenerateCellSFCResponse': */
class SOAP_CMAC _ns1__GenerateCellSFCResponse {
      public:
        /// Optional element 'ns1:GenerateCellSFCResult' of XML schema type 'ns1:ApiResponseDataForScadaOfString'
        ns1__ApiResponseDataForScadaOfString *GenerateCellSFCResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GenerateCellSFCResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GenerateCellSFCResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GenerateCellSFCResponse, default initialized and not managed by a soap context
        virtual _ns1__GenerateCellSFCResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GenerateCellSFCResponse); }
      public:
        /// Constructor with default initializations
        _ns1__GenerateCellSFCResponse() : GenerateCellSFCResult(), soap() { }
        virtual ~_ns1__GenerateCellSFCResponse() { }
        /// Friend allocator used by soap_new__ns1__GenerateCellSFCResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GenerateCellSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__GenerateCellSFCResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:336 */
#ifndef SOAP_TYPE__ns1__Heartbeat
#define SOAP_TYPE__ns1__Heartbeat (97)
/* complex XML schema type 'ns1:Heartbeat': */
class SOAP_CMAC _ns1__Heartbeat {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:Heartbeat'
        ns1__Heartbeat *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Heartbeat
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Heartbeat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Heartbeat, default initialized and not managed by a soap context
        virtual _ns1__Heartbeat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Heartbeat); }
      public:
        /// Constructor with default initializations
        _ns1__Heartbeat() : model(), soap() { }
        virtual ~_ns1__Heartbeat() { }
        /// Friend allocator used by soap_new__ns1__Heartbeat(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Heartbeat * SOAP_FMAC2 soap_instantiate__ns1__Heartbeat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:338 */
#ifndef SOAP_TYPE__ns1__HeartbeatResponse
#define SOAP_TYPE__ns1__HeartbeatResponse (98)
/* complex XML schema type 'ns1:HeartbeatResponse': */
class SOAP_CMAC _ns1__HeartbeatResponse {
      public:
        /// Optional element 'ns1:HeartbeatResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *HeartbeatResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__HeartbeatResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__HeartbeatResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__HeartbeatResponse, default initialized and not managed by a soap context
        virtual _ns1__HeartbeatResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__HeartbeatResponse); }
      public:
        /// Constructor with default initializations
        _ns1__HeartbeatResponse() : HeartbeatResult(), soap() { }
        virtual ~_ns1__HeartbeatResponse() { }
        /// Friend allocator used by soap_new__ns1__HeartbeatResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__HeartbeatResponse * SOAP_FMAC2 soap_instantiate__ns1__HeartbeatResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:340 */
#ifndef SOAP_TYPE__ns1__Inbound
#define SOAP_TYPE__ns1__Inbound (99)
/* complex XML schema type 'ns1:Inbound': */
class SOAP_CMAC _ns1__Inbound {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:Inbound'
        ns1__Inbound *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Inbound
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Inbound; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Inbound, default initialized and not managed by a soap context
        virtual _ns1__Inbound *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Inbound); }
      public:
        /// Constructor with default initializations
        _ns1__Inbound() : model(), soap() { }
        virtual ~_ns1__Inbound() { }
        /// Friend allocator used by soap_new__ns1__Inbound(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Inbound * SOAP_FMAC2 soap_instantiate__ns1__Inbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:342 */
#ifndef SOAP_TYPE__ns1__InboundResponse
#define SOAP_TYPE__ns1__InboundResponse (100)
/* complex XML schema type 'ns1:InboundResponse': */
class SOAP_CMAC _ns1__InboundResponse {
      public:
        /// Optional element 'ns1:InboundResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *InboundResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundResponse, default initialized and not managed by a soap context
        virtual _ns1__InboundResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundResponse); }
      public:
        /// Constructor with default initializations
        _ns1__InboundResponse() : InboundResult(), soap() { }
        virtual ~_ns1__InboundResponse() { }
        /// Friend allocator used by soap_new__ns1__InboundResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:344 */
#ifndef SOAP_TYPE__ns1__InboundInContainer
#define SOAP_TYPE__ns1__InboundInContainer (101)
/* complex XML schema type 'ns1:InboundInContainer': */
class SOAP_CMAC _ns1__InboundInContainer {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:InboundInContainer'
        ns1__InboundInContainer *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInContainer
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInContainer, default initialized and not managed by a soap context
        virtual _ns1__InboundInContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInContainer); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInContainer() : model(), soap() { }
        virtual ~_ns1__InboundInContainer() { }
        /// Friend allocator used by soap_new__ns1__InboundInContainer(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate__ns1__InboundInContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:346 */
#ifndef SOAP_TYPE__ns1__InboundInContainerResponse
#define SOAP_TYPE__ns1__InboundInContainerResponse (102)
/* complex XML schema type 'ns1:InboundInContainerResponse': */
class SOAP_CMAC _ns1__InboundInContainerResponse {
      public:
        /// Optional element 'ns1:InboundInContainerResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *InboundInContainerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInContainerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInContainerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInContainerResponse, default initialized and not managed by a soap context
        virtual _ns1__InboundInContainerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInContainerResponse); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInContainerResponse() : InboundInContainerResult(), soap() { }
        virtual ~_ns1__InboundInContainerResponse() { }
        /// Friend allocator used by soap_new__ns1__InboundInContainerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInContainerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:348 */
#ifndef SOAP_TYPE__ns1__InboundInSFCContainer
#define SOAP_TYPE__ns1__InboundInSFCContainer (103)
/* complex XML schema type 'ns1:InboundInSFCContainer': */
class SOAP_CMAC _ns1__InboundInSFCContainer {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:InboundInSFCContainer'
        ns1__InboundInSFCContainer *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInSFCContainer
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInSFCContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInSFCContainer, default initialized and not managed by a soap context
        virtual _ns1__InboundInSFCContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInSFCContainer); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInSFCContainer() : model(), soap() { }
        virtual ~_ns1__InboundInSFCContainer() { }
        /// Friend allocator used by soap_new__ns1__InboundInSFCContainer(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate__ns1__InboundInSFCContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:350 */
#ifndef SOAP_TYPE__ns1__InboundInSFCContainerResponse
#define SOAP_TYPE__ns1__InboundInSFCContainerResponse (104)
/* complex XML schema type 'ns1:InboundInSFCContainerResponse': */
class SOAP_CMAC _ns1__InboundInSFCContainerResponse {
      public:
        /// Optional element 'ns1:InboundInSFCContainerResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *InboundInSFCContainerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInSFCContainerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInSFCContainerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInSFCContainerResponse, default initialized and not managed by a soap context
        virtual _ns1__InboundInSFCContainerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInSFCContainerResponse); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInSFCContainerResponse() : InboundInSFCContainerResult(), soap() { }
        virtual ~_ns1__InboundInSFCContainerResponse() { }
        /// Friend allocator used by soap_new__ns1__InboundInSFCContainerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInSFCContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInSFCContainerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:352 */
#ifndef SOAP_TYPE__ns1__InboundInTwoInjection
#define SOAP_TYPE__ns1__InboundInTwoInjection (105)
/* complex XML schema type 'ns1:InboundInTwoInjection': */
class SOAP_CMAC _ns1__InboundInTwoInjection {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:InboundInTwoInjection'
        ns1__InboundInTwoInjection *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInTwoInjection
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInTwoInjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInTwoInjection, default initialized and not managed by a soap context
        virtual _ns1__InboundInTwoInjection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInTwoInjection); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInTwoInjection() : model(), soap() { }
        virtual ~_ns1__InboundInTwoInjection() { }
        /// Friend allocator used by soap_new__ns1__InboundInTwoInjection(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate__ns1__InboundInTwoInjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:354 */
#ifndef SOAP_TYPE__ns1__InboundInTwoInjectionResponse
#define SOAP_TYPE__ns1__InboundInTwoInjectionResponse (106)
/* complex XML schema type 'ns1:InboundInTwoInjectionResponse': */
class SOAP_CMAC _ns1__InboundInTwoInjectionResponse {
      public:
        /// Optional element 'ns1:InboundInTwoInjectionResult' of XML schema type 'ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu'
        ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *InboundInTwoInjectionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundInTwoInjectionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundInTwoInjectionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundInTwoInjectionResponse, default initialized and not managed by a soap context
        virtual _ns1__InboundInTwoInjectionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundInTwoInjectionResponse); }
      public:
        /// Constructor with default initializations
        _ns1__InboundInTwoInjectionResponse() : InboundInTwoInjectionResult(), soap() { }
        virtual ~_ns1__InboundInTwoInjectionResponse() { }
        /// Friend allocator used by soap_new__ns1__InboundInTwoInjectionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundInTwoInjectionResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInTwoInjectionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:356 */
#ifndef SOAP_TYPE__ns1__InboundMore
#define SOAP_TYPE__ns1__InboundMore (107)
/* complex XML schema type 'ns1:InboundMore': */
class SOAP_CMAC _ns1__InboundMore {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:InboundMore'
        ns1__InboundMore *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundMore
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundMore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundMore, default initialized and not managed by a soap context
        virtual _ns1__InboundMore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundMore); }
      public:
        /// Constructor with default initializations
        _ns1__InboundMore() : model(), soap() { }
        virtual ~_ns1__InboundMore() { }
        /// Friend allocator used by soap_new__ns1__InboundMore(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundMore * SOAP_FMAC2 soap_instantiate__ns1__InboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:358 */
#ifndef SOAP_TYPE__ns1__InboundMoreResponse
#define SOAP_TYPE__ns1__InboundMoreResponse (108)
/* complex XML schema type 'ns1:InboundMoreResponse': */
class SOAP_CMAC _ns1__InboundMoreResponse {
      public:
        /// Optional element 'ns1:InboundMoreResult' of XML schema type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada'
        ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *InboundMoreResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InboundMoreResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InboundMoreResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InboundMoreResponse, default initialized and not managed by a soap context
        virtual _ns1__InboundMoreResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__InboundMoreResponse); }
      public:
        /// Constructor with default initializations
        _ns1__InboundMoreResponse() : InboundMoreResult(), soap() { }
        virtual ~_ns1__InboundMoreResponse() { }
        /// Friend allocator used by soap_new__ns1__InboundMoreResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InboundMoreResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundMoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:360 */
#ifndef SOAP_TYPE__ns1__OperatorLogin
#define SOAP_TYPE__ns1__OperatorLogin (109)
/* complex XML schema type 'ns1:OperatorLogin': */
class SOAP_CMAC _ns1__OperatorLogin {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:OperatorLogin'
        ns1__OperatorLogin *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OperatorLogin
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OperatorLogin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OperatorLogin, default initialized and not managed by a soap context
        virtual _ns1__OperatorLogin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OperatorLogin); }
      public:
        /// Constructor with default initializations
        _ns1__OperatorLogin() : model(), soap() { }
        virtual ~_ns1__OperatorLogin() { }
        /// Friend allocator used by soap_new__ns1__OperatorLogin(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate__ns1__OperatorLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:362 */
#ifndef SOAP_TYPE__ns1__OperatorLoginResponse
#define SOAP_TYPE__ns1__OperatorLoginResponse (110)
/* complex XML schema type 'ns1:OperatorLoginResponse': */
class SOAP_CMAC _ns1__OperatorLoginResponse {
      public:
        /// Optional element 'ns1:OperatorLoginResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *OperatorLoginResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OperatorLoginResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OperatorLoginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OperatorLoginResponse, default initialized and not managed by a soap context
        virtual _ns1__OperatorLoginResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OperatorLoginResponse); }
      public:
        /// Constructor with default initializations
        _ns1__OperatorLoginResponse() : OperatorLoginResult(), soap() { }
        virtual ~_ns1__OperatorLoginResponse() { }
        /// Friend allocator used by soap_new__ns1__OperatorLoginResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OperatorLoginResponse * SOAP_FMAC2 soap_instantiate__ns1__OperatorLoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:364 */
#ifndef SOAP_TYPE__ns1__Outbound
#define SOAP_TYPE__ns1__Outbound (111)
/* complex XML schema type 'ns1:Outbound': */
class SOAP_CMAC _ns1__Outbound {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:Outbound'
        ns1__Outbound *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Outbound
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Outbound; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Outbound, default initialized and not managed by a soap context
        virtual _ns1__Outbound *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Outbound); }
      public:
        /// Constructor with default initializations
        _ns1__Outbound() : model(), soap() { }
        virtual ~_ns1__Outbound() { }
        /// Friend allocator used by soap_new__ns1__Outbound(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Outbound * SOAP_FMAC2 soap_instantiate__ns1__Outbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:366 */
#ifndef SOAP_TYPE__ns1__OutboundResponse
#define SOAP_TYPE__ns1__OutboundResponse (112)
/* complex XML schema type 'ns1:OutboundResponse': */
class SOAP_CMAC _ns1__OutboundResponse {
      public:
        /// Optional element 'ns1:OutboundResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *OutboundResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundResponse, default initialized and not managed by a soap context
        virtual _ns1__OutboundResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundResponse); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundResponse() : OutboundResult(), soap() { }
        virtual ~_ns1__OutboundResponse() { }
        /// Friend allocator used by soap_new__ns1__OutboundResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:368 */
#ifndef SOAP_TYPE__ns1__OutboundInLaminating
#define SOAP_TYPE__ns1__OutboundInLaminating (113)
/* complex XML schema type 'ns1:OutboundInLaminating': */
class SOAP_CMAC _ns1__OutboundInLaminating {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:OutboundInLaminating'
        ns1__OutboundInLaminating *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundInLaminating
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundInLaminating; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundInLaminating, default initialized and not managed by a soap context
        virtual _ns1__OutboundInLaminating *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundInLaminating); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundInLaminating() : model(), soap() { }
        virtual ~_ns1__OutboundInLaminating() { }
        /// Friend allocator used by soap_new__ns1__OutboundInLaminating(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate__ns1__OutboundInLaminating(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:370 */
#ifndef SOAP_TYPE__ns1__OutboundInLaminatingResponse
#define SOAP_TYPE__ns1__OutboundInLaminatingResponse (114)
/* complex XML schema type 'ns1:OutboundInLaminatingResponse': */
class SOAP_CMAC _ns1__OutboundInLaminatingResponse {
      public:
        /// Optional element 'ns1:OutboundInLaminatingResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *OutboundInLaminatingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundInLaminatingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundInLaminatingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundInLaminatingResponse, default initialized and not managed by a soap context
        virtual _ns1__OutboundInLaminatingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundInLaminatingResponse); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundInLaminatingResponse() : OutboundInLaminatingResult(), soap() { }
        virtual ~_ns1__OutboundInLaminatingResponse() { }
        /// Friend allocator used by soap_new__ns1__OutboundInLaminatingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundInLaminatingResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundInLaminatingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:372 */
#ifndef SOAP_TYPE__ns1__OutboundInSFCOutputQty
#define SOAP_TYPE__ns1__OutboundInSFCOutputQty (115)
/* complex XML schema type 'ns1:OutboundInSFCOutputQty': */
class SOAP_CMAC _ns1__OutboundInSFCOutputQty {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:OutboundInSFCOutputQty'
        ns1__OutboundInSFCOutputQty *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundInSFCOutputQty
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundInSFCOutputQty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundInSFCOutputQty, default initialized and not managed by a soap context
        virtual _ns1__OutboundInSFCOutputQty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundInSFCOutputQty); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundInSFCOutputQty() : model(), soap() { }
        virtual ~_ns1__OutboundInSFCOutputQty() { }
        /// Friend allocator used by soap_new__ns1__OutboundInSFCOutputQty(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate__ns1__OutboundInSFCOutputQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:374 */
#ifndef SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse
#define SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse (116)
/* complex XML schema type 'ns1:OutboundInSFCOutputQtyResponse': */
class SOAP_CMAC _ns1__OutboundInSFCOutputQtyResponse {
      public:
        /// Optional element 'ns1:OutboundInSFCOutputQtyResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *OutboundInSFCOutputQtyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundInSFCOutputQtyResponse, default initialized and not managed by a soap context
        virtual _ns1__OutboundInSFCOutputQtyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundInSFCOutputQtyResponse); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundInSFCOutputQtyResponse() : OutboundInSFCOutputQtyResult(), soap() { }
        virtual ~_ns1__OutboundInSFCOutputQtyResponse() { }
        /// Friend allocator used by soap_new__ns1__OutboundInSFCOutputQtyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundInSFCOutputQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundInSFCOutputQtyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:376 */
#ifndef SOAP_TYPE__ns1__OutboundMore
#define SOAP_TYPE__ns1__OutboundMore (117)
/* complex XML schema type 'ns1:OutboundMore': */
class SOAP_CMAC _ns1__OutboundMore {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:OutboundMore'
        ns1__OutboundMore *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundMore
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundMore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundMore, default initialized and not managed by a soap context
        virtual _ns1__OutboundMore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundMore); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundMore() : model(), soap() { }
        virtual ~_ns1__OutboundMore() { }
        /// Friend allocator used by soap_new__ns1__OutboundMore(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundMore * SOAP_FMAC2 soap_instantiate__ns1__OutboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:378 */
#ifndef SOAP_TYPE__ns1__OutboundMoreResponse
#define SOAP_TYPE__ns1__OutboundMoreResponse (118)
/* complex XML schema type 'ns1:OutboundMoreResponse': */
class SOAP_CMAC _ns1__OutboundMoreResponse {
      public:
        /// Optional element 'ns1:OutboundMoreResult' of XML schema type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada'
        ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *OutboundMoreResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutboundMoreResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__OutboundMoreResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutboundMoreResponse, default initialized and not managed by a soap context
        virtual _ns1__OutboundMoreResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__OutboundMoreResponse); }
      public:
        /// Constructor with default initializations
        _ns1__OutboundMoreResponse() : OutboundMoreResult(), soap() { }
        virtual ~_ns1__OutboundMoreResponse() { }
        /// Friend allocator used by soap_new__ns1__OutboundMoreResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutboundMoreResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundMoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:380 */
#ifndef SOAP_TYPE__ns1__Recipe
#define SOAP_TYPE__ns1__Recipe (119)
/* complex XML schema type 'ns1:Recipe': */
class SOAP_CMAC _ns1__Recipe {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:Recipe'
        ns1__Recipe *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Recipe
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Recipe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Recipe, default initialized and not managed by a soap context
        virtual _ns1__Recipe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Recipe); }
      public:
        /// Constructor with default initializations
        _ns1__Recipe() : model(), soap() { }
        virtual ~_ns1__Recipe() { }
        /// Friend allocator used by soap_new__ns1__Recipe(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Recipe * SOAP_FMAC2 soap_instantiate__ns1__Recipe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:382 */
#ifndef SOAP_TYPE__ns1__RecipeResponse
#define SOAP_TYPE__ns1__RecipeResponse (120)
/* complex XML schema type 'ns1:RecipeResponse': */
class SOAP_CMAC _ns1__RecipeResponse {
      public:
        /// Optional element 'ns1:RecipeResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *RecipeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RecipeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__RecipeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RecipeResponse, default initialized and not managed by a soap context
        virtual _ns1__RecipeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__RecipeResponse); }
      public:
        /// Constructor with default initializations
        _ns1__RecipeResponse() : RecipeResult(), soap() { }
        virtual ~_ns1__RecipeResponse() { }
        /// Friend allocator used by soap_new__ns1__RecipeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RecipeResponse * SOAP_FMAC2 soap_instantiate__ns1__RecipeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:384 */
#ifndef SOAP_TYPE__ns1__GetRecipe
#define SOAP_TYPE__ns1__GetRecipe (121)
/* complex XML schema type 'ns1:GetRecipe': */
class SOAP_CMAC _ns1__GetRecipe {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:RecipeGet'
        ns1__RecipeGet *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecipe
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetRecipe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecipe, default initialized and not managed by a soap context
        virtual _ns1__GetRecipe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetRecipe); }
      public:
        /// Constructor with default initializations
        _ns1__GetRecipe() : model(), soap() { }
        virtual ~_ns1__GetRecipe() { }
        /// Friend allocator used by soap_new__ns1__GetRecipe(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecipe * SOAP_FMAC2 soap_instantiate__ns1__GetRecipe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:386 */
#ifndef SOAP_TYPE__ns1__GetRecipeResponse
#define SOAP_TYPE__ns1__GetRecipeResponse (122)
/* complex XML schema type 'ns1:GetRecipeResponse': */
class SOAP_CMAC _ns1__GetRecipeResponse {
      public:
        /// Optional element 'ns1:GetRecipeResult' of XML schema type 'ns1:ApiResponseDataForScadaOfRecipeGetForEqu'
        ns1__ApiResponseDataForScadaOfRecipeGetForEqu *GetRecipeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecipeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetRecipeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecipeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRecipeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetRecipeResponse); }
      public:
        /// Constructor with default initializations
        _ns1__GetRecipeResponse() : GetRecipeResult(), soap() { }
        virtual ~_ns1__GetRecipeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRecipeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecipeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:388 */
#ifndef SOAP_TYPE__ns1__GetRecipeList
#define SOAP_TYPE__ns1__GetRecipeList (123)
/* complex XML schema type 'ns1:GetRecipeList': */
class SOAP_CMAC _ns1__GetRecipeList {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:RecipeListGet'
        ns1__RecipeListGet *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecipeList
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetRecipeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecipeList, default initialized and not managed by a soap context
        virtual _ns1__GetRecipeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetRecipeList); }
      public:
        /// Constructor with default initializations
        _ns1__GetRecipeList() : model(), soap() { }
        virtual ~_ns1__GetRecipeList() { }
        /// Friend allocator used by soap_new__ns1__GetRecipeList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecipeList * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:390 */
#ifndef SOAP_TYPE__ns1__GetRecipeListResponse
#define SOAP_TYPE__ns1__GetRecipeListResponse (124)
/* complex XML schema type 'ns1:GetRecipeListResponse': */
class SOAP_CMAC _ns1__GetRecipeListResponse {
      public:
        /// Optional element 'ns1:GetRecipeListResult' of XML schema type 'ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu'
        ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *GetRecipeListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecipeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetRecipeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecipeListResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRecipeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetRecipeListResponse); }
      public:
        /// Constructor with default initializations
        _ns1__GetRecipeListResponse() : GetRecipeListResult(), soap() { }
        virtual ~_ns1__GetRecipeListResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRecipeListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecipeListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:392 */
#ifndef SOAP_TYPE__ns1__RecipeVersionExamine
#define SOAP_TYPE__ns1__RecipeVersionExamine (125)
/* complex XML schema type 'ns1:RecipeVersionExamine': */
class SOAP_CMAC _ns1__RecipeVersionExamine {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:RecipeVersionExamine'
        ns1__RecipeVersionExamine *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RecipeVersionExamine
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__RecipeVersionExamine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RecipeVersionExamine, default initialized and not managed by a soap context
        virtual _ns1__RecipeVersionExamine *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__RecipeVersionExamine); }
      public:
        /// Constructor with default initializations
        _ns1__RecipeVersionExamine() : model(), soap() { }
        virtual ~_ns1__RecipeVersionExamine() { }
        /// Friend allocator used by soap_new__ns1__RecipeVersionExamine(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate__ns1__RecipeVersionExamine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:394 */
#ifndef SOAP_TYPE__ns1__RecipeVersionExamineResponse
#define SOAP_TYPE__ns1__RecipeVersionExamineResponse (126)
/* complex XML schema type 'ns1:RecipeVersionExamineResponse': */
class SOAP_CMAC _ns1__RecipeVersionExamineResponse {
      public:
        /// Optional element 'ns1:RecipeVersionExamineResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *RecipeVersionExamineResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RecipeVersionExamineResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__RecipeVersionExamineResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RecipeVersionExamineResponse, default initialized and not managed by a soap context
        virtual _ns1__RecipeVersionExamineResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__RecipeVersionExamineResponse); }
      public:
        /// Constructor with default initializations
        _ns1__RecipeVersionExamineResponse() : RecipeVersionExamineResult(), soap() { }
        virtual ~_ns1__RecipeVersionExamineResponse() { }
        /// Friend allocator used by soap_new__ns1__RecipeVersionExamineResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RecipeVersionExamineResponse * SOAP_FMAC2 soap_instantiate__ns1__RecipeVersionExamineResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:396 */
#ifndef SOAP_TYPE__ns1__State
#define SOAP_TYPE__ns1__State (127)
/* complex XML schema type 'ns1:State': */
class SOAP_CMAC _ns1__State {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:State'
        ns1__State *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__State
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__State; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__State, default initialized and not managed by a soap context
        virtual _ns1__State *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__State); }
      public:
        /// Constructor with default initializations
        _ns1__State() : model(), soap() { }
        virtual ~_ns1__State() { }
        /// Friend allocator used by soap_new__ns1__State(struct soap*, int)
        friend SOAP_FMAC1 _ns1__State * SOAP_FMAC2 soap_instantiate__ns1__State(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:398 */
#ifndef SOAP_TYPE__ns1__StateResponse
#define SOAP_TYPE__ns1__StateResponse (128)
/* complex XML schema type 'ns1:StateResponse': */
class SOAP_CMAC _ns1__StateResponse {
      public:
        /// Optional element 'ns1:StateResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *StateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__StateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StateResponse, default initialized and not managed by a soap context
        virtual _ns1__StateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__StateResponse); }
      public:
        /// Constructor with default initializations
        _ns1__StateResponse() : StateResult(), soap() { }
        virtual ~_ns1__StateResponse() { }
        /// Friend allocator used by soap_new__ns1__StateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StateResponse * SOAP_FMAC2 soap_instantiate__ns1__StateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:400 */
#ifndef SOAP_TYPE__ns1__ToolBind
#define SOAP_TYPE__ns1__ToolBind (129)
/* complex XML schema type 'ns1:ToolBind': */
class SOAP_CMAC _ns1__ToolBind {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:ToolBind'
        ns1__ToolBind *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ToolBind
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ToolBind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ToolBind, default initialized and not managed by a soap context
        virtual _ns1__ToolBind *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ToolBind); }
      public:
        /// Constructor with default initializations
        _ns1__ToolBind() : model(), soap() { }
        virtual ~_ns1__ToolBind() { }
        /// Friend allocator used by soap_new__ns1__ToolBind(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ToolBind * SOAP_FMAC2 soap_instantiate__ns1__ToolBind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:402 */
#ifndef SOAP_TYPE__ns1__ToolBindResponse
#define SOAP_TYPE__ns1__ToolBindResponse (130)
/* complex XML schema type 'ns1:ToolBindResponse': */
class SOAP_CMAC _ns1__ToolBindResponse {
      public:
        /// Optional element 'ns1:ToolBindResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *ToolBindResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ToolBindResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ToolBindResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ToolBindResponse, default initialized and not managed by a soap context
        virtual _ns1__ToolBindResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ToolBindResponse); }
      public:
        /// Constructor with default initializations
        _ns1__ToolBindResponse() : ToolBindResult(), soap() { }
        virtual ~_ns1__ToolBindResponse() { }
        /// Friend allocator used by soap_new__ns1__ToolBindResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ToolBindResponse * SOAP_FMAC2 soap_instantiate__ns1__ToolBindResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:404 */
#ifndef SOAP_TYPE__ns1__ToolLife
#define SOAP_TYPE__ns1__ToolLife (131)
/* complex XML schema type 'ns1:ToolLife': */
class SOAP_CMAC _ns1__ToolLife {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:ToolLife'
        ns1__ToolLife *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ToolLife
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ToolLife; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ToolLife, default initialized and not managed by a soap context
        virtual _ns1__ToolLife *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ToolLife); }
      public:
        /// Constructor with default initializations
        _ns1__ToolLife() : model(), soap() { }
        virtual ~_ns1__ToolLife() { }
        /// Friend allocator used by soap_new__ns1__ToolLife(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ToolLife * SOAP_FMAC2 soap_instantiate__ns1__ToolLife(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:406 */
#ifndef SOAP_TYPE__ns1__ToolLifeResponse
#define SOAP_TYPE__ns1__ToolLifeResponse (132)
/* complex XML schema type 'ns1:ToolLifeResponse': */
class SOAP_CMAC _ns1__ToolLifeResponse {
      public:
        /// Optional element 'ns1:ToolLifeResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *ToolLifeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ToolLifeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ToolLifeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ToolLifeResponse, default initialized and not managed by a soap context
        virtual _ns1__ToolLifeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ToolLifeResponse); }
      public:
        /// Constructor with default initializations
        _ns1__ToolLifeResponse() : ToolLifeResult(), soap() { }
        virtual ~_ns1__ToolLifeResponse() { }
        /// Friend allocator used by soap_new__ns1__ToolLifeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ToolLifeResponse * SOAP_FMAC2 soap_instantiate__ns1__ToolLifeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:408 */
#ifndef SOAP_TYPE__ns1__UnBindSFC
#define SOAP_TYPE__ns1__UnBindSFC (133)
/* complex XML schema type 'ns1:UnBindSFC': */
class SOAP_CMAC _ns1__UnBindSFC {
      public:
        /// Optional element 'ns1:model' of XML schema type 'ns1:UnBindSFCByScadaDTO'
        ns1__UnBindSFCByScadaDTO *model;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnBindSFC
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UnBindSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnBindSFC, default initialized and not managed by a soap context
        virtual _ns1__UnBindSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UnBindSFC); }
      public:
        /// Constructor with default initializations
        _ns1__UnBindSFC() : model(), soap() { }
        virtual ~_ns1__UnBindSFC() { }
        /// Friend allocator used by soap_new__ns1__UnBindSFC(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnBindSFC * SOAP_FMAC2 soap_instantiate__ns1__UnBindSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:410 */
#ifndef SOAP_TYPE__ns1__UnBindSFCResponse
#define SOAP_TYPE__ns1__UnBindSFCResponse (134)
/* complex XML schema type 'ns1:UnBindSFCResponse': */
class SOAP_CMAC _ns1__UnBindSFCResponse {
      public:
        /// Optional element 'ns1:UnBindSFCResult' of XML schema type 'ns1:ApiResponseForScada'
        ns1__ApiResponseForScada *UnBindSFCResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnBindSFCResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UnBindSFCResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnBindSFCResponse, default initialized and not managed by a soap context
        virtual _ns1__UnBindSFCResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UnBindSFCResponse); }
      public:
        /// Constructor with default initializations
        _ns1__UnBindSFCResponse() : UnBindSFCResult(), soap() { }
        virtual ~_ns1__UnBindSFCResponse() { }
        /// Friend allocator used by soap_new__ns1__UnBindSFCResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnBindSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__UnBindSFCResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:164 */
#ifndef SOAP_TYPE_ns1__Alarm
#define SOAP_TYPE_ns1__Alarm (11)
/* complex XML schema type 'ns1:Alarm': */
class SOAP_CMAC ns1__Alarm : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:AlarmCode' of XML schema type 'xsd:string'
        wchar_t *AlarmCode;
        /// Required element 'ns1:Status' of XML schema type 'xsd:int'
        int Status;
        /// Optional element 'ns1:AlarmMsg' of XML schema type 'xsd:string'
        wchar_t *AlarmMsg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Alarm
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Alarm; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Alarm, default initialized and not managed by a soap context
        virtual ns1__Alarm *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Alarm); }
      public:
        /// Constructor with default initializations
        ns1__Alarm() : AlarmCode(), Status(), AlarmMsg() { }
        virtual ~ns1__Alarm() { }
        /// Friend allocator used by soap_new_ns1__Alarm(struct soap*, int)
        friend SOAP_FMAC1 ns1__Alarm * SOAP_FMAC2 soap_instantiate_ns1__Alarm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:168 */
#ifndef SOAP_TYPE_ns1__ApiResponseForScada
#define SOAP_TYPE_ns1__ApiResponseForScada (13)
/* complex XML schema type 'ns1:ApiResponseForScada': */
class SOAP_CMAC ns1__ApiResponseForScada : public ns1__BaseApiResponseForScada {
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseForScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseForScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseForScada, default initialized and not managed by a soap context
        virtual ns1__ApiResponseForScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseForScada); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseForScada() { }
        virtual ~ns1__ApiResponseForScada() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseForScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseForScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:174 */
#ifndef SOAP_TYPE_ns1__BindContainer
#define SOAP_TYPE_ns1__BindContainer (16)
/* complex XML schema type 'ns1:BindContainer': */
class SOAP_CMAC ns1__BindContainer : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ContainerCode' of XML schema type 'xsd:string'
        wchar_t *ContainerCode;
        /// Optional element 'ns1:ContainerSFCs' of XML schema type 'ns1:ArrayOfBindContainerSFC'
        ns1__ArrayOfBindContainerSFC *ContainerSFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BindContainer
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BindContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BindContainer, default initialized and not managed by a soap context
        virtual ns1__BindContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BindContainer); }
      public:
        /// Constructor with default initializations
        ns1__BindContainer() : ContainerCode(), ContainerSFCs() { }
        virtual ~ns1__BindContainer() { }
        /// Friend allocator used by soap_new_ns1__BindContainer(struct soap*, int)
        friend SOAP_FMAC1 ns1__BindContainer * SOAP_FMAC2 soap_instantiate_ns1__BindContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:180 */
#ifndef SOAP_TYPE_ns1__BindSFCByScadaDTO
#define SOAP_TYPE_ns1__BindSFCByScadaDTO (19)
/* complex XML schema type 'ns1:BindSFCByScadaDTO': */
class SOAP_CMAC ns1__BindSFCByScadaDTO : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Optional element 'ns1:BindSFCs' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindSFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BindSFCByScadaDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BindSFCByScadaDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BindSFCByScadaDTO, default initialized and not managed by a soap context
        virtual ns1__BindSFCByScadaDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BindSFCByScadaDTO); }
      public:
        /// Constructor with default initializations
        ns1__BindSFCByScadaDTO() : SFC(), BindSFCs() { }
        virtual ~ns1__BindSFCByScadaDTO() { }
        /// Friend allocator used by soap_new_ns1__BindSFCByScadaDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__BindSFCByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__BindSFCByScadaDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:184 */
#ifndef SOAP_TYPE_ns1__CCDFileUploadComplete
#define SOAP_TYPE_ns1__CCDFileUploadComplete (21)
/* complex XML schema type 'ns1:CCDFileUploadComplete': */
class SOAP_CMAC ns1__CCDFileUploadComplete : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFCs' of XML schema type 'ns1:ArrayOfCCDFileUploadCompleteSFC'
        ns1__ArrayOfCCDFileUploadCompleteSFC *SFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CCDFileUploadComplete
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CCDFileUploadComplete; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CCDFileUploadComplete, default initialized and not managed by a soap context
        virtual ns1__CCDFileUploadComplete *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CCDFileUploadComplete); }
      public:
        /// Constructor with default initializations
        ns1__CCDFileUploadComplete() : SFCs() { }
        virtual ~ns1__CCDFileUploadComplete() { }
        /// Friend allocator used by soap_new_ns1__CCDFileUploadComplete(struct soap*, int)
        friend SOAP_FMAC1 ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate_ns1__CCDFileUploadComplete(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:192 */
#ifndef SOAP_TYPE_ns1__DownReason
#define SOAP_TYPE_ns1__DownReason (25)
/* complex XML schema type 'ns1:DownReason': */
class SOAP_CMAC ns1__DownReason : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:DownReasonCode' of XML schema type 'xsd:string'
        wchar_t *DownReasonCode;
        /// Required element 'ns1:BeginTime' of XML schema type 'xsd:dateTime'
        time_t BeginTime;
        /// Required element 'ns1:EndTime' of XML schema type 'xsd:dateTime'
        time_t EndTime;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DownReason
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DownReason; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DownReason, default initialized and not managed by a soap context
        virtual ns1__DownReason *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DownReason); }
      public:
        /// Constructor with default initializations
        ns1__DownReason() : DownReasonCode(), BeginTime(), EndTime() { }
        virtual ~ns1__DownReason() { }
        /// Friend allocator used by soap_new_ns1__DownReason(struct soap*, int)
        friend SOAP_FMAC1 ns1__DownReason * SOAP_FMAC2 soap_instantiate_ns1__DownReason(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:194 */
#ifndef SOAP_TYPE_ns1__EquipmentProcessParam
#define SOAP_TYPE_ns1__EquipmentProcessParam (26)
/* complex XML schema type 'ns1:EquipmentProcessParam': */
class SOAP_CMAC ns1__EquipmentProcessParam : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquipmentProcessParam
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EquipmentProcessParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquipmentProcessParam, default initialized and not managed by a soap context
        virtual ns1__EquipmentProcessParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EquipmentProcessParam); }
      public:
        /// Constructor with default initializations
        ns1__EquipmentProcessParam() : ParamList() { }
        virtual ~ns1__EquipmentProcessParam() { }
        /// Friend allocator used by soap_new_ns1__EquipmentProcessParam(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:200 */
#ifndef SOAP_TYPE_ns1__EquipmentProductProcessParam
#define SOAP_TYPE_ns1__EquipmentProductProcessParam (29)
/* complex XML schema type 'ns1:EquipmentProductProcessParam': */
class SOAP_CMAC ns1__EquipmentProductProcessParam : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFCParams' of XML schema type 'ns1:ArrayOfEquipmentProductProcessParamSFC'
        ns1__ArrayOfEquipmentProductProcessParamSFC *SFCParams;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquipmentProductProcessParam
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EquipmentProductProcessParam; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquipmentProductProcessParam, default initialized and not managed by a soap context
        virtual ns1__EquipmentProductProcessParam *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EquipmentProductProcessParam); }
      public:
        /// Constructor with default initializations
        ns1__EquipmentProductProcessParam() : SFCParams() { }
        virtual ~ns1__EquipmentProductProcessParam() { }
        /// Friend allocator used by soap_new_ns1__EquipmentProductProcessParam(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProductProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:206 */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada (32)
/* complex XML schema type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada': */
class SOAP_CMAC ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:Data' of XML schema type 'ns1:ArrayOfApiResponseSFCForScada'
        ns1__ArrayOfApiResponseSFCForScada *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, default initialized and not managed by a soap context
        virtual ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada() : Data() { }
        virtual ~ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:208 */
#ifndef SOAP_TYPE_ns1__ApiResponseSFCForScada
#define SOAP_TYPE_ns1__ApiResponseSFCForScada (33)
/* complex XML schema type 'ns1:ApiResponseSFCForScada': */
class SOAP_CMAC ns1__ApiResponseSFCForScada : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseSFCForScada
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseSFCForScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseSFCForScada, default initialized and not managed by a soap context
        virtual ns1__ApiResponseSFCForScada *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseSFCForScada); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseSFCForScada() : SFC() { }
        virtual ~ns1__ApiResponseSFCForScada() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseSFCForScada(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseSFCForScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:212 */
#ifndef SOAP_TYPE_ns1__ExamineExistsByScadaDTO
#define SOAP_TYPE_ns1__ExamineExistsByScadaDTO (35)
/* complex XML schema type 'ns1:ExamineExistsByScadaDTO': */
class SOAP_CMAC ns1__ExamineExistsByScadaDTO : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExamineExistsByScadaDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ExamineExistsByScadaDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExamineExistsByScadaDTO, default initialized and not managed by a soap context
        virtual ns1__ExamineExistsByScadaDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ExamineExistsByScadaDTO); }
      public:
        /// Constructor with default initializations
        ns1__ExamineExistsByScadaDTO() : SFC() { }
        virtual ~ns1__ExamineExistsByScadaDTO() { }
        /// Friend allocator used by soap_new_ns1__ExamineExistsByScadaDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExamineExistsByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__ExamineExistsByScadaDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:214 */
#ifndef SOAP_TYPE_ns1__FeedingByScadaDTO
#define SOAP_TYPE_ns1__FeedingByScadaDTO (36)
/* complex XML schema type 'ns1:FeedingByScadaDTO': */
class SOAP_CMAC ns1__FeedingByScadaDTO : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Qty' of XML schema type 'xsd:decimal'
        std::wstring *Qty;
        /// Required nillable (xsi:nil when NULL) element 'ns1:IsFeedingPoint' of XML schema type 'xsd:boolean'
        bool *IsFeedingPoint;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FeedingByScadaDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FeedingByScadaDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FeedingByScadaDTO, default initialized and not managed by a soap context
        virtual ns1__FeedingByScadaDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FeedingByScadaDTO); }
      public:
        /// Constructor with default initializations
        ns1__FeedingByScadaDTO() : SFC(), Qty(), IsFeedingPoint() { }
        virtual ~ns1__FeedingByScadaDTO() { }
        /// Friend allocator used by soap_new_ns1__FeedingByScadaDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__FeedingByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__FeedingByScadaDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:216 */
#ifndef SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO
#define SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO (37)
/* complex XML schema type 'ns1:FeedingDJInLaminatingByScadaDTO': */
class SOAP_CMAC ns1__FeedingDJInLaminatingByScadaDTO : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:DJCode' of XML schema type 'xsd:string'
        wchar_t *DJCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FeedingDJInLaminatingByScadaDTO, default initialized and not managed by a soap context
        virtual ns1__FeedingDJInLaminatingByScadaDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FeedingDJInLaminatingByScadaDTO); }
      public:
        /// Constructor with default initializations
        ns1__FeedingDJInLaminatingByScadaDTO() : DJCode() { }
        virtual ~ns1__FeedingDJInLaminatingByScadaDTO() { }
        /// Friend allocator used by soap_new_ns1__FeedingDJInLaminatingByScadaDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__FeedingDJInLaminatingByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:218 */
#ifndef SOAP_TYPE_ns1__FillingData
#define SOAP_TYPE_ns1__FillingData (38)
/* complex XML schema type 'ns1:FillingData': */
class SOAP_CMAC ns1__FillingData : public ns1__BaseApiRequestByScada {
      public:
        /// Required element 'ns1:InTime' of XML schema type 'xsd:dateTime'
        time_t InTime;
        /// Required element 'ns1:OutTime' of XML schema type 'xsd:dateTime'
        time_t OutTime;
        /// Required element 'ns1:BeforeWeight' of XML schema type 'xsd:double'
        double BeforeWeight;
        /// Required element 'ns1:AfterWeight' of XML schema type 'xsd:double'
        double AfterWeight;
        /// Required element 'ns1:ELWeight' of XML schema type 'xsd:double'
        double ELWeight;
        /// Required element 'ns1:AddEL' of XML schema type 'xsd:double'
        double AddEL;
        /// Required element 'ns1:TotalEL' of XML schema type 'xsd:double'
        double TotalEL;
        /// Required element 'ns1:ManualEL' of XML schema type 'xsd:double'
        double ManualEL;
        /// Required element 'ns1:FinalEL' of XML schema type 'xsd:double'
        double FinalEL;
        /// Required element 'ns1:IsOK' of XML schema type 'xsd:boolean'
        bool IsOK;
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FillingData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FillingData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FillingData, default initialized and not managed by a soap context
        virtual ns1__FillingData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FillingData); }
      public:
        /// Constructor with default initializations
        ns1__FillingData() : InTime(), OutTime(), BeforeWeight(), AfterWeight(), ELWeight(), AddEL(), TotalEL(), ManualEL(), FinalEL(), IsOK(), SFC() { }
        virtual ~ns1__FillingData() { }
        /// Friend allocator used by soap_new_ns1__FillingData(struct soap*, int)
        friend SOAP_FMAC1 ns1__FillingData * SOAP_FMAC2 soap_instantiate_ns1__FillingData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:220 */
#ifndef SOAP_TYPE_ns1__GenerateCellSFC
#define SOAP_TYPE_ns1__GenerateCellSFC (39)
/* complex XML schema type 'ns1:GenerateCellSFC': */
class SOAP_CMAC ns1__GenerateCellSFC : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ProductCode' of XML schema type 'xsd:string'
        wchar_t *ProductCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenerateCellSFC
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GenerateCellSFC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenerateCellSFC, default initialized and not managed by a soap context
        virtual ns1__GenerateCellSFC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GenerateCellSFC); }
      public:
        /// Constructor with default initializations
        ns1__GenerateCellSFC() : ProductCode() { }
        virtual ~ns1__GenerateCellSFC() { }
        /// Friend allocator used by soap_new_ns1__GenerateCellSFC(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate_ns1__GenerateCellSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:222 */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfString
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfString (40)
/* complex XML schema type 'ns1:ApiResponseDataForScadaOfString': */
class SOAP_CMAC ns1__ApiResponseDataForScadaOfString : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:Data' of XML schema type 'xsd:string'
        wchar_t *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseDataForScadaOfString
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseDataForScadaOfString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseDataForScadaOfString, default initialized and not managed by a soap context
        virtual ns1__ApiResponseDataForScadaOfString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseDataForScadaOfString); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseDataForScadaOfString() : Data() { }
        virtual ~ns1__ApiResponseDataForScadaOfString() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseDataForScadaOfString(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseDataForScadaOfString * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:224 */
#ifndef SOAP_TYPE_ns1__Heartbeat
#define SOAP_TYPE_ns1__Heartbeat (41)
/* complex XML schema type 'ns1:Heartbeat': */
class SOAP_CMAC ns1__Heartbeat : public ns1__BaseApiRequestByScada {
      public:
        /// Required element 'ns1:IsOnline' of XML schema type 'xsd:boolean'
        bool IsOnline;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Heartbeat
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Heartbeat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Heartbeat, default initialized and not managed by a soap context
        virtual ns1__Heartbeat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Heartbeat); }
      public:
        /// Constructor with default initializations
        ns1__Heartbeat() : IsOnline() { }
        virtual ~ns1__Heartbeat() { }
        /// Friend allocator used by soap_new_ns1__Heartbeat(struct soap*, int)
        friend SOAP_FMAC1 ns1__Heartbeat * SOAP_FMAC2 soap_instantiate_ns1__Heartbeat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:226 */
#ifndef SOAP_TYPE_ns1__Inbound
#define SOAP_TYPE_ns1__Inbound (42)
/* complex XML schema type 'ns1:Inbound': */
class SOAP_CMAC ns1__Inbound : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Inbound
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Inbound; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Inbound, default initialized and not managed by a soap context
        virtual ns1__Inbound *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Inbound); }
      public:
        /// Constructor with default initializations
        ns1__Inbound() : SFC() { }
        virtual ~ns1__Inbound() { }
        /// Friend allocator used by soap_new_ns1__Inbound(struct soap*, int)
        friend SOAP_FMAC1 ns1__Inbound * SOAP_FMAC2 soap_instantiate_ns1__Inbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:228 */
#ifndef SOAP_TYPE_ns1__InboundInContainer
#define SOAP_TYPE_ns1__InboundInContainer (43)
/* complex XML schema type 'ns1:InboundInContainer': */
class SOAP_CMAC ns1__InboundInContainer : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ContainerCode' of XML schema type 'xsd:string'
        wchar_t *ContainerCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InboundInContainer
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InboundInContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InboundInContainer, default initialized and not managed by a soap context
        virtual ns1__InboundInContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InboundInContainer); }
      public:
        /// Constructor with default initializations
        ns1__InboundInContainer() : ContainerCode() { }
        virtual ~ns1__InboundInContainer() { }
        /// Friend allocator used by soap_new_ns1__InboundInContainer(struct soap*, int)
        friend SOAP_FMAC1 ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate_ns1__InboundInContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:230 */
#ifndef SOAP_TYPE_ns1__InboundInSFCContainer
#define SOAP_TYPE_ns1__InboundInSFCContainer (44)
/* complex XML schema type 'ns1:InboundInSFCContainer': */
class SOAP_CMAC ns1__InboundInSFCContainer : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:CheckContainerCode' of XML schema type 'xsd:string'
        wchar_t *CheckContainerCode;
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InboundInSFCContainer
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InboundInSFCContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InboundInSFCContainer, default initialized and not managed by a soap context
        virtual ns1__InboundInSFCContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InboundInSFCContainer); }
      public:
        /// Constructor with default initializations
        ns1__InboundInSFCContainer() : CheckContainerCode(), SFC() { }
        virtual ~ns1__InboundInSFCContainer() { }
        /// Friend allocator used by soap_new_ns1__InboundInSFCContainer(struct soap*, int)
        friend SOAP_FMAC1 ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate_ns1__InboundInSFCContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:232 */
#ifndef SOAP_TYPE_ns1__InboundInTwoInjection
#define SOAP_TYPE_ns1__InboundInTwoInjection (45)
/* complex XML schema type 'ns1:InboundInTwoInjection': */
class SOAP_CMAC ns1__InboundInTwoInjection : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InboundInTwoInjection
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InboundInTwoInjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InboundInTwoInjection, default initialized and not managed by a soap context
        virtual ns1__InboundInTwoInjection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InboundInTwoInjection); }
      public:
        /// Constructor with default initializations
        ns1__InboundInTwoInjection() : SFC() { }
        virtual ~ns1__InboundInTwoInjection() { }
        /// Friend allocator used by soap_new_ns1__InboundInTwoInjection(struct soap*, int)
        friend SOAP_FMAC1 ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate_ns1__InboundInTwoInjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:234 */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu (46)
/* complex XML schema type 'ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu': */
class SOAP_CMAC ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:Data' of XML schema type 'ns1:InboundInTwoInjectionForEqu'
        ns1__InboundInTwoInjectionForEqu *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, default initialized and not managed by a soap context
        virtual ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu() : Data() { }
        virtual ~ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:238 */
#ifndef SOAP_TYPE_ns1__InboundMore
#define SOAP_TYPE_ns1__InboundMore (48)
/* complex XML schema type 'ns1:InboundMore': */
class SOAP_CMAC ns1__InboundMore : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFCs' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *SFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InboundMore
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InboundMore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InboundMore, default initialized and not managed by a soap context
        virtual ns1__InboundMore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InboundMore); }
      public:
        /// Constructor with default initializations
        ns1__InboundMore() : SFCs() { }
        virtual ~ns1__InboundMore() { }
        /// Friend allocator used by soap_new_ns1__InboundMore(struct soap*, int)
        friend SOAP_FMAC1 ns1__InboundMore * SOAP_FMAC2 soap_instantiate_ns1__InboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:240 */
#ifndef SOAP_TYPE_ns1__OperatorLogin
#define SOAP_TYPE_ns1__OperatorLogin (49)
/* complex XML schema type 'ns1:OperatorLogin': */
class SOAP_CMAC ns1__OperatorLogin : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:OperatorUserID' of XML schema type 'xsd:string'
        wchar_t *OperatorUserID;
        /// Optional element 'ns1:OperatorPassword' of XML schema type 'xsd:string'
        wchar_t *OperatorPassword;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperatorLogin
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OperatorLogin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperatorLogin, default initialized and not managed by a soap context
        virtual ns1__OperatorLogin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OperatorLogin); }
      public:
        /// Constructor with default initializations
        ns1__OperatorLogin() : OperatorUserID(), OperatorPassword() { }
        virtual ~ns1__OperatorLogin() { }
        /// Friend allocator used by soap_new_ns1__OperatorLogin(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate_ns1__OperatorLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:242 */
#ifndef SOAP_TYPE_ns1__Outbound
#define SOAP_TYPE_ns1__Outbound (50)
/* complex XML schema type 'ns1:Outbound': */
class SOAP_CMAC ns1__Outbound : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Passed' of XML schema type 'xsd:int'
        int *Passed;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
        /// Optional element 'ns1:BindFeedingCodes' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindFeedingCodes;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Outbound
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Outbound; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Outbound, default initialized and not managed by a soap context
        virtual ns1__Outbound *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Outbound); }
      public:
        /// Constructor with default initializations
        ns1__Outbound() : SFC(), Passed(), ParamList(), BindFeedingCodes() { }
        virtual ~ns1__Outbound() { }
        /// Friend allocator used by soap_new_ns1__Outbound(struct soap*, int)
        friend SOAP_FMAC1 ns1__Outbound * SOAP_FMAC2 soap_instantiate_ns1__Outbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:244 */
#ifndef SOAP_TYPE_ns1__OutboundInLaminating
#define SOAP_TYPE_ns1__OutboundInLaminating (51)
/* complex XML schema type 'ns1:OutboundInLaminating': */
class SOAP_CMAC ns1__OutboundInLaminating : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Passed' of XML schema type 'xsd:int'
        int *Passed;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
        /// Optional element 'ns1:BindFeedingCodes' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindFeedingCodes;
        /// Optional element 'ns1:BindDJCodes' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindDJCodes;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OutboundInLaminating
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OutboundInLaminating; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OutboundInLaminating, default initialized and not managed by a soap context
        virtual ns1__OutboundInLaminating *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OutboundInLaminating); }
      public:
        /// Constructor with default initializations
        ns1__OutboundInLaminating() : SFC(), Passed(), ParamList(), BindFeedingCodes(), BindDJCodes() { }
        virtual ~ns1__OutboundInLaminating() { }
        /// Friend allocator used by soap_new_ns1__OutboundInLaminating(struct soap*, int)
        friend SOAP_FMAC1 ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate_ns1__OutboundInLaminating(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:246 */
#ifndef SOAP_TYPE_ns1__OutboundInSFCOutputQty
#define SOAP_TYPE_ns1__OutboundInSFCOutputQty (52)
/* complex XML schema type 'ns1:OutboundInSFCOutputQty': */
class SOAP_CMAC ns1__OutboundInSFCOutputQty : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Required element 'ns1:TotalQty' of XML schema type 'xsd:decimal'
        std::wstring TotalQty;
        /// Required element 'ns1:OKQty' of XML schema type 'xsd:decimal'
        std::wstring OKQty;
        /// Required element 'ns1:NGQty' of XML schema type 'xsd:decimal'
        std::wstring NGQty;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfParamDTO'
        ns1__ArrayOfParamDTO *ParamList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OutboundInSFCOutputQty
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OutboundInSFCOutputQty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OutboundInSFCOutputQty, default initialized and not managed by a soap context
        virtual ns1__OutboundInSFCOutputQty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OutboundInSFCOutputQty); }
      public:
        /// Constructor with default initializations
        ns1__OutboundInSFCOutputQty() : SFC(), TotalQty(), OKQty(), NGQty(), ParamList() { }
        virtual ~ns1__OutboundInSFCOutputQty() { }
        /// Friend allocator used by soap_new_ns1__OutboundInSFCOutputQty(struct soap*, int)
        friend SOAP_FMAC1 ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate_ns1__OutboundInSFCOutputQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:248 */
#ifndef SOAP_TYPE_ns1__OutboundMore
#define SOAP_TYPE_ns1__OutboundMore (53)
/* complex XML schema type 'ns1:OutboundMore': */
class SOAP_CMAC ns1__OutboundMore : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFCs' of XML schema type 'ns1:ArrayOfOutboundSFC'
        ns1__ArrayOfOutboundSFC *SFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OutboundMore
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OutboundMore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OutboundMore, default initialized and not managed by a soap context
        virtual ns1__OutboundMore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OutboundMore); }
      public:
        /// Constructor with default initializations
        ns1__OutboundMore() : SFCs() { }
        virtual ~ns1__OutboundMore() { }
        /// Friend allocator used by soap_new_ns1__OutboundMore(struct soap*, int)
        friend SOAP_FMAC1 ns1__OutboundMore * SOAP_FMAC2 soap_instantiate_ns1__OutboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:254 */
#ifndef SOAP_TYPE_ns1__Recipe
#define SOAP_TYPE_ns1__Recipe (56)
/* complex XML schema type 'ns1:Recipe': */
class SOAP_CMAC ns1__Recipe : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:RecipeCode' of XML schema type 'xsd:string'
        wchar_t *RecipeCode;
        /// Optional element 'ns1:Version' of XML schema type 'xsd:string'
        wchar_t *Version;
        /// Optional element 'ns1:ProductCode' of XML schema type 'xsd:string'
        wchar_t *ProductCode;
        /// Optional element 'ns1:ParamList' of XML schema type 'ns1:ArrayOfRecipeParam'
        ns1__ArrayOfRecipeParam *ParamList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Recipe
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Recipe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Recipe, default initialized and not managed by a soap context
        virtual ns1__Recipe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Recipe); }
      public:
        /// Constructor with default initializations
        ns1__Recipe() : RecipeCode(), Version(), ProductCode(), ParamList() { }
        virtual ~ns1__Recipe() { }
        /// Friend allocator used by soap_new_ns1__Recipe(struct soap*, int)
        friend SOAP_FMAC1 ns1__Recipe * SOAP_FMAC2 soap_instantiate_ns1__Recipe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:260 */
#ifndef SOAP_TYPE_ns1__RecipeGet
#define SOAP_TYPE_ns1__RecipeGet (59)
/* complex XML schema type 'ns1:RecipeGet': */
class SOAP_CMAC ns1__RecipeGet : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:RecipeCode' of XML schema type 'xsd:string'
        wchar_t *RecipeCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeGet
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeGet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeGet, default initialized and not managed by a soap context
        virtual ns1__RecipeGet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeGet); }
      public:
        /// Constructor with default initializations
        ns1__RecipeGet() : RecipeCode() { }
        virtual ~ns1__RecipeGet() { }
        /// Friend allocator used by soap_new_ns1__RecipeGet(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeGet * SOAP_FMAC2 soap_instantiate_ns1__RecipeGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:262 */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu (60)
/* complex XML schema type 'ns1:ApiResponseDataForScadaOfRecipeGetForEqu': */
class SOAP_CMAC ns1__ApiResponseDataForScadaOfRecipeGetForEqu : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:Data' of XML schema type 'ns1:RecipeGetForEqu'
        ns1__RecipeGetForEqu *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseDataForScadaOfRecipeGetForEqu, default initialized and not managed by a soap context
        virtual ns1__ApiResponseDataForScadaOfRecipeGetForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseDataForScadaOfRecipeGetForEqu); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseDataForScadaOfRecipeGetForEqu() : Data() { }
        virtual ~ns1__ApiResponseDataForScadaOfRecipeGetForEqu() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseDataForScadaOfRecipeGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:270 */
#ifndef SOAP_TYPE_ns1__RecipeListGet
#define SOAP_TYPE_ns1__RecipeListGet (64)
/* complex XML schema type 'ns1:RecipeListGet': */
class SOAP_CMAC ns1__RecipeListGet : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ProductCode' of XML schema type 'xsd:string'
        wchar_t *ProductCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeListGet
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeListGet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeListGet, default initialized and not managed by a soap context
        virtual ns1__RecipeListGet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeListGet); }
      public:
        /// Constructor with default initializations
        ns1__RecipeListGet() : ProductCode() { }
        virtual ~ns1__RecipeListGet() { }
        /// Friend allocator used by soap_new_ns1__RecipeListGet(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeListGet * SOAP_FMAC2 soap_instantiate_ns1__RecipeListGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:272 */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu (65)
/* complex XML schema type 'ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu': */
class SOAP_CMAC ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu : public ns1__BaseApiResponseForScada {
      public:
        /// Optional element 'ns1:Data' of XML schema type 'ns1:ArrayOfRecipeListGetForEqu'
        ns1__ArrayOfRecipeListGetForEqu *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, default initialized and not managed by a soap context
        virtual ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu); }
      public:
        /// Constructor with default initializations
        ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu() : Data() { }
        virtual ~ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu() { }
        /// Friend allocator used by soap_new_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:278 */
#ifndef SOAP_TYPE_ns1__RecipeVersionExamine
#define SOAP_TYPE_ns1__RecipeVersionExamine (68)
/* complex XML schema type 'ns1:RecipeVersionExamine': */
class SOAP_CMAC ns1__RecipeVersionExamine : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:RecipeCode' of XML schema type 'xsd:string'
        wchar_t *RecipeCode;
        /// Optional element 'ns1:Version' of XML schema type 'xsd:string'
        wchar_t *Version;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecipeVersionExamine
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RecipeVersionExamine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecipeVersionExamine, default initialized and not managed by a soap context
        virtual ns1__RecipeVersionExamine *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RecipeVersionExamine); }
      public:
        /// Constructor with default initializations
        ns1__RecipeVersionExamine() : RecipeCode(), Version() { }
        virtual ~ns1__RecipeVersionExamine() { }
        /// Friend allocator used by soap_new_ns1__RecipeVersionExamine(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate_ns1__RecipeVersionExamine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:280 */
#ifndef SOAP_TYPE_ns1__State
#define SOAP_TYPE_ns1__State (69)
/* complex XML schema type 'ns1:State': */
class SOAP_CMAC ns1__State : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:StateCode' of XML schema type 'xsd:string'
        wchar_t *StateCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__State
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__State; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__State, default initialized and not managed by a soap context
        virtual ns1__State *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__State); }
      public:
        /// Constructor with default initializations
        ns1__State() : StateCode() { }
        virtual ~ns1__State() { }
        /// Friend allocator used by soap_new_ns1__State(struct soap*, int)
        friend SOAP_FMAC1 ns1__State * SOAP_FMAC2 soap_instantiate_ns1__State(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:282 */
#ifndef SOAP_TYPE_ns1__ToolBind
#define SOAP_TYPE_ns1__ToolBind (70)
/* complex XML schema type 'ns1:ToolBind': */
class SOAP_CMAC ns1__ToolBind : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ToolCode' of XML schema type 'xsd:string'
        wchar_t *ToolCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ToolBind
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ToolBind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ToolBind, default initialized and not managed by a soap context
        virtual ns1__ToolBind *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ToolBind); }
      public:
        /// Constructor with default initializations
        ns1__ToolBind() : ToolCode() { }
        virtual ~ns1__ToolBind() { }
        /// Friend allocator used by soap_new_ns1__ToolBind(struct soap*, int)
        friend SOAP_FMAC1 ns1__ToolBind * SOAP_FMAC2 soap_instantiate_ns1__ToolBind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:284 */
#ifndef SOAP_TYPE_ns1__ToolLife
#define SOAP_TYPE_ns1__ToolLife (71)
/* complex XML schema type 'ns1:ToolLife': */
class SOAP_CMAC ns1__ToolLife : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:ToolCode' of XML schema type 'xsd:string'
        wchar_t *ToolCode;
        /// Required element 'ns1:UsedLife' of XML schema type 'xsd:double'
        double UsedLife;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ToolLife
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ToolLife; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ToolLife, default initialized and not managed by a soap context
        virtual ns1__ToolLife *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ToolLife); }
      public:
        /// Constructor with default initializations
        ns1__ToolLife() : ToolCode(), UsedLife() { }
        virtual ~ns1__ToolLife() { }
        /// Friend allocator used by soap_new_ns1__ToolLife(struct soap*, int)
        friend SOAP_FMAC1 ns1__ToolLife * SOAP_FMAC2 soap_instantiate_ns1__ToolLife(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:286 */
#ifndef SOAP_TYPE_ns1__UnBindSFCByScadaDTO
#define SOAP_TYPE_ns1__UnBindSFCByScadaDTO (72)
/* complex XML schema type 'ns1:UnBindSFCByScadaDTO': */
class SOAP_CMAC ns1__UnBindSFCByScadaDTO : public ns1__BaseApiRequestByScada {
      public:
        /// Optional element 'ns1:SFC' of XML schema type 'xsd:string'
        wchar_t *SFC;
        /// Optional element 'ns1:BindSFCs' of XML schema type 'ns1:ArrayOfString'
        ns1__ArrayOfString *BindSFCs;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UnBindSFCByScadaDTO
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__UnBindSFCByScadaDTO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UnBindSFCByScadaDTO, default initialized and not managed by a soap context
        virtual ns1__UnBindSFCByScadaDTO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__UnBindSFCByScadaDTO); }
      public:
        /// Constructor with default initializations
        ns1__UnBindSFCByScadaDTO() : SFC(), BindSFCs() { }
        virtual ~ns1__UnBindSFCByScadaDTO() { }
        /// Friend allocator used by soap_new_ns1__UnBindSFCByScadaDTO(struct soap*, int)
        friend SOAP_FMAC1 ns1__UnBindSFCByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__UnBindSFCByScadaDTO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:3802 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (216)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        ns1__LoginSoapHeader *ns1__LoginSoapHeader_;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : ns1__LoginSoapHeader_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* mes_cc2_1.h:3921 */
#ifndef SOAP_TYPE___ns1__Alarm
#define SOAP_TYPE___ns1__Alarm (221)
/* Wrapper: */
struct SOAP_CMAC __ns1__Alarm {
      public:
        /** Optional element 'ns1:Alarm' of XML schema type 'ns1:Alarm' */
        _ns1__Alarm *ns1__Alarm_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Alarm */
        long soap_type() const { return SOAP_TYPE___ns1__Alarm; }
        /** Constructor with member initializations */
        __ns1__Alarm() : ns1__Alarm_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Alarm * SOAP_FMAC2 soap_instantiate___ns1__Alarm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4026 */
#ifndef SOAP_TYPE___ns1__Alarm_
#define SOAP_TYPE___ns1__Alarm_ (223)
/* Wrapper: */
struct SOAP_CMAC __ns1__Alarm_ {
      public:
        /** Optional element 'ns1:Alarm' of XML schema type 'ns1:Alarm' */
        _ns1__Alarm *ns1__Alarm_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Alarm_ */
        long soap_type() const { return SOAP_TYPE___ns1__Alarm_; }
        /** Constructor with member initializations */
        __ns1__Alarm_() : ns1__Alarm_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Alarm_ * SOAP_FMAC2 soap_instantiate___ns1__Alarm_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4131 */
#ifndef SOAP_TYPE___ns1__BindContainer
#define SOAP_TYPE___ns1__BindContainer (227)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindContainer {
      public:
        /** Optional element 'ns1:BindContainer' of XML schema type 'ns1:BindContainer' */
        _ns1__BindContainer *ns1__BindContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindContainer */
        long soap_type() const { return SOAP_TYPE___ns1__BindContainer; }
        /** Constructor with member initializations */
        __ns1__BindContainer() : ns1__BindContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindContainer * SOAP_FMAC2 soap_instantiate___ns1__BindContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4236 */
#ifndef SOAP_TYPE___ns1__BindContainer_
#define SOAP_TYPE___ns1__BindContainer_ (229)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindContainer_ {
      public:
        /** Optional element 'ns1:BindContainer' of XML schema type 'ns1:BindContainer' */
        _ns1__BindContainer *ns1__BindContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindContainer_ */
        long soap_type() const { return SOAP_TYPE___ns1__BindContainer_; }
        /** Constructor with member initializations */
        __ns1__BindContainer_() : ns1__BindContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindContainer_ * SOAP_FMAC2 soap_instantiate___ns1__BindContainer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4341 */
#ifndef SOAP_TYPE___ns1__BindSFC
#define SOAP_TYPE___ns1__BindSFC (233)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindSFC {
      public:
        /** Optional element 'ns1:BindSFC' of XML schema type 'ns1:BindSFC' */
        _ns1__BindSFC *ns1__BindSFC;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindSFC */
        long soap_type() const { return SOAP_TYPE___ns1__BindSFC; }
        /** Constructor with member initializations */
        __ns1__BindSFC() : ns1__BindSFC() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindSFC * SOAP_FMAC2 soap_instantiate___ns1__BindSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4446 */
#ifndef SOAP_TYPE___ns1__BindSFC_
#define SOAP_TYPE___ns1__BindSFC_ (235)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindSFC_ {
      public:
        /** Optional element 'ns1:BindSFC' of XML schema type 'ns1:BindSFC' */
        _ns1__BindSFC *ns1__BindSFC;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindSFC_ */
        long soap_type() const { return SOAP_TYPE___ns1__BindSFC_; }
        /** Constructor with member initializations */
        __ns1__BindSFC_() : ns1__BindSFC() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindSFC_ * SOAP_FMAC2 soap_instantiate___ns1__BindSFC_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4551 */
#ifndef SOAP_TYPE___ns1__CCDFileUploadComplete
#define SOAP_TYPE___ns1__CCDFileUploadComplete (239)
/* Wrapper: */
struct SOAP_CMAC __ns1__CCDFileUploadComplete {
      public:
        /** Optional element 'ns1:CCDFileUploadComplete' of XML schema type 'ns1:CCDFileUploadComplete' */
        _ns1__CCDFileUploadComplete *ns1__CCDFileUploadComplete_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CCDFileUploadComplete */
        long soap_type() const { return SOAP_TYPE___ns1__CCDFileUploadComplete; }
        /** Constructor with member initializations */
        __ns1__CCDFileUploadComplete() : ns1__CCDFileUploadComplete_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate___ns1__CCDFileUploadComplete(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4656 */
#ifndef SOAP_TYPE___ns1__CCDFileUploadComplete_
#define SOAP_TYPE___ns1__CCDFileUploadComplete_ (241)
/* Wrapper: */
struct SOAP_CMAC __ns1__CCDFileUploadComplete_ {
      public:
        /** Optional element 'ns1:CCDFileUploadComplete' of XML schema type 'ns1:CCDFileUploadComplete' */
        _ns1__CCDFileUploadComplete *ns1__CCDFileUploadComplete_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CCDFileUploadComplete_ */
        long soap_type() const { return SOAP_TYPE___ns1__CCDFileUploadComplete_; }
        /** Constructor with member initializations */
        __ns1__CCDFileUploadComplete_() : ns1__CCDFileUploadComplete_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CCDFileUploadComplete_ * SOAP_FMAC2 soap_instantiate___ns1__CCDFileUploadComplete_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4761 */
#ifndef SOAP_TYPE___ns1__DownReason
#define SOAP_TYPE___ns1__DownReason (245)
/* Wrapper: */
struct SOAP_CMAC __ns1__DownReason {
      public:
        /** Optional element 'ns1:DownReason' of XML schema type 'ns1:DownReason' */
        _ns1__DownReason *ns1__DownReason_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DownReason */
        long soap_type() const { return SOAP_TYPE___ns1__DownReason; }
        /** Constructor with member initializations */
        __ns1__DownReason() : ns1__DownReason_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DownReason * SOAP_FMAC2 soap_instantiate___ns1__DownReason(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4866 */
#ifndef SOAP_TYPE___ns1__DownReason_
#define SOAP_TYPE___ns1__DownReason_ (247)
/* Wrapper: */
struct SOAP_CMAC __ns1__DownReason_ {
      public:
        /** Optional element 'ns1:DownReason' of XML schema type 'ns1:DownReason' */
        _ns1__DownReason *ns1__DownReason_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DownReason_ */
        long soap_type() const { return SOAP_TYPE___ns1__DownReason_; }
        /** Constructor with member initializations */
        __ns1__DownReason_() : ns1__DownReason_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DownReason_ * SOAP_FMAC2 soap_instantiate___ns1__DownReason_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:4971 */
#ifndef SOAP_TYPE___ns1__EquipmentProcessParam
#define SOAP_TYPE___ns1__EquipmentProcessParam (251)
/* Wrapper: */
struct SOAP_CMAC __ns1__EquipmentProcessParam {
      public:
        /** Optional element 'ns1:EquipmentProcessParam' of XML schema type 'ns1:EquipmentProcessParam' */
        _ns1__EquipmentProcessParam *ns1__EquipmentProcessParam_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EquipmentProcessParam */
        long soap_type() const { return SOAP_TYPE___ns1__EquipmentProcessParam; }
        /** Constructor with member initializations */
        __ns1__EquipmentProcessParam() : ns1__EquipmentProcessParam_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5076 */
#ifndef SOAP_TYPE___ns1__EquipmentProcessParam_
#define SOAP_TYPE___ns1__EquipmentProcessParam_ (253)
/* Wrapper: */
struct SOAP_CMAC __ns1__EquipmentProcessParam_ {
      public:
        /** Optional element 'ns1:EquipmentProcessParam' of XML schema type 'ns1:EquipmentProcessParam' */
        _ns1__EquipmentProcessParam *ns1__EquipmentProcessParam_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EquipmentProcessParam_ */
        long soap_type() const { return SOAP_TYPE___ns1__EquipmentProcessParam_; }
        /** Constructor with member initializations */
        __ns1__EquipmentProcessParam_() : ns1__EquipmentProcessParam_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EquipmentProcessParam_ * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProcessParam_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5181 */
#ifndef SOAP_TYPE___ns1__EquipmentProductProcessParam
#define SOAP_TYPE___ns1__EquipmentProductProcessParam (257)
/* Wrapper: */
struct SOAP_CMAC __ns1__EquipmentProductProcessParam {
      public:
        /** Optional element 'ns1:EquipmentProductProcessParam' of XML schema type 'ns1:EquipmentProductProcessParam' */
        _ns1__EquipmentProductProcessParam *ns1__EquipmentProductProcessParam_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EquipmentProductProcessParam */
        long soap_type() const { return SOAP_TYPE___ns1__EquipmentProductProcessParam; }
        /** Constructor with member initializations */
        __ns1__EquipmentProductProcessParam() : ns1__EquipmentProductProcessParam_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProductProcessParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5286 */
#ifndef SOAP_TYPE___ns1__EquipmentProductProcessParam_
#define SOAP_TYPE___ns1__EquipmentProductProcessParam_ (259)
/* Wrapper: */
struct SOAP_CMAC __ns1__EquipmentProductProcessParam_ {
      public:
        /** Optional element 'ns1:EquipmentProductProcessParam' of XML schema type 'ns1:EquipmentProductProcessParam' */
        _ns1__EquipmentProductProcessParam *ns1__EquipmentProductProcessParam_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EquipmentProductProcessParam_ */
        long soap_type() const { return SOAP_TYPE___ns1__EquipmentProductProcessParam_; }
        /** Constructor with member initializations */
        __ns1__EquipmentProductProcessParam_() : ns1__EquipmentProductProcessParam_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EquipmentProductProcessParam_ * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProductProcessParam_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5391 */
#ifndef SOAP_TYPE___ns1__ExamineExists
#define SOAP_TYPE___ns1__ExamineExists (263)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExamineExists {
      public:
        /** Optional element 'ns1:ExamineExists' of XML schema type 'ns1:ExamineExists' */
        _ns1__ExamineExists *ns1__ExamineExists;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExamineExists */
        long soap_type() const { return SOAP_TYPE___ns1__ExamineExists; }
        /** Constructor with member initializations */
        __ns1__ExamineExists() : ns1__ExamineExists() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ExamineExists * SOAP_FMAC2 soap_instantiate___ns1__ExamineExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5496 */
#ifndef SOAP_TYPE___ns1__ExamineExists_
#define SOAP_TYPE___ns1__ExamineExists_ (265)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExamineExists_ {
      public:
        /** Optional element 'ns1:ExamineExists' of XML schema type 'ns1:ExamineExists' */
        _ns1__ExamineExists *ns1__ExamineExists;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExamineExists_ */
        long soap_type() const { return SOAP_TYPE___ns1__ExamineExists_; }
        /** Constructor with member initializations */
        __ns1__ExamineExists_() : ns1__ExamineExists() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ExamineExists_ * SOAP_FMAC2 soap_instantiate___ns1__ExamineExists_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5601 */
#ifndef SOAP_TYPE___ns1__Feeding
#define SOAP_TYPE___ns1__Feeding (269)
/* Wrapper: */
struct SOAP_CMAC __ns1__Feeding {
      public:
        /** Optional element 'ns1:Feeding' of XML schema type 'ns1:Feeding' */
        _ns1__Feeding *ns1__Feeding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Feeding */
        long soap_type() const { return SOAP_TYPE___ns1__Feeding; }
        /** Constructor with member initializations */
        __ns1__Feeding() : ns1__Feeding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Feeding * SOAP_FMAC2 soap_instantiate___ns1__Feeding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5706 */
#ifndef SOAP_TYPE___ns1__Feeding_
#define SOAP_TYPE___ns1__Feeding_ (271)
/* Wrapper: */
struct SOAP_CMAC __ns1__Feeding_ {
      public:
        /** Optional element 'ns1:Feeding' of XML schema type 'ns1:Feeding' */
        _ns1__Feeding *ns1__Feeding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Feeding_ */
        long soap_type() const { return SOAP_TYPE___ns1__Feeding_; }
        /** Constructor with member initializations */
        __ns1__Feeding_() : ns1__Feeding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Feeding_ * SOAP_FMAC2 soap_instantiate___ns1__Feeding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5811 */
#ifndef SOAP_TYPE___ns1__FeedingDJInLaminating
#define SOAP_TYPE___ns1__FeedingDJInLaminating (275)
/* Wrapper: */
struct SOAP_CMAC __ns1__FeedingDJInLaminating {
      public:
        /** Optional element 'ns1:FeedingDJInLaminating' of XML schema type 'ns1:FeedingDJInLaminating' */
        _ns1__FeedingDJInLaminating *ns1__FeedingDJInLaminating;
      public:
        /** Return unique type id SOAP_TYPE___ns1__FeedingDJInLaminating */
        long soap_type() const { return SOAP_TYPE___ns1__FeedingDJInLaminating; }
        /** Constructor with member initializations */
        __ns1__FeedingDJInLaminating() : ns1__FeedingDJInLaminating() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__FeedingDJInLaminating * SOAP_FMAC2 soap_instantiate___ns1__FeedingDJInLaminating(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:5916 */
#ifndef SOAP_TYPE___ns1__FeedingDJInLaminating_
#define SOAP_TYPE___ns1__FeedingDJInLaminating_ (277)
/* Wrapper: */
struct SOAP_CMAC __ns1__FeedingDJInLaminating_ {
      public:
        /** Optional element 'ns1:FeedingDJInLaminating' of XML schema type 'ns1:FeedingDJInLaminating' */
        _ns1__FeedingDJInLaminating *ns1__FeedingDJInLaminating;
      public:
        /** Return unique type id SOAP_TYPE___ns1__FeedingDJInLaminating_ */
        long soap_type() const { return SOAP_TYPE___ns1__FeedingDJInLaminating_; }
        /** Constructor with member initializations */
        __ns1__FeedingDJInLaminating_() : ns1__FeedingDJInLaminating() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__FeedingDJInLaminating_ * SOAP_FMAC2 soap_instantiate___ns1__FeedingDJInLaminating_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6021 */
#ifndef SOAP_TYPE___ns1__FillingData
#define SOAP_TYPE___ns1__FillingData (281)
/* Wrapper: */
struct SOAP_CMAC __ns1__FillingData {
      public:
        /** Optional element 'ns1:FillingData' of XML schema type 'ns1:FillingData' */
        _ns1__FillingData *ns1__FillingData_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__FillingData */
        long soap_type() const { return SOAP_TYPE___ns1__FillingData; }
        /** Constructor with member initializations */
        __ns1__FillingData() : ns1__FillingData_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__FillingData * SOAP_FMAC2 soap_instantiate___ns1__FillingData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6126 */
#ifndef SOAP_TYPE___ns1__FillingData_
#define SOAP_TYPE___ns1__FillingData_ (283)
/* Wrapper: */
struct SOAP_CMAC __ns1__FillingData_ {
      public:
        /** Optional element 'ns1:FillingData' of XML schema type 'ns1:FillingData' */
        _ns1__FillingData *ns1__FillingData_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__FillingData_ */
        long soap_type() const { return SOAP_TYPE___ns1__FillingData_; }
        /** Constructor with member initializations */
        __ns1__FillingData_() : ns1__FillingData_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__FillingData_ * SOAP_FMAC2 soap_instantiate___ns1__FillingData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6231 */
#ifndef SOAP_TYPE___ns1__GenerateCellSFC
#define SOAP_TYPE___ns1__GenerateCellSFC (287)
/* Wrapper: */
struct SOAP_CMAC __ns1__GenerateCellSFC {
      public:
        /** Optional element 'ns1:GenerateCellSFC' of XML schema type 'ns1:GenerateCellSFC' */
        _ns1__GenerateCellSFC *ns1__GenerateCellSFC_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GenerateCellSFC */
        long soap_type() const { return SOAP_TYPE___ns1__GenerateCellSFC; }
        /** Constructor with member initializations */
        __ns1__GenerateCellSFC() : ns1__GenerateCellSFC_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate___ns1__GenerateCellSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6336 */
#ifndef SOAP_TYPE___ns1__GenerateCellSFC_
#define SOAP_TYPE___ns1__GenerateCellSFC_ (289)
/* Wrapper: */
struct SOAP_CMAC __ns1__GenerateCellSFC_ {
      public:
        /** Optional element 'ns1:GenerateCellSFC' of XML schema type 'ns1:GenerateCellSFC' */
        _ns1__GenerateCellSFC *ns1__GenerateCellSFC_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GenerateCellSFC_ */
        long soap_type() const { return SOAP_TYPE___ns1__GenerateCellSFC_; }
        /** Constructor with member initializations */
        __ns1__GenerateCellSFC_() : ns1__GenerateCellSFC_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GenerateCellSFC_ * SOAP_FMAC2 soap_instantiate___ns1__GenerateCellSFC_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6441 */
#ifndef SOAP_TYPE___ns1__Heartbeat
#define SOAP_TYPE___ns1__Heartbeat (293)
/* Wrapper: */
struct SOAP_CMAC __ns1__Heartbeat {
      public:
        /** Optional element 'ns1:Heartbeat' of XML schema type 'ns1:Heartbeat' */
        _ns1__Heartbeat *ns1__Heartbeat_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Heartbeat */
        long soap_type() const { return SOAP_TYPE___ns1__Heartbeat; }
        /** Constructor with member initializations */
        __ns1__Heartbeat() : ns1__Heartbeat_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Heartbeat * SOAP_FMAC2 soap_instantiate___ns1__Heartbeat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6546 */
#ifndef SOAP_TYPE___ns1__Heartbeat_
#define SOAP_TYPE___ns1__Heartbeat_ (295)
/* Wrapper: */
struct SOAP_CMAC __ns1__Heartbeat_ {
      public:
        /** Optional element 'ns1:Heartbeat' of XML schema type 'ns1:Heartbeat' */
        _ns1__Heartbeat *ns1__Heartbeat_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Heartbeat_ */
        long soap_type() const { return SOAP_TYPE___ns1__Heartbeat_; }
        /** Constructor with member initializations */
        __ns1__Heartbeat_() : ns1__Heartbeat_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Heartbeat_ * SOAP_FMAC2 soap_instantiate___ns1__Heartbeat_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6651 */
#ifndef SOAP_TYPE___ns1__Inbound
#define SOAP_TYPE___ns1__Inbound (299)
/* Wrapper: */
struct SOAP_CMAC __ns1__Inbound {
      public:
        /** Optional element 'ns1:Inbound' of XML schema type 'ns1:Inbound' */
        _ns1__Inbound *ns1__Inbound_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Inbound */
        long soap_type() const { return SOAP_TYPE___ns1__Inbound; }
        /** Constructor with member initializations */
        __ns1__Inbound() : ns1__Inbound_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Inbound * SOAP_FMAC2 soap_instantiate___ns1__Inbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6756 */
#ifndef SOAP_TYPE___ns1__Inbound_
#define SOAP_TYPE___ns1__Inbound_ (301)
/* Wrapper: */
struct SOAP_CMAC __ns1__Inbound_ {
      public:
        /** Optional element 'ns1:Inbound' of XML schema type 'ns1:Inbound' */
        _ns1__Inbound *ns1__Inbound_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Inbound_ */
        long soap_type() const { return SOAP_TYPE___ns1__Inbound_; }
        /** Constructor with member initializations */
        __ns1__Inbound_() : ns1__Inbound_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Inbound_ * SOAP_FMAC2 soap_instantiate___ns1__Inbound_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6861 */
#ifndef SOAP_TYPE___ns1__InboundInContainer
#define SOAP_TYPE___ns1__InboundInContainer (305)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInContainer {
      public:
        /** Optional element 'ns1:InboundInContainer' of XML schema type 'ns1:InboundInContainer' */
        _ns1__InboundInContainer *ns1__InboundInContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInContainer */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInContainer; }
        /** Constructor with member initializations */
        __ns1__InboundInContainer() : ns1__InboundInContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate___ns1__InboundInContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:6966 */
#ifndef SOAP_TYPE___ns1__InboundInContainer_
#define SOAP_TYPE___ns1__InboundInContainer_ (307)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInContainer_ {
      public:
        /** Optional element 'ns1:InboundInContainer' of XML schema type 'ns1:InboundInContainer' */
        _ns1__InboundInContainer *ns1__InboundInContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInContainer_ */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInContainer_; }
        /** Constructor with member initializations */
        __ns1__InboundInContainer_() : ns1__InboundInContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInContainer_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInContainer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7071 */
#ifndef SOAP_TYPE___ns1__InboundInSFCContainer
#define SOAP_TYPE___ns1__InboundInSFCContainer (311)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInSFCContainer {
      public:
        /** Optional element 'ns1:InboundInSFCContainer' of XML schema type 'ns1:InboundInSFCContainer' */
        _ns1__InboundInSFCContainer *ns1__InboundInSFCContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInSFCContainer */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInSFCContainer; }
        /** Constructor with member initializations */
        __ns1__InboundInSFCContainer() : ns1__InboundInSFCContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate___ns1__InboundInSFCContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7176 */
#ifndef SOAP_TYPE___ns1__InboundInSFCContainer_
#define SOAP_TYPE___ns1__InboundInSFCContainer_ (313)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInSFCContainer_ {
      public:
        /** Optional element 'ns1:InboundInSFCContainer' of XML schema type 'ns1:InboundInSFCContainer' */
        _ns1__InboundInSFCContainer *ns1__InboundInSFCContainer_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInSFCContainer_ */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInSFCContainer_; }
        /** Constructor with member initializations */
        __ns1__InboundInSFCContainer_() : ns1__InboundInSFCContainer_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInSFCContainer_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInSFCContainer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7281 */
#ifndef SOAP_TYPE___ns1__InboundInTwoInjection
#define SOAP_TYPE___ns1__InboundInTwoInjection (317)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInTwoInjection {
      public:
        /** Optional element 'ns1:InboundInTwoInjection' of XML schema type 'ns1:InboundInTwoInjection' */
        _ns1__InboundInTwoInjection *ns1__InboundInTwoInjection_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInTwoInjection */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInTwoInjection; }
        /** Constructor with member initializations */
        __ns1__InboundInTwoInjection() : ns1__InboundInTwoInjection_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate___ns1__InboundInTwoInjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7386 */
#ifndef SOAP_TYPE___ns1__InboundInTwoInjection_
#define SOAP_TYPE___ns1__InboundInTwoInjection_ (319)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundInTwoInjection_ {
      public:
        /** Optional element 'ns1:InboundInTwoInjection' of XML schema type 'ns1:InboundInTwoInjection' */
        _ns1__InboundInTwoInjection *ns1__InboundInTwoInjection_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundInTwoInjection_ */
        long soap_type() const { return SOAP_TYPE___ns1__InboundInTwoInjection_; }
        /** Constructor with member initializations */
        __ns1__InboundInTwoInjection_() : ns1__InboundInTwoInjection_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundInTwoInjection_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInTwoInjection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7491 */
#ifndef SOAP_TYPE___ns1__InboundMore
#define SOAP_TYPE___ns1__InboundMore (323)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundMore {
      public:
        /** Optional element 'ns1:InboundMore' of XML schema type 'ns1:InboundMore' */
        _ns1__InboundMore *ns1__InboundMore_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundMore */
        long soap_type() const { return SOAP_TYPE___ns1__InboundMore; }
        /** Constructor with member initializations */
        __ns1__InboundMore() : ns1__InboundMore_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundMore * SOAP_FMAC2 soap_instantiate___ns1__InboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7596 */
#ifndef SOAP_TYPE___ns1__InboundMore_
#define SOAP_TYPE___ns1__InboundMore_ (325)
/* Wrapper: */
struct SOAP_CMAC __ns1__InboundMore_ {
      public:
        /** Optional element 'ns1:InboundMore' of XML schema type 'ns1:InboundMore' */
        _ns1__InboundMore *ns1__InboundMore_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InboundMore_ */
        long soap_type() const { return SOAP_TYPE___ns1__InboundMore_; }
        /** Constructor with member initializations */
        __ns1__InboundMore_() : ns1__InboundMore_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InboundMore_ * SOAP_FMAC2 soap_instantiate___ns1__InboundMore_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7701 */
#ifndef SOAP_TYPE___ns1__OperatorLogin
#define SOAP_TYPE___ns1__OperatorLogin (329)
/* Wrapper: */
struct SOAP_CMAC __ns1__OperatorLogin {
      public:
        /** Optional element 'ns1:OperatorLogin' of XML schema type 'ns1:OperatorLogin' */
        _ns1__OperatorLogin *ns1__OperatorLogin_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OperatorLogin */
        long soap_type() const { return SOAP_TYPE___ns1__OperatorLogin; }
        /** Constructor with member initializations */
        __ns1__OperatorLogin() : ns1__OperatorLogin_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate___ns1__OperatorLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7806 */
#ifndef SOAP_TYPE___ns1__OperatorLogin_
#define SOAP_TYPE___ns1__OperatorLogin_ (331)
/* Wrapper: */
struct SOAP_CMAC __ns1__OperatorLogin_ {
      public:
        /** Optional element 'ns1:OperatorLogin' of XML schema type 'ns1:OperatorLogin' */
        _ns1__OperatorLogin *ns1__OperatorLogin_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OperatorLogin_ */
        long soap_type() const { return SOAP_TYPE___ns1__OperatorLogin_; }
        /** Constructor with member initializations */
        __ns1__OperatorLogin_() : ns1__OperatorLogin_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OperatorLogin_ * SOAP_FMAC2 soap_instantiate___ns1__OperatorLogin_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:7911 */
#ifndef SOAP_TYPE___ns1__Outbound
#define SOAP_TYPE___ns1__Outbound (335)
/* Wrapper: */
struct SOAP_CMAC __ns1__Outbound {
      public:
        /** Optional element 'ns1:Outbound' of XML schema type 'ns1:Outbound' */
        _ns1__Outbound *ns1__Outbound_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Outbound */
        long soap_type() const { return SOAP_TYPE___ns1__Outbound; }
        /** Constructor with member initializations */
        __ns1__Outbound() : ns1__Outbound_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Outbound * SOAP_FMAC2 soap_instantiate___ns1__Outbound(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8016 */
#ifndef SOAP_TYPE___ns1__Outbound_
#define SOAP_TYPE___ns1__Outbound_ (337)
/* Wrapper: */
struct SOAP_CMAC __ns1__Outbound_ {
      public:
        /** Optional element 'ns1:Outbound' of XML schema type 'ns1:Outbound' */
        _ns1__Outbound *ns1__Outbound_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Outbound_ */
        long soap_type() const { return SOAP_TYPE___ns1__Outbound_; }
        /** Constructor with member initializations */
        __ns1__Outbound_() : ns1__Outbound_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Outbound_ * SOAP_FMAC2 soap_instantiate___ns1__Outbound_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8121 */
#ifndef SOAP_TYPE___ns1__OutboundInLaminating
#define SOAP_TYPE___ns1__OutboundInLaminating (341)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundInLaminating {
      public:
        /** Optional element 'ns1:OutboundInLaminating' of XML schema type 'ns1:OutboundInLaminating' */
        _ns1__OutboundInLaminating *ns1__OutboundInLaminating_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundInLaminating */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundInLaminating; }
        /** Constructor with member initializations */
        __ns1__OutboundInLaminating() : ns1__OutboundInLaminating_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate___ns1__OutboundInLaminating(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8226 */
#ifndef SOAP_TYPE___ns1__OutboundInLaminating_
#define SOAP_TYPE___ns1__OutboundInLaminating_ (343)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundInLaminating_ {
      public:
        /** Optional element 'ns1:OutboundInLaminating' of XML schema type 'ns1:OutboundInLaminating' */
        _ns1__OutboundInLaminating *ns1__OutboundInLaminating_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundInLaminating_ */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundInLaminating_; }
        /** Constructor with member initializations */
        __ns1__OutboundInLaminating_() : ns1__OutboundInLaminating_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundInLaminating_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundInLaminating_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8331 */
#ifndef SOAP_TYPE___ns1__OutboundInSFCOutputQty
#define SOAP_TYPE___ns1__OutboundInSFCOutputQty (347)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundInSFCOutputQty {
      public:
        /** Optional element 'ns1:OutboundInSFCOutputQty' of XML schema type 'ns1:OutboundInSFCOutputQty' */
        _ns1__OutboundInSFCOutputQty *ns1__OutboundInSFCOutputQty_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundInSFCOutputQty */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundInSFCOutputQty; }
        /** Constructor with member initializations */
        __ns1__OutboundInSFCOutputQty() : ns1__OutboundInSFCOutputQty_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate___ns1__OutboundInSFCOutputQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8436 */
#ifndef SOAP_TYPE___ns1__OutboundInSFCOutputQty_
#define SOAP_TYPE___ns1__OutboundInSFCOutputQty_ (349)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundInSFCOutputQty_ {
      public:
        /** Optional element 'ns1:OutboundInSFCOutputQty' of XML schema type 'ns1:OutboundInSFCOutputQty' */
        _ns1__OutboundInSFCOutputQty *ns1__OutboundInSFCOutputQty_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundInSFCOutputQty_ */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundInSFCOutputQty_; }
        /** Constructor with member initializations */
        __ns1__OutboundInSFCOutputQty_() : ns1__OutboundInSFCOutputQty_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundInSFCOutputQty_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundInSFCOutputQty_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8541 */
#ifndef SOAP_TYPE___ns1__OutboundMore
#define SOAP_TYPE___ns1__OutboundMore (353)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundMore {
      public:
        /** Optional element 'ns1:OutboundMore' of XML schema type 'ns1:OutboundMore' */
        _ns1__OutboundMore *ns1__OutboundMore_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundMore */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundMore; }
        /** Constructor with member initializations */
        __ns1__OutboundMore() : ns1__OutboundMore_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundMore * SOAP_FMAC2 soap_instantiate___ns1__OutboundMore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8646 */
#ifndef SOAP_TYPE___ns1__OutboundMore_
#define SOAP_TYPE___ns1__OutboundMore_ (355)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutboundMore_ {
      public:
        /** Optional element 'ns1:OutboundMore' of XML schema type 'ns1:OutboundMore' */
        _ns1__OutboundMore *ns1__OutboundMore_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutboundMore_ */
        long soap_type() const { return SOAP_TYPE___ns1__OutboundMore_; }
        /** Constructor with member initializations */
        __ns1__OutboundMore_() : ns1__OutboundMore_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutboundMore_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundMore_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8751 */
#ifndef SOAP_TYPE___ns1__Recipe
#define SOAP_TYPE___ns1__Recipe (359)
/* Wrapper: */
struct SOAP_CMAC __ns1__Recipe {
      public:
        /** Optional element 'ns1:Recipe' of XML schema type 'ns1:Recipe' */
        _ns1__Recipe *ns1__Recipe_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Recipe */
        long soap_type() const { return SOAP_TYPE___ns1__Recipe; }
        /** Constructor with member initializations */
        __ns1__Recipe() : ns1__Recipe_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Recipe * SOAP_FMAC2 soap_instantiate___ns1__Recipe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8856 */
#ifndef SOAP_TYPE___ns1__Recipe_
#define SOAP_TYPE___ns1__Recipe_ (361)
/* Wrapper: */
struct SOAP_CMAC __ns1__Recipe_ {
      public:
        /** Optional element 'ns1:Recipe' of XML schema type 'ns1:Recipe' */
        _ns1__Recipe *ns1__Recipe_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Recipe_ */
        long soap_type() const { return SOAP_TYPE___ns1__Recipe_; }
        /** Constructor with member initializations */
        __ns1__Recipe_() : ns1__Recipe_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Recipe_ * SOAP_FMAC2 soap_instantiate___ns1__Recipe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:8961 */
#ifndef SOAP_TYPE___ns1__GetRecipe
#define SOAP_TYPE___ns1__GetRecipe (365)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRecipe {
      public:
        /** Optional element 'ns1:GetRecipe' of XML schema type 'ns1:GetRecipe' */
        _ns1__GetRecipe *ns1__GetRecipe;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRecipe */
        long soap_type() const { return SOAP_TYPE___ns1__GetRecipe; }
        /** Constructor with member initializations */
        __ns1__GetRecipe() : ns1__GetRecipe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetRecipe * SOAP_FMAC2 soap_instantiate___ns1__GetRecipe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9066 */
#ifndef SOAP_TYPE___ns1__GetRecipe_
#define SOAP_TYPE___ns1__GetRecipe_ (367)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRecipe_ {
      public:
        /** Optional element 'ns1:GetRecipe' of XML schema type 'ns1:GetRecipe' */
        _ns1__GetRecipe *ns1__GetRecipe;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRecipe_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetRecipe_; }
        /** Constructor with member initializations */
        __ns1__GetRecipe_() : ns1__GetRecipe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetRecipe_ * SOAP_FMAC2 soap_instantiate___ns1__GetRecipe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9171 */
#ifndef SOAP_TYPE___ns1__GetRecipeList
#define SOAP_TYPE___ns1__GetRecipeList (371)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRecipeList {
      public:
        /** Optional element 'ns1:GetRecipeList' of XML schema type 'ns1:GetRecipeList' */
        _ns1__GetRecipeList *ns1__GetRecipeList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRecipeList */
        long soap_type() const { return SOAP_TYPE___ns1__GetRecipeList; }
        /** Constructor with member initializations */
        __ns1__GetRecipeList() : ns1__GetRecipeList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetRecipeList * SOAP_FMAC2 soap_instantiate___ns1__GetRecipeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9276 */
#ifndef SOAP_TYPE___ns1__GetRecipeList_
#define SOAP_TYPE___ns1__GetRecipeList_ (373)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRecipeList_ {
      public:
        /** Optional element 'ns1:GetRecipeList' of XML schema type 'ns1:GetRecipeList' */
        _ns1__GetRecipeList *ns1__GetRecipeList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRecipeList_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetRecipeList_; }
        /** Constructor with member initializations */
        __ns1__GetRecipeList_() : ns1__GetRecipeList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetRecipeList_ * SOAP_FMAC2 soap_instantiate___ns1__GetRecipeList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9381 */
#ifndef SOAP_TYPE___ns1__RecipeVersionExamine
#define SOAP_TYPE___ns1__RecipeVersionExamine (377)
/* Wrapper: */
struct SOAP_CMAC __ns1__RecipeVersionExamine {
      public:
        /** Optional element 'ns1:RecipeVersionExamine' of XML schema type 'ns1:RecipeVersionExamine' */
        _ns1__RecipeVersionExamine *ns1__RecipeVersionExamine_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RecipeVersionExamine */
        long soap_type() const { return SOAP_TYPE___ns1__RecipeVersionExamine; }
        /** Constructor with member initializations */
        __ns1__RecipeVersionExamine() : ns1__RecipeVersionExamine_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate___ns1__RecipeVersionExamine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9486 */
#ifndef SOAP_TYPE___ns1__RecipeVersionExamine_
#define SOAP_TYPE___ns1__RecipeVersionExamine_ (379)
/* Wrapper: */
struct SOAP_CMAC __ns1__RecipeVersionExamine_ {
      public:
        /** Optional element 'ns1:RecipeVersionExamine' of XML schema type 'ns1:RecipeVersionExamine' */
        _ns1__RecipeVersionExamine *ns1__RecipeVersionExamine_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RecipeVersionExamine_ */
        long soap_type() const { return SOAP_TYPE___ns1__RecipeVersionExamine_; }
        /** Constructor with member initializations */
        __ns1__RecipeVersionExamine_() : ns1__RecipeVersionExamine_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__RecipeVersionExamine_ * SOAP_FMAC2 soap_instantiate___ns1__RecipeVersionExamine_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9591 */
#ifndef SOAP_TYPE___ns1__State
#define SOAP_TYPE___ns1__State (383)
/* Wrapper: */
struct SOAP_CMAC __ns1__State {
      public:
        /** Optional element 'ns1:State' of XML schema type 'ns1:State' */
        _ns1__State *ns1__State_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__State */
        long soap_type() const { return SOAP_TYPE___ns1__State; }
        /** Constructor with member initializations */
        __ns1__State() : ns1__State_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__State * SOAP_FMAC2 soap_instantiate___ns1__State(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9696 */
#ifndef SOAP_TYPE___ns1__State_
#define SOAP_TYPE___ns1__State_ (385)
/* Wrapper: */
struct SOAP_CMAC __ns1__State_ {
      public:
        /** Optional element 'ns1:State' of XML schema type 'ns1:State' */
        _ns1__State *ns1__State_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__State_ */
        long soap_type() const { return SOAP_TYPE___ns1__State_; }
        /** Constructor with member initializations */
        __ns1__State_() : ns1__State_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__State_ * SOAP_FMAC2 soap_instantiate___ns1__State_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9801 */
#ifndef SOAP_TYPE___ns1__ToolBind
#define SOAP_TYPE___ns1__ToolBind (389)
/* Wrapper: */
struct SOAP_CMAC __ns1__ToolBind {
      public:
        /** Optional element 'ns1:ToolBind' of XML schema type 'ns1:ToolBind' */
        _ns1__ToolBind *ns1__ToolBind_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ToolBind */
        long soap_type() const { return SOAP_TYPE___ns1__ToolBind; }
        /** Constructor with member initializations */
        __ns1__ToolBind() : ns1__ToolBind_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ToolBind * SOAP_FMAC2 soap_instantiate___ns1__ToolBind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:9906 */
#ifndef SOAP_TYPE___ns1__ToolBind_
#define SOAP_TYPE___ns1__ToolBind_ (391)
/* Wrapper: */
struct SOAP_CMAC __ns1__ToolBind_ {
      public:
        /** Optional element 'ns1:ToolBind' of XML schema type 'ns1:ToolBind' */
        _ns1__ToolBind *ns1__ToolBind_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ToolBind_ */
        long soap_type() const { return SOAP_TYPE___ns1__ToolBind_; }
        /** Constructor with member initializations */
        __ns1__ToolBind_() : ns1__ToolBind_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ToolBind_ * SOAP_FMAC2 soap_instantiate___ns1__ToolBind_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:10011 */
#ifndef SOAP_TYPE___ns1__ToolLife
#define SOAP_TYPE___ns1__ToolLife (395)
/* Wrapper: */
struct SOAP_CMAC __ns1__ToolLife {
      public:
        /** Optional element 'ns1:ToolLife' of XML schema type 'ns1:ToolLife' */
        _ns1__ToolLife *ns1__ToolLife_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ToolLife */
        long soap_type() const { return SOAP_TYPE___ns1__ToolLife; }
        /** Constructor with member initializations */
        __ns1__ToolLife() : ns1__ToolLife_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ToolLife * SOAP_FMAC2 soap_instantiate___ns1__ToolLife(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:10116 */
#ifndef SOAP_TYPE___ns1__ToolLife_
#define SOAP_TYPE___ns1__ToolLife_ (397)
/* Wrapper: */
struct SOAP_CMAC __ns1__ToolLife_ {
      public:
        /** Optional element 'ns1:ToolLife' of XML schema type 'ns1:ToolLife' */
        _ns1__ToolLife *ns1__ToolLife_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ToolLife_ */
        long soap_type() const { return SOAP_TYPE___ns1__ToolLife_; }
        /** Constructor with member initializations */
        __ns1__ToolLife_() : ns1__ToolLife_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ToolLife_ * SOAP_FMAC2 soap_instantiate___ns1__ToolLife_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:10221 */
#ifndef SOAP_TYPE___ns1__UnBindSFC
#define SOAP_TYPE___ns1__UnBindSFC (401)
/* Wrapper: */
struct SOAP_CMAC __ns1__UnBindSFC {
      public:
        /** Optional element 'ns1:UnBindSFC' of XML schema type 'ns1:UnBindSFC' */
        _ns1__UnBindSFC *ns1__UnBindSFC;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UnBindSFC */
        long soap_type() const { return SOAP_TYPE___ns1__UnBindSFC; }
        /** Constructor with member initializations */
        __ns1__UnBindSFC() : ns1__UnBindSFC() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UnBindSFC * SOAP_FMAC2 soap_instantiate___ns1__UnBindSFC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:10326 */
#ifndef SOAP_TYPE___ns1__UnBindSFC_
#define SOAP_TYPE___ns1__UnBindSFC_ (403)
/* Wrapper: */
struct SOAP_CMAC __ns1__UnBindSFC_ {
      public:
        /** Optional element 'ns1:UnBindSFC' of XML schema type 'ns1:UnBindSFC' */
        _ns1__UnBindSFC *ns1__UnBindSFC;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UnBindSFC_ */
        long soap_type() const { return SOAP_TYPE___ns1__UnBindSFC_; }
        /** Constructor with member initializations */
        __ns1__UnBindSFC_() : ns1__UnBindSFC() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UnBindSFC_ * SOAP_FMAC2 soap_instantiate___ns1__UnBindSFC_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mes_cc2_1.h:11319 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (404)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* mes_cc2_1.h:11319 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (406)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* mes_cc2_1.h:11319 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (409)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* mes_cc2_1.h:11319 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (410)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* mes_cc2_1.h:152 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
typedef std::wstring xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (156)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (140)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (209)
#endif

/* _ns1__UnBindSFCResponse has binding name '_ns1__UnBindSFCResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UnBindSFCResponse
#define SOAP_TYPE__ns1__UnBindSFCResponse (134)
#endif

/* _ns1__UnBindSFC has binding name '_ns1__UnBindSFC' for type '' */
#ifndef SOAP_TYPE__ns1__UnBindSFC
#define SOAP_TYPE__ns1__UnBindSFC (133)
#endif

/* _ns1__ToolLifeResponse has binding name '_ns1__ToolLifeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ToolLifeResponse
#define SOAP_TYPE__ns1__ToolLifeResponse (132)
#endif

/* _ns1__ToolLife has binding name '_ns1__ToolLife' for type '' */
#ifndef SOAP_TYPE__ns1__ToolLife
#define SOAP_TYPE__ns1__ToolLife (131)
#endif

/* _ns1__ToolBindResponse has binding name '_ns1__ToolBindResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ToolBindResponse
#define SOAP_TYPE__ns1__ToolBindResponse (130)
#endif

/* _ns1__ToolBind has binding name '_ns1__ToolBind' for type '' */
#ifndef SOAP_TYPE__ns1__ToolBind
#define SOAP_TYPE__ns1__ToolBind (129)
#endif

/* _ns1__StateResponse has binding name '_ns1__StateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StateResponse
#define SOAP_TYPE__ns1__StateResponse (128)
#endif

/* _ns1__State has binding name '_ns1__State' for type '' */
#ifndef SOAP_TYPE__ns1__State
#define SOAP_TYPE__ns1__State (127)
#endif

/* _ns1__RecipeVersionExamineResponse has binding name '_ns1__RecipeVersionExamineResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RecipeVersionExamineResponse
#define SOAP_TYPE__ns1__RecipeVersionExamineResponse (126)
#endif

/* _ns1__RecipeVersionExamine has binding name '_ns1__RecipeVersionExamine' for type '' */
#ifndef SOAP_TYPE__ns1__RecipeVersionExamine
#define SOAP_TYPE__ns1__RecipeVersionExamine (125)
#endif

/* _ns1__GetRecipeListResponse has binding name '_ns1__GetRecipeListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecipeListResponse
#define SOAP_TYPE__ns1__GetRecipeListResponse (124)
#endif

/* _ns1__GetRecipeList has binding name '_ns1__GetRecipeList' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecipeList
#define SOAP_TYPE__ns1__GetRecipeList (123)
#endif

/* _ns1__GetRecipeResponse has binding name '_ns1__GetRecipeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecipeResponse
#define SOAP_TYPE__ns1__GetRecipeResponse (122)
#endif

/* _ns1__GetRecipe has binding name '_ns1__GetRecipe' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecipe
#define SOAP_TYPE__ns1__GetRecipe (121)
#endif

/* _ns1__RecipeResponse has binding name '_ns1__RecipeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RecipeResponse
#define SOAP_TYPE__ns1__RecipeResponse (120)
#endif

/* _ns1__Recipe has binding name '_ns1__Recipe' for type '' */
#ifndef SOAP_TYPE__ns1__Recipe
#define SOAP_TYPE__ns1__Recipe (119)
#endif

/* _ns1__OutboundMoreResponse has binding name '_ns1__OutboundMoreResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundMoreResponse
#define SOAP_TYPE__ns1__OutboundMoreResponse (118)
#endif

/* _ns1__OutboundMore has binding name '_ns1__OutboundMore' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundMore
#define SOAP_TYPE__ns1__OutboundMore (117)
#endif

/* _ns1__OutboundInSFCOutputQtyResponse has binding name '_ns1__OutboundInSFCOutputQtyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse
#define SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse (116)
#endif

/* _ns1__OutboundInSFCOutputQty has binding name '_ns1__OutboundInSFCOutputQty' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundInSFCOutputQty
#define SOAP_TYPE__ns1__OutboundInSFCOutputQty (115)
#endif

/* _ns1__OutboundInLaminatingResponse has binding name '_ns1__OutboundInLaminatingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundInLaminatingResponse
#define SOAP_TYPE__ns1__OutboundInLaminatingResponse (114)
#endif

/* _ns1__OutboundInLaminating has binding name '_ns1__OutboundInLaminating' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundInLaminating
#define SOAP_TYPE__ns1__OutboundInLaminating (113)
#endif

/* _ns1__OutboundResponse has binding name '_ns1__OutboundResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutboundResponse
#define SOAP_TYPE__ns1__OutboundResponse (112)
#endif

/* _ns1__Outbound has binding name '_ns1__Outbound' for type '' */
#ifndef SOAP_TYPE__ns1__Outbound
#define SOAP_TYPE__ns1__Outbound (111)
#endif

/* _ns1__OperatorLoginResponse has binding name '_ns1__OperatorLoginResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OperatorLoginResponse
#define SOAP_TYPE__ns1__OperatorLoginResponse (110)
#endif

/* _ns1__OperatorLogin has binding name '_ns1__OperatorLogin' for type '' */
#ifndef SOAP_TYPE__ns1__OperatorLogin
#define SOAP_TYPE__ns1__OperatorLogin (109)
#endif

/* _ns1__InboundMoreResponse has binding name '_ns1__InboundMoreResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InboundMoreResponse
#define SOAP_TYPE__ns1__InboundMoreResponse (108)
#endif

/* _ns1__InboundMore has binding name '_ns1__InboundMore' for type '' */
#ifndef SOAP_TYPE__ns1__InboundMore
#define SOAP_TYPE__ns1__InboundMore (107)
#endif

/* _ns1__InboundInTwoInjectionResponse has binding name '_ns1__InboundInTwoInjectionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInTwoInjectionResponse
#define SOAP_TYPE__ns1__InboundInTwoInjectionResponse (106)
#endif

/* _ns1__InboundInTwoInjection has binding name '_ns1__InboundInTwoInjection' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInTwoInjection
#define SOAP_TYPE__ns1__InboundInTwoInjection (105)
#endif

/* _ns1__InboundInSFCContainerResponse has binding name '_ns1__InboundInSFCContainerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInSFCContainerResponse
#define SOAP_TYPE__ns1__InboundInSFCContainerResponse (104)
#endif

/* _ns1__InboundInSFCContainer has binding name '_ns1__InboundInSFCContainer' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInSFCContainer
#define SOAP_TYPE__ns1__InboundInSFCContainer (103)
#endif

/* _ns1__InboundInContainerResponse has binding name '_ns1__InboundInContainerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInContainerResponse
#define SOAP_TYPE__ns1__InboundInContainerResponse (102)
#endif

/* _ns1__InboundInContainer has binding name '_ns1__InboundInContainer' for type '' */
#ifndef SOAP_TYPE__ns1__InboundInContainer
#define SOAP_TYPE__ns1__InboundInContainer (101)
#endif

/* _ns1__InboundResponse has binding name '_ns1__InboundResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InboundResponse
#define SOAP_TYPE__ns1__InboundResponse (100)
#endif

/* _ns1__Inbound has binding name '_ns1__Inbound' for type '' */
#ifndef SOAP_TYPE__ns1__Inbound
#define SOAP_TYPE__ns1__Inbound (99)
#endif

/* _ns1__HeartbeatResponse has binding name '_ns1__HeartbeatResponse' for type '' */
#ifndef SOAP_TYPE__ns1__HeartbeatResponse
#define SOAP_TYPE__ns1__HeartbeatResponse (98)
#endif

/* _ns1__Heartbeat has binding name '_ns1__Heartbeat' for type '' */
#ifndef SOAP_TYPE__ns1__Heartbeat
#define SOAP_TYPE__ns1__Heartbeat (97)
#endif

/* _ns1__GenerateCellSFCResponse has binding name '_ns1__GenerateCellSFCResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GenerateCellSFCResponse
#define SOAP_TYPE__ns1__GenerateCellSFCResponse (96)
#endif

/* _ns1__GenerateCellSFC has binding name '_ns1__GenerateCellSFC' for type '' */
#ifndef SOAP_TYPE__ns1__GenerateCellSFC
#define SOAP_TYPE__ns1__GenerateCellSFC (95)
#endif

/* _ns1__FillingDataResponse has binding name '_ns1__FillingDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__FillingDataResponse
#define SOAP_TYPE__ns1__FillingDataResponse (94)
#endif

/* _ns1__FillingData has binding name '_ns1__FillingData' for type '' */
#ifndef SOAP_TYPE__ns1__FillingData
#define SOAP_TYPE__ns1__FillingData (93)
#endif

/* _ns1__FeedingDJInLaminatingResponse has binding name '_ns1__FeedingDJInLaminatingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__FeedingDJInLaminatingResponse
#define SOAP_TYPE__ns1__FeedingDJInLaminatingResponse (92)
#endif

/* _ns1__FeedingDJInLaminating has binding name '_ns1__FeedingDJInLaminating' for type '' */
#ifndef SOAP_TYPE__ns1__FeedingDJInLaminating
#define SOAP_TYPE__ns1__FeedingDJInLaminating (91)
#endif

/* _ns1__FeedingResponse has binding name '_ns1__FeedingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__FeedingResponse
#define SOAP_TYPE__ns1__FeedingResponse (90)
#endif

/* _ns1__Feeding has binding name '_ns1__Feeding' for type '' */
#ifndef SOAP_TYPE__ns1__Feeding
#define SOAP_TYPE__ns1__Feeding (89)
#endif

/* _ns1__ExamineExistsResponse has binding name '_ns1__ExamineExistsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ExamineExistsResponse
#define SOAP_TYPE__ns1__ExamineExistsResponse (88)
#endif

/* _ns1__ExamineExists has binding name '_ns1__ExamineExists' for type '' */
#ifndef SOAP_TYPE__ns1__ExamineExists
#define SOAP_TYPE__ns1__ExamineExists (87)
#endif

/* _ns1__EquipmentProductProcessParamResponse has binding name '_ns1__EquipmentProductProcessParamResponse' for type '' */
#ifndef SOAP_TYPE__ns1__EquipmentProductProcessParamResponse
#define SOAP_TYPE__ns1__EquipmentProductProcessParamResponse (86)
#endif

/* _ns1__EquipmentProductProcessParam has binding name '_ns1__EquipmentProductProcessParam' for type '' */
#ifndef SOAP_TYPE__ns1__EquipmentProductProcessParam
#define SOAP_TYPE__ns1__EquipmentProductProcessParam (85)
#endif

/* _ns1__EquipmentProcessParamResponse has binding name '_ns1__EquipmentProcessParamResponse' for type '' */
#ifndef SOAP_TYPE__ns1__EquipmentProcessParamResponse
#define SOAP_TYPE__ns1__EquipmentProcessParamResponse (84)
#endif

/* _ns1__EquipmentProcessParam has binding name '_ns1__EquipmentProcessParam' for type '' */
#ifndef SOAP_TYPE__ns1__EquipmentProcessParam
#define SOAP_TYPE__ns1__EquipmentProcessParam (83)
#endif

/* _ns1__DownReasonResponse has binding name '_ns1__DownReasonResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DownReasonResponse
#define SOAP_TYPE__ns1__DownReasonResponse (82)
#endif

/* _ns1__DownReason has binding name '_ns1__DownReason' for type '' */
#ifndef SOAP_TYPE__ns1__DownReason
#define SOAP_TYPE__ns1__DownReason (81)
#endif

/* _ns1__CCDFileUploadCompleteResponse has binding name '_ns1__CCDFileUploadCompleteResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CCDFileUploadCompleteResponse
#define SOAP_TYPE__ns1__CCDFileUploadCompleteResponse (80)
#endif

/* _ns1__CCDFileUploadComplete has binding name '_ns1__CCDFileUploadComplete' for type '' */
#ifndef SOAP_TYPE__ns1__CCDFileUploadComplete
#define SOAP_TYPE__ns1__CCDFileUploadComplete (79)
#endif

/* _ns1__BindSFCResponse has binding name '_ns1__BindSFCResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BindSFCResponse
#define SOAP_TYPE__ns1__BindSFCResponse (78)
#endif

/* _ns1__BindSFC has binding name '_ns1__BindSFC' for type '' */
#ifndef SOAP_TYPE__ns1__BindSFC
#define SOAP_TYPE__ns1__BindSFC (77)
#endif

/* _ns1__BindContainerResponse has binding name '_ns1__BindContainerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BindContainerResponse
#define SOAP_TYPE__ns1__BindContainerResponse (76)
#endif

/* _ns1__BindContainer has binding name '_ns1__BindContainer' for type '' */
#ifndef SOAP_TYPE__ns1__BindContainer
#define SOAP_TYPE__ns1__BindContainer (75)
#endif

/* _ns1__AlarmResponse has binding name '_ns1__AlarmResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AlarmResponse
#define SOAP_TYPE__ns1__AlarmResponse (74)
#endif

/* _ns1__Alarm has binding name '_ns1__Alarm' for type '' */
#ifndef SOAP_TYPE__ns1__Alarm
#define SOAP_TYPE__ns1__Alarm (73)
#endif

/* ns1__UnBindSFCByScadaDTO has binding name 'ns1__UnBindSFCByScadaDTO' for type 'ns1:UnBindSFCByScadaDTO' */
#ifndef SOAP_TYPE_ns1__UnBindSFCByScadaDTO
#define SOAP_TYPE_ns1__UnBindSFCByScadaDTO (72)
#endif

/* ns1__ToolLife has binding name 'ns1__ToolLife' for type 'ns1:ToolLife' */
#ifndef SOAP_TYPE_ns1__ToolLife
#define SOAP_TYPE_ns1__ToolLife (71)
#endif

/* ns1__ToolBind has binding name 'ns1__ToolBind' for type 'ns1:ToolBind' */
#ifndef SOAP_TYPE_ns1__ToolBind
#define SOAP_TYPE_ns1__ToolBind (70)
#endif

/* ns1__State has binding name 'ns1__State' for type 'ns1:State' */
#ifndef SOAP_TYPE_ns1__State
#define SOAP_TYPE_ns1__State (69)
#endif

/* ns1__RecipeVersionExamine has binding name 'ns1__RecipeVersionExamine' for type 'ns1:RecipeVersionExamine' */
#ifndef SOAP_TYPE_ns1__RecipeVersionExamine
#define SOAP_TYPE_ns1__RecipeVersionExamine (68)
#endif

/* ns1__RecipeListGetForEqu has binding name 'ns1__RecipeListGetForEqu' for type 'ns1:RecipeListGetForEqu' */
#ifndef SOAP_TYPE_ns1__RecipeListGetForEqu
#define SOAP_TYPE_ns1__RecipeListGetForEqu (67)
#endif

/* ns1__ArrayOfRecipeListGetForEqu has binding name 'ns1__ArrayOfRecipeListGetForEqu' for type 'ns1:ArrayOfRecipeListGetForEqu' */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu
#define SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu (66)
#endif

/* ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu has binding name 'ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu' for type 'ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu' */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu (65)
#endif

/* ns1__RecipeListGet has binding name 'ns1__RecipeListGet' for type 'ns1:RecipeListGet' */
#ifndef SOAP_TYPE_ns1__RecipeListGet
#define SOAP_TYPE_ns1__RecipeListGet (64)
#endif

/* ns1__RecipeGetParamForEqu has binding name 'ns1__RecipeGetParamForEqu' for type 'ns1:RecipeGetParamForEqu' */
#ifndef SOAP_TYPE_ns1__RecipeGetParamForEqu
#define SOAP_TYPE_ns1__RecipeGetParamForEqu (63)
#endif

/* ns1__ArrayOfRecipeGetParamForEqu has binding name 'ns1__ArrayOfRecipeGetParamForEqu' for type 'ns1:ArrayOfRecipeGetParamForEqu' */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu
#define SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu (62)
#endif

/* ns1__RecipeGetForEqu has binding name 'ns1__RecipeGetForEqu' for type 'ns1:RecipeGetForEqu' */
#ifndef SOAP_TYPE_ns1__RecipeGetForEqu
#define SOAP_TYPE_ns1__RecipeGetForEqu (61)
#endif

/* ns1__ApiResponseDataForScadaOfRecipeGetForEqu has binding name 'ns1__ApiResponseDataForScadaOfRecipeGetForEqu' for type 'ns1:ApiResponseDataForScadaOfRecipeGetForEqu' */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu (60)
#endif

/* ns1__RecipeGet has binding name 'ns1__RecipeGet' for type 'ns1:RecipeGet' */
#ifndef SOAP_TYPE_ns1__RecipeGet
#define SOAP_TYPE_ns1__RecipeGet (59)
#endif

/* ns1__RecipeParam has binding name 'ns1__RecipeParam' for type 'ns1:RecipeParam' */
#ifndef SOAP_TYPE_ns1__RecipeParam
#define SOAP_TYPE_ns1__RecipeParam (58)
#endif

/* ns1__ArrayOfRecipeParam has binding name 'ns1__ArrayOfRecipeParam' for type 'ns1:ArrayOfRecipeParam' */
#ifndef SOAP_TYPE_ns1__ArrayOfRecipeParam
#define SOAP_TYPE_ns1__ArrayOfRecipeParam (57)
#endif

/* ns1__Recipe has binding name 'ns1__Recipe' for type 'ns1:Recipe' */
#ifndef SOAP_TYPE_ns1__Recipe
#define SOAP_TYPE_ns1__Recipe (56)
#endif

/* ns1__OutboundSFC has binding name 'ns1__OutboundSFC' for type 'ns1:OutboundSFC' */
#ifndef SOAP_TYPE_ns1__OutboundSFC
#define SOAP_TYPE_ns1__OutboundSFC (55)
#endif

/* ns1__ArrayOfOutboundSFC has binding name 'ns1__ArrayOfOutboundSFC' for type 'ns1:ArrayOfOutboundSFC' */
#ifndef SOAP_TYPE_ns1__ArrayOfOutboundSFC
#define SOAP_TYPE_ns1__ArrayOfOutboundSFC (54)
#endif

/* ns1__OutboundMore has binding name 'ns1__OutboundMore' for type 'ns1:OutboundMore' */
#ifndef SOAP_TYPE_ns1__OutboundMore
#define SOAP_TYPE_ns1__OutboundMore (53)
#endif

/* ns1__OutboundInSFCOutputQty has binding name 'ns1__OutboundInSFCOutputQty' for type 'ns1:OutboundInSFCOutputQty' */
#ifndef SOAP_TYPE_ns1__OutboundInSFCOutputQty
#define SOAP_TYPE_ns1__OutboundInSFCOutputQty (52)
#endif

/* ns1__OutboundInLaminating has binding name 'ns1__OutboundInLaminating' for type 'ns1:OutboundInLaminating' */
#ifndef SOAP_TYPE_ns1__OutboundInLaminating
#define SOAP_TYPE_ns1__OutboundInLaminating (51)
#endif

/* ns1__Outbound has binding name 'ns1__Outbound' for type 'ns1:Outbound' */
#ifndef SOAP_TYPE_ns1__Outbound
#define SOAP_TYPE_ns1__Outbound (50)
#endif

/* ns1__OperatorLogin has binding name 'ns1__OperatorLogin' for type 'ns1:OperatorLogin' */
#ifndef SOAP_TYPE_ns1__OperatorLogin
#define SOAP_TYPE_ns1__OperatorLogin (49)
#endif

/* ns1__InboundMore has binding name 'ns1__InboundMore' for type 'ns1:InboundMore' */
#ifndef SOAP_TYPE_ns1__InboundMore
#define SOAP_TYPE_ns1__InboundMore (48)
#endif

/* ns1__InboundInTwoInjectionForEqu has binding name 'ns1__InboundInTwoInjectionForEqu' for type 'ns1:InboundInTwoInjectionForEqu' */
#ifndef SOAP_TYPE_ns1__InboundInTwoInjectionForEqu
#define SOAP_TYPE_ns1__InboundInTwoInjectionForEqu (47)
#endif

/* ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu has binding name 'ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu' for type 'ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu' */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu (46)
#endif

/* ns1__InboundInTwoInjection has binding name 'ns1__InboundInTwoInjection' for type 'ns1:InboundInTwoInjection' */
#ifndef SOAP_TYPE_ns1__InboundInTwoInjection
#define SOAP_TYPE_ns1__InboundInTwoInjection (45)
#endif

/* ns1__InboundInSFCContainer has binding name 'ns1__InboundInSFCContainer' for type 'ns1:InboundInSFCContainer' */
#ifndef SOAP_TYPE_ns1__InboundInSFCContainer
#define SOAP_TYPE_ns1__InboundInSFCContainer (44)
#endif

/* ns1__InboundInContainer has binding name 'ns1__InboundInContainer' for type 'ns1:InboundInContainer' */
#ifndef SOAP_TYPE_ns1__InboundInContainer
#define SOAP_TYPE_ns1__InboundInContainer (43)
#endif

/* ns1__Inbound has binding name 'ns1__Inbound' for type 'ns1:Inbound' */
#ifndef SOAP_TYPE_ns1__Inbound
#define SOAP_TYPE_ns1__Inbound (42)
#endif

/* ns1__Heartbeat has binding name 'ns1__Heartbeat' for type 'ns1:Heartbeat' */
#ifndef SOAP_TYPE_ns1__Heartbeat
#define SOAP_TYPE_ns1__Heartbeat (41)
#endif

/* ns1__ApiResponseDataForScadaOfString has binding name 'ns1__ApiResponseDataForScadaOfString' for type 'ns1:ApiResponseDataForScadaOfString' */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfString
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfString (40)
#endif

/* ns1__GenerateCellSFC has binding name 'ns1__GenerateCellSFC' for type 'ns1:GenerateCellSFC' */
#ifndef SOAP_TYPE_ns1__GenerateCellSFC
#define SOAP_TYPE_ns1__GenerateCellSFC (39)
#endif

/* ns1__FillingData has binding name 'ns1__FillingData' for type 'ns1:FillingData' */
#ifndef SOAP_TYPE_ns1__FillingData
#define SOAP_TYPE_ns1__FillingData (38)
#endif

/* ns1__FeedingDJInLaminatingByScadaDTO has binding name 'ns1__FeedingDJInLaminatingByScadaDTO' for type 'ns1:FeedingDJInLaminatingByScadaDTO' */
#ifndef SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO
#define SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO (37)
#endif

/* ns1__FeedingByScadaDTO has binding name 'ns1__FeedingByScadaDTO' for type 'ns1:FeedingByScadaDTO' */
#ifndef SOAP_TYPE_ns1__FeedingByScadaDTO
#define SOAP_TYPE_ns1__FeedingByScadaDTO (36)
#endif

/* ns1__ExamineExistsByScadaDTO has binding name 'ns1__ExamineExistsByScadaDTO' for type 'ns1:ExamineExistsByScadaDTO' */
#ifndef SOAP_TYPE_ns1__ExamineExistsByScadaDTO
#define SOAP_TYPE_ns1__ExamineExistsByScadaDTO (35)
#endif

/* ns1__ArrayOfApiResponseSFCForScada has binding name 'ns1__ArrayOfApiResponseSFCForScada' for type 'ns1:ArrayOfApiResponseSFCForScada' */
#ifndef SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada
#define SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada (34)
#endif

/* ns1__ApiResponseSFCForScada has binding name 'ns1__ApiResponseSFCForScada' for type 'ns1:ApiResponseSFCForScada' */
#ifndef SOAP_TYPE_ns1__ApiResponseSFCForScada
#define SOAP_TYPE_ns1__ApiResponseSFCForScada (33)
#endif

/* ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada has binding name 'ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada' for type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada' */
#ifndef SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada
#define SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada (32)
#endif

/* ns1__EquipmentProductProcessParamSFC has binding name 'ns1__EquipmentProductProcessParamSFC' for type 'ns1:EquipmentProductProcessParamSFC' */
#ifndef SOAP_TYPE_ns1__EquipmentProductProcessParamSFC
#define SOAP_TYPE_ns1__EquipmentProductProcessParamSFC (31)
#endif

/* ns1__ArrayOfEquipmentProductProcessParamSFC has binding name 'ns1__ArrayOfEquipmentProductProcessParamSFC' for type 'ns1:ArrayOfEquipmentProductProcessParamSFC' */
#ifndef SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC
#define SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC (30)
#endif

/* ns1__EquipmentProductProcessParam has binding name 'ns1__EquipmentProductProcessParam' for type 'ns1:EquipmentProductProcessParam' */
#ifndef SOAP_TYPE_ns1__EquipmentProductProcessParam
#define SOAP_TYPE_ns1__EquipmentProductProcessParam (29)
#endif

/* ns1__ParamDTO has binding name 'ns1__ParamDTO' for type 'ns1:ParamDTO' */
#ifndef SOAP_TYPE_ns1__ParamDTO
#define SOAP_TYPE_ns1__ParamDTO (28)
#endif

/* ns1__ArrayOfParamDTO has binding name 'ns1__ArrayOfParamDTO' for type 'ns1:ArrayOfParamDTO' */
#ifndef SOAP_TYPE_ns1__ArrayOfParamDTO
#define SOAP_TYPE_ns1__ArrayOfParamDTO (27)
#endif

/* ns1__EquipmentProcessParam has binding name 'ns1__EquipmentProcessParam' for type 'ns1:EquipmentProcessParam' */
#ifndef SOAP_TYPE_ns1__EquipmentProcessParam
#define SOAP_TYPE_ns1__EquipmentProcessParam (26)
#endif

/* ns1__DownReason has binding name 'ns1__DownReason' for type 'ns1:DownReason' */
#ifndef SOAP_TYPE_ns1__DownReason
#define SOAP_TYPE_ns1__DownReason (25)
#endif

/* ns1__ArrayOfDownReason has binding name 'ns1__ArrayOfDownReason' for type 'ns1:ArrayOfDownReason' */
#ifndef SOAP_TYPE_ns1__ArrayOfDownReason
#define SOAP_TYPE_ns1__ArrayOfDownReason (24)
#endif

/* ns1__CCDFileUploadCompleteSFC has binding name 'ns1__CCDFileUploadCompleteSFC' for type 'ns1:CCDFileUploadCompleteSFC' */
#ifndef SOAP_TYPE_ns1__CCDFileUploadCompleteSFC
#define SOAP_TYPE_ns1__CCDFileUploadCompleteSFC (23)
#endif

/* ns1__ArrayOfCCDFileUploadCompleteSFC has binding name 'ns1__ArrayOfCCDFileUploadCompleteSFC' for type 'ns1:ArrayOfCCDFileUploadCompleteSFC' */
#ifndef SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC
#define SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC (22)
#endif

/* ns1__CCDFileUploadComplete has binding name 'ns1__CCDFileUploadComplete' for type 'ns1:CCDFileUploadComplete' */
#ifndef SOAP_TYPE_ns1__CCDFileUploadComplete
#define SOAP_TYPE_ns1__CCDFileUploadComplete (21)
#endif

/* ns1__ArrayOfString has binding name 'ns1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (20)
#endif

/* ns1__BindSFCByScadaDTO has binding name 'ns1__BindSFCByScadaDTO' for type 'ns1:BindSFCByScadaDTO' */
#ifndef SOAP_TYPE_ns1__BindSFCByScadaDTO
#define SOAP_TYPE_ns1__BindSFCByScadaDTO (19)
#endif

/* ns1__BindContainerSFC has binding name 'ns1__BindContainerSFC' for type 'ns1:BindContainerSFC' */
#ifndef SOAP_TYPE_ns1__BindContainerSFC
#define SOAP_TYPE_ns1__BindContainerSFC (18)
#endif

/* ns1__ArrayOfBindContainerSFC has binding name 'ns1__ArrayOfBindContainerSFC' for type 'ns1:ArrayOfBindContainerSFC' */
#ifndef SOAP_TYPE_ns1__ArrayOfBindContainerSFC
#define SOAP_TYPE_ns1__ArrayOfBindContainerSFC (17)
#endif

/* ns1__BindContainer has binding name 'ns1__BindContainer' for type 'ns1:BindContainer' */
#ifndef SOAP_TYPE_ns1__BindContainer
#define SOAP_TYPE_ns1__BindContainer (16)
#endif

/* ns1__LoginSoapHeader has binding name 'ns1__LoginSoapHeader' for type 'ns1:LoginSoapHeader' */
#ifndef SOAP_TYPE_ns1__LoginSoapHeader
#define SOAP_TYPE_ns1__LoginSoapHeader (15)
#endif

/* ns1__BaseApiResponseForScada has binding name 'ns1__BaseApiResponseForScada' for type 'ns1:BaseApiResponseForScada' */
#ifndef SOAP_TYPE_ns1__BaseApiResponseForScada
#define SOAP_TYPE_ns1__BaseApiResponseForScada (14)
#endif

/* ns1__ApiResponseForScada has binding name 'ns1__ApiResponseForScada' for type 'ns1:ApiResponseForScada' */
#ifndef SOAP_TYPE_ns1__ApiResponseForScada
#define SOAP_TYPE_ns1__ApiResponseForScada (13)
#endif

/* ns1__BaseApiRequestByScada has binding name 'ns1__BaseApiRequestByScada' for type 'ns1:BaseApiRequestByScada' */
#ifndef SOAP_TYPE_ns1__BaseApiRequestByScada
#define SOAP_TYPE_ns1__BaseApiRequestByScada (12)
#endif

/* ns1__Alarm has binding name 'ns1__Alarm' for type 'ns1:Alarm' */
#ifndef SOAP_TYPE_ns1__Alarm
#define SOAP_TYPE_ns1__Alarm (11)
#endif

/* ns1__ArrayOfAlarm has binding name 'ns1__ArrayOfAlarm' for type 'ns1:ArrayOfAlarm' */
#ifndef SOAP_TYPE_ns1__ArrayOfAlarm
#define SOAP_TYPE_ns1__ArrayOfAlarm (10)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (410)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (409)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (406)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (404)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (216)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (412)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (411)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (405)
#endif

/* _ns1__UnBindSFC * has binding name 'PointerTo_ns1__UnBindSFC' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UnBindSFC
#define SOAP_TYPE_PointerTo_ns1__UnBindSFC (398)
#endif

/* _ns1__ToolLife * has binding name 'PointerTo_ns1__ToolLife' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ToolLife
#define SOAP_TYPE_PointerTo_ns1__ToolLife (392)
#endif

/* _ns1__ToolBind * has binding name 'PointerTo_ns1__ToolBind' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ToolBind
#define SOAP_TYPE_PointerTo_ns1__ToolBind (386)
#endif

/* _ns1__State * has binding name 'PointerTo_ns1__State' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__State
#define SOAP_TYPE_PointerTo_ns1__State (380)
#endif

/* _ns1__RecipeVersionExamine * has binding name 'PointerTo_ns1__RecipeVersionExamine' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RecipeVersionExamine
#define SOAP_TYPE_PointerTo_ns1__RecipeVersionExamine (374)
#endif

/* _ns1__GetRecipeList * has binding name 'PointerTo_ns1__GetRecipeList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRecipeList
#define SOAP_TYPE_PointerTo_ns1__GetRecipeList (368)
#endif

/* _ns1__GetRecipe * has binding name 'PointerTo_ns1__GetRecipe' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRecipe
#define SOAP_TYPE_PointerTo_ns1__GetRecipe (362)
#endif

/* _ns1__Recipe * has binding name 'PointerTo_ns1__Recipe' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Recipe
#define SOAP_TYPE_PointerTo_ns1__Recipe (356)
#endif

/* _ns1__OutboundMore * has binding name 'PointerTo_ns1__OutboundMore' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OutboundMore
#define SOAP_TYPE_PointerTo_ns1__OutboundMore (350)
#endif

/* _ns1__OutboundInSFCOutputQty * has binding name 'PointerTo_ns1__OutboundInSFCOutputQty' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OutboundInSFCOutputQty
#define SOAP_TYPE_PointerTo_ns1__OutboundInSFCOutputQty (344)
#endif

/* _ns1__OutboundInLaminating * has binding name 'PointerTo_ns1__OutboundInLaminating' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OutboundInLaminating
#define SOAP_TYPE_PointerTo_ns1__OutboundInLaminating (338)
#endif

/* _ns1__Outbound * has binding name 'PointerTo_ns1__Outbound' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Outbound
#define SOAP_TYPE_PointerTo_ns1__Outbound (332)
#endif

/* _ns1__OperatorLogin * has binding name 'PointerTo_ns1__OperatorLogin' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OperatorLogin
#define SOAP_TYPE_PointerTo_ns1__OperatorLogin (326)
#endif

/* _ns1__InboundMore * has binding name 'PointerTo_ns1__InboundMore' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InboundMore
#define SOAP_TYPE_PointerTo_ns1__InboundMore (320)
#endif

/* _ns1__InboundInTwoInjection * has binding name 'PointerTo_ns1__InboundInTwoInjection' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InboundInTwoInjection
#define SOAP_TYPE_PointerTo_ns1__InboundInTwoInjection (314)
#endif

/* _ns1__InboundInSFCContainer * has binding name 'PointerTo_ns1__InboundInSFCContainer' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InboundInSFCContainer
#define SOAP_TYPE_PointerTo_ns1__InboundInSFCContainer (308)
#endif

/* _ns1__InboundInContainer * has binding name 'PointerTo_ns1__InboundInContainer' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InboundInContainer
#define SOAP_TYPE_PointerTo_ns1__InboundInContainer (302)
#endif

/* _ns1__Inbound * has binding name 'PointerTo_ns1__Inbound' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Inbound
#define SOAP_TYPE_PointerTo_ns1__Inbound (296)
#endif

/* _ns1__Heartbeat * has binding name 'PointerTo_ns1__Heartbeat' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Heartbeat
#define SOAP_TYPE_PointerTo_ns1__Heartbeat (290)
#endif

/* _ns1__GenerateCellSFC * has binding name 'PointerTo_ns1__GenerateCellSFC' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GenerateCellSFC
#define SOAP_TYPE_PointerTo_ns1__GenerateCellSFC (284)
#endif

/* _ns1__FillingData * has binding name 'PointerTo_ns1__FillingData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__FillingData
#define SOAP_TYPE_PointerTo_ns1__FillingData (278)
#endif

/* _ns1__FeedingDJInLaminating * has binding name 'PointerTo_ns1__FeedingDJInLaminating' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__FeedingDJInLaminating
#define SOAP_TYPE_PointerTo_ns1__FeedingDJInLaminating (272)
#endif

/* _ns1__Feeding * has binding name 'PointerTo_ns1__Feeding' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Feeding
#define SOAP_TYPE_PointerTo_ns1__Feeding (266)
#endif

/* _ns1__ExamineExists * has binding name 'PointerTo_ns1__ExamineExists' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ExamineExists
#define SOAP_TYPE_PointerTo_ns1__ExamineExists (260)
#endif

/* _ns1__EquipmentProductProcessParam * has binding name 'PointerTo_ns1__EquipmentProductProcessParam' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EquipmentProductProcessParam
#define SOAP_TYPE_PointerTo_ns1__EquipmentProductProcessParam (254)
#endif

/* _ns1__EquipmentProcessParam * has binding name 'PointerTo_ns1__EquipmentProcessParam' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EquipmentProcessParam
#define SOAP_TYPE_PointerTo_ns1__EquipmentProcessParam (248)
#endif

/* _ns1__DownReason * has binding name 'PointerTo_ns1__DownReason' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DownReason
#define SOAP_TYPE_PointerTo_ns1__DownReason (242)
#endif

/* _ns1__CCDFileUploadComplete * has binding name 'PointerTo_ns1__CCDFileUploadComplete' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CCDFileUploadComplete
#define SOAP_TYPE_PointerTo_ns1__CCDFileUploadComplete (236)
#endif

/* _ns1__BindSFC * has binding name 'PointerTo_ns1__BindSFC' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BindSFC
#define SOAP_TYPE_PointerTo_ns1__BindSFC (230)
#endif

/* _ns1__BindContainer * has binding name 'PointerTo_ns1__BindContainer' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BindContainer
#define SOAP_TYPE_PointerTo_ns1__BindContainer (224)
#endif

/* _ns1__Alarm * has binding name 'PointerTo_ns1__Alarm' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Alarm
#define SOAP_TYPE_PointerTo_ns1__Alarm (218)
#endif

/* ns1__LoginSoapHeader * has binding name 'PointerTons1__LoginSoapHeader' for type 'ns1:LoginSoapHeader' */
#ifndef SOAP_TYPE_PointerTons1__LoginSoapHeader
#define SOAP_TYPE_PointerTons1__LoginSoapHeader (217)
#endif

/* ns1__ArrayOfRecipeListGetForEqu * has binding name 'PointerTons1__ArrayOfRecipeListGetForEqu' for type 'ns1:ArrayOfRecipeListGetForEqu' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfRecipeListGetForEqu
#define SOAP_TYPE_PointerTons1__ArrayOfRecipeListGetForEqu (215)
#endif

/* ns1__RecipeGetForEqu * has binding name 'PointerTons1__RecipeGetForEqu' for type 'ns1:RecipeGetForEqu' */
#ifndef SOAP_TYPE_PointerTons1__RecipeGetForEqu
#define SOAP_TYPE_PointerTons1__RecipeGetForEqu (214)
#endif

/* ns1__ArrayOfRecipeParam * has binding name 'PointerTons1__ArrayOfRecipeParam' for type 'ns1:ArrayOfRecipeParam' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfRecipeParam
#define SOAP_TYPE_PointerTons1__ArrayOfRecipeParam (213)
#endif

/* ns1__ArrayOfOutboundSFC * has binding name 'PointerTons1__ArrayOfOutboundSFC' for type 'ns1:ArrayOfOutboundSFC' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfOutboundSFC
#define SOAP_TYPE_PointerTons1__ArrayOfOutboundSFC (212)
#endif

/* ns1__InboundInTwoInjectionForEqu * has binding name 'PointerTons1__InboundInTwoInjectionForEqu' for type 'ns1:InboundInTwoInjectionForEqu' */
#ifndef SOAP_TYPE_PointerTons1__InboundInTwoInjectionForEqu
#define SOAP_TYPE_PointerTons1__InboundInTwoInjectionForEqu (211)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (210)
#endif

/* std::wstring * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_PointerToxsd__decimal
#define SOAP_TYPE_PointerToxsd__decimal (208)
#endif

/* ns1__ArrayOfApiResponseSFCForScada * has binding name 'PointerTons1__ArrayOfApiResponseSFCForScada' for type 'ns1:ArrayOfApiResponseSFCForScada' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfApiResponseSFCForScada
#define SOAP_TYPE_PointerTons1__ArrayOfApiResponseSFCForScada (207)
#endif

/* ns1__ArrayOfEquipmentProductProcessParamSFC * has binding name 'PointerTons1__ArrayOfEquipmentProductProcessParamSFC' for type 'ns1:ArrayOfEquipmentProductProcessParamSFC' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfEquipmentProductProcessParamSFC
#define SOAP_TYPE_PointerTons1__ArrayOfEquipmentProductProcessParamSFC (206)
#endif

/* ns1__ArrayOfCCDFileUploadCompleteSFC * has binding name 'PointerTons1__ArrayOfCCDFileUploadCompleteSFC' for type 'ns1:ArrayOfCCDFileUploadCompleteSFC' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfCCDFileUploadCompleteSFC
#define SOAP_TYPE_PointerTons1__ArrayOfCCDFileUploadCompleteSFC (205)
#endif

/* ns1__ArrayOfBindContainerSFC * has binding name 'PointerTons1__ArrayOfBindContainerSFC' for type 'ns1:ArrayOfBindContainerSFC' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfBindContainerSFC
#define SOAP_TYPE_PointerTons1__ArrayOfBindContainerSFC (204)
#endif

/* ns1__UnBindSFCByScadaDTO * has binding name 'PointerTons1__UnBindSFCByScadaDTO' for type 'ns1:UnBindSFCByScadaDTO' */
#ifndef SOAP_TYPE_PointerTons1__UnBindSFCByScadaDTO
#define SOAP_TYPE_PointerTons1__UnBindSFCByScadaDTO (203)
#endif

/* ns1__ToolLife * has binding name 'PointerTons1__ToolLife' for type 'ns1:ToolLife' */
#ifndef SOAP_TYPE_PointerTons1__ToolLife
#define SOAP_TYPE_PointerTons1__ToolLife (202)
#endif

/* ns1__ToolBind * has binding name 'PointerTons1__ToolBind' for type 'ns1:ToolBind' */
#ifndef SOAP_TYPE_PointerTons1__ToolBind
#define SOAP_TYPE_PointerTons1__ToolBind (201)
#endif

/* ns1__State * has binding name 'PointerTons1__State' for type 'ns1:State' */
#ifndef SOAP_TYPE_PointerTons1__State
#define SOAP_TYPE_PointerTons1__State (200)
#endif

/* ns1__RecipeVersionExamine * has binding name 'PointerTons1__RecipeVersionExamine' for type 'ns1:RecipeVersionExamine' */
#ifndef SOAP_TYPE_PointerTons1__RecipeVersionExamine
#define SOAP_TYPE_PointerTons1__RecipeVersionExamine (199)
#endif

/* ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu * has binding name 'PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu' for type 'ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu
#define SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu (198)
#endif

/* ns1__RecipeListGet * has binding name 'PointerTons1__RecipeListGet' for type 'ns1:RecipeListGet' */
#ifndef SOAP_TYPE_PointerTons1__RecipeListGet
#define SOAP_TYPE_PointerTons1__RecipeListGet (197)
#endif

/* ns1__ApiResponseDataForScadaOfRecipeGetForEqu * has binding name 'PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu' for type 'ns1:ApiResponseDataForScadaOfRecipeGetForEqu' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu
#define SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu (196)
#endif

/* ns1__RecipeGet * has binding name 'PointerTons1__RecipeGet' for type 'ns1:RecipeGet' */
#ifndef SOAP_TYPE_PointerTons1__RecipeGet
#define SOAP_TYPE_PointerTons1__RecipeGet (195)
#endif

/* ns1__Recipe * has binding name 'PointerTons1__Recipe' for type 'ns1:Recipe' */
#ifndef SOAP_TYPE_PointerTons1__Recipe
#define SOAP_TYPE_PointerTons1__Recipe (194)
#endif

/* ns1__OutboundMore * has binding name 'PointerTons1__OutboundMore' for type 'ns1:OutboundMore' */
#ifndef SOAP_TYPE_PointerTons1__OutboundMore
#define SOAP_TYPE_PointerTons1__OutboundMore (193)
#endif

/* ns1__OutboundInSFCOutputQty * has binding name 'PointerTons1__OutboundInSFCOutputQty' for type 'ns1:OutboundInSFCOutputQty' */
#ifndef SOAP_TYPE_PointerTons1__OutboundInSFCOutputQty
#define SOAP_TYPE_PointerTons1__OutboundInSFCOutputQty (192)
#endif

/* ns1__OutboundInLaminating * has binding name 'PointerTons1__OutboundInLaminating' for type 'ns1:OutboundInLaminating' */
#ifndef SOAP_TYPE_PointerTons1__OutboundInLaminating
#define SOAP_TYPE_PointerTons1__OutboundInLaminating (191)
#endif

/* ns1__Outbound * has binding name 'PointerTons1__Outbound' for type 'ns1:Outbound' */
#ifndef SOAP_TYPE_PointerTons1__Outbound
#define SOAP_TYPE_PointerTons1__Outbound (190)
#endif

/* ns1__OperatorLogin * has binding name 'PointerTons1__OperatorLogin' for type 'ns1:OperatorLogin' */
#ifndef SOAP_TYPE_PointerTons1__OperatorLogin
#define SOAP_TYPE_PointerTons1__OperatorLogin (189)
#endif

/* ns1__InboundMore * has binding name 'PointerTons1__InboundMore' for type 'ns1:InboundMore' */
#ifndef SOAP_TYPE_PointerTons1__InboundMore
#define SOAP_TYPE_PointerTons1__InboundMore (188)
#endif

/* ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu * has binding name 'PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu' for type 'ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu
#define SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu (187)
#endif

/* ns1__InboundInTwoInjection * has binding name 'PointerTons1__InboundInTwoInjection' for type 'ns1:InboundInTwoInjection' */
#ifndef SOAP_TYPE_PointerTons1__InboundInTwoInjection
#define SOAP_TYPE_PointerTons1__InboundInTwoInjection (186)
#endif

/* ns1__InboundInSFCContainer * has binding name 'PointerTons1__InboundInSFCContainer' for type 'ns1:InboundInSFCContainer' */
#ifndef SOAP_TYPE_PointerTons1__InboundInSFCContainer
#define SOAP_TYPE_PointerTons1__InboundInSFCContainer (185)
#endif

/* ns1__InboundInContainer * has binding name 'PointerTons1__InboundInContainer' for type 'ns1:InboundInContainer' */
#ifndef SOAP_TYPE_PointerTons1__InboundInContainer
#define SOAP_TYPE_PointerTons1__InboundInContainer (184)
#endif

/* ns1__Inbound * has binding name 'PointerTons1__Inbound' for type 'ns1:Inbound' */
#ifndef SOAP_TYPE_PointerTons1__Inbound
#define SOAP_TYPE_PointerTons1__Inbound (183)
#endif

/* ns1__Heartbeat * has binding name 'PointerTons1__Heartbeat' for type 'ns1:Heartbeat' */
#ifndef SOAP_TYPE_PointerTons1__Heartbeat
#define SOAP_TYPE_PointerTons1__Heartbeat (182)
#endif

/* ns1__ApiResponseDataForScadaOfString * has binding name 'PointerTons1__ApiResponseDataForScadaOfString' for type 'ns1:ApiResponseDataForScadaOfString' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfString
#define SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfString (181)
#endif

/* ns1__GenerateCellSFC * has binding name 'PointerTons1__GenerateCellSFC' for type 'ns1:GenerateCellSFC' */
#ifndef SOAP_TYPE_PointerTons1__GenerateCellSFC
#define SOAP_TYPE_PointerTons1__GenerateCellSFC (180)
#endif

/* ns1__FillingData * has binding name 'PointerTons1__FillingData' for type 'ns1:FillingData' */
#ifndef SOAP_TYPE_PointerTons1__FillingData
#define SOAP_TYPE_PointerTons1__FillingData (179)
#endif

/* ns1__FeedingDJInLaminatingByScadaDTO * has binding name 'PointerTons1__FeedingDJInLaminatingByScadaDTO' for type 'ns1:FeedingDJInLaminatingByScadaDTO' */
#ifndef SOAP_TYPE_PointerTons1__FeedingDJInLaminatingByScadaDTO
#define SOAP_TYPE_PointerTons1__FeedingDJInLaminatingByScadaDTO (178)
#endif

/* ns1__FeedingByScadaDTO * has binding name 'PointerTons1__FeedingByScadaDTO' for type 'ns1:FeedingByScadaDTO' */
#ifndef SOAP_TYPE_PointerTons1__FeedingByScadaDTO
#define SOAP_TYPE_PointerTons1__FeedingByScadaDTO (177)
#endif

/* ns1__ExamineExistsByScadaDTO * has binding name 'PointerTons1__ExamineExistsByScadaDTO' for type 'ns1:ExamineExistsByScadaDTO' */
#ifndef SOAP_TYPE_PointerTons1__ExamineExistsByScadaDTO
#define SOAP_TYPE_PointerTons1__ExamineExistsByScadaDTO (176)
#endif

/* ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada * has binding name 'PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada' for type 'ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada
#define SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada (175)
#endif

/* ns1__EquipmentProductProcessParam * has binding name 'PointerTons1__EquipmentProductProcessParam' for type 'ns1:EquipmentProductProcessParam' */
#ifndef SOAP_TYPE_PointerTons1__EquipmentProductProcessParam
#define SOAP_TYPE_PointerTons1__EquipmentProductProcessParam (174)
#endif

/* ns1__EquipmentProcessParam * has binding name 'PointerTons1__EquipmentProcessParam' for type 'ns1:EquipmentProcessParam' */
#ifndef SOAP_TYPE_PointerTons1__EquipmentProcessParam
#define SOAP_TYPE_PointerTons1__EquipmentProcessParam (173)
#endif

/* ns1__ArrayOfDownReason * has binding name 'PointerTons1__ArrayOfDownReason' for type 'ns1:ArrayOfDownReason' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfDownReason
#define SOAP_TYPE_PointerTons1__ArrayOfDownReason (172)
#endif

/* ns1__CCDFileUploadComplete * has binding name 'PointerTons1__CCDFileUploadComplete' for type 'ns1:CCDFileUploadComplete' */
#ifndef SOAP_TYPE_PointerTons1__CCDFileUploadComplete
#define SOAP_TYPE_PointerTons1__CCDFileUploadComplete (171)
#endif

/* ns1__BindSFCByScadaDTO * has binding name 'PointerTons1__BindSFCByScadaDTO' for type 'ns1:BindSFCByScadaDTO' */
#ifndef SOAP_TYPE_PointerTons1__BindSFCByScadaDTO
#define SOAP_TYPE_PointerTons1__BindSFCByScadaDTO (170)
#endif

/* ns1__BindContainer * has binding name 'PointerTons1__BindContainer' for type 'ns1:BindContainer' */
#ifndef SOAP_TYPE_PointerTons1__BindContainer
#define SOAP_TYPE_PointerTons1__BindContainer (169)
#endif

/* ns1__ApiResponseForScada * has binding name 'PointerTons1__ApiResponseForScada' for type 'ns1:ApiResponseForScada' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseForScada
#define SOAP_TYPE_PointerTons1__ApiResponseForScada (168)
#endif

/* ns1__ArrayOfAlarm * has binding name 'PointerTons1__ArrayOfAlarm' for type 'ns1:ArrayOfAlarm' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfAlarm
#define SOAP_TYPE_PointerTons1__ArrayOfAlarm (167)
#endif

/* ns1__RecipeListGetForEqu * has binding name 'PointerTons1__RecipeListGetForEqu' for type 'ns1:RecipeListGetForEqu' */
#ifndef SOAP_TYPE_PointerTons1__RecipeListGetForEqu
#define SOAP_TYPE_PointerTons1__RecipeListGetForEqu (165)
#endif

/* ns1__RecipeGetParamForEqu * has binding name 'PointerTons1__RecipeGetParamForEqu' for type 'ns1:RecipeGetParamForEqu' */
#ifndef SOAP_TYPE_PointerTons1__RecipeGetParamForEqu
#define SOAP_TYPE_PointerTons1__RecipeGetParamForEqu (163)
#endif

/* ns1__ArrayOfRecipeGetParamForEqu * has binding name 'PointerTons1__ArrayOfRecipeGetParamForEqu' for type 'ns1:ArrayOfRecipeGetParamForEqu' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfRecipeGetParamForEqu
#define SOAP_TYPE_PointerTons1__ArrayOfRecipeGetParamForEqu (162)
#endif

/* ns1__RecipeParam * has binding name 'PointerTons1__RecipeParam' for type 'ns1:RecipeParam' */
#ifndef SOAP_TYPE_PointerTons1__RecipeParam
#define SOAP_TYPE_PointerTons1__RecipeParam (160)
#endif

/* ns1__ArrayOfString * has binding name 'PointerTons1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfString
#define SOAP_TYPE_PointerTons1__ArrayOfString (159)
#endif

/* ns1__OutboundSFC * has binding name 'PointerTons1__OutboundSFC' for type 'ns1:OutboundSFC' */
#ifndef SOAP_TYPE_PointerTons1__OutboundSFC
#define SOAP_TYPE_PointerTons1__OutboundSFC (157)
#endif

/* ns1__ApiResponseSFCForScada * has binding name 'PointerTons1__ApiResponseSFCForScada' for type 'ns1:ApiResponseSFCForScada' */
#ifndef SOAP_TYPE_PointerTons1__ApiResponseSFCForScada
#define SOAP_TYPE_PointerTons1__ApiResponseSFCForScada (154)
#endif

/* ns1__ArrayOfParamDTO * has binding name 'PointerTons1__ArrayOfParamDTO' for type 'ns1:ArrayOfParamDTO' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfParamDTO
#define SOAP_TYPE_PointerTons1__ArrayOfParamDTO (153)
#endif

/* ns1__EquipmentProductProcessParamSFC * has binding name 'PointerTons1__EquipmentProductProcessParamSFC' for type 'ns1:EquipmentProductProcessParamSFC' */
#ifndef SOAP_TYPE_PointerTons1__EquipmentProductProcessParamSFC
#define SOAP_TYPE_PointerTons1__EquipmentProductProcessParamSFC (151)
#endif

/* ns1__ParamDTO * has binding name 'PointerTons1__ParamDTO' for type 'ns1:ParamDTO' */
#ifndef SOAP_TYPE_PointerTons1__ParamDTO
#define SOAP_TYPE_PointerTons1__ParamDTO (149)
#endif

/* ns1__DownReason * has binding name 'PointerTons1__DownReason' for type 'ns1:DownReason' */
#ifndef SOAP_TYPE_PointerTons1__DownReason
#define SOAP_TYPE_PointerTons1__DownReason (147)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (146)
#endif

/* ns1__CCDFileUploadCompleteSFC * has binding name 'PointerTons1__CCDFileUploadCompleteSFC' for type 'ns1:CCDFileUploadCompleteSFC' */
#ifndef SOAP_TYPE_PointerTons1__CCDFileUploadCompleteSFC
#define SOAP_TYPE_PointerTons1__CCDFileUploadCompleteSFC (144)
#endif

/* ns1__BindContainerSFC * has binding name 'PointerTons1__BindContainerSFC' for type 'ns1:BindContainerSFC' */
#ifndef SOAP_TYPE_PointerTons1__BindContainerSFC
#define SOAP_TYPE_PointerTons1__BindContainerSFC (141)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (139)
#endif

/* ns1__Alarm * has binding name 'PointerTons1__Alarm' for type 'ns1:Alarm' */
#ifndef SOAP_TYPE_PointerTons1__Alarm
#define SOAP_TYPE_PointerTons1__Alarm (135)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__RecipeListGetForEqu *>  has binding name 'std__vectorTemplateOfPointerTons1__RecipeListGetForEqu' for type 'ns1:RecipeListGetForEqu' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu (166)
#endif

/* std::vector<ns1__RecipeGetParamForEqu *>  has binding name 'std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu' for type 'ns1:RecipeGetParamForEqu' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu (164)
#endif

/* std::vector<ns1__RecipeParam *>  has binding name 'std__vectorTemplateOfPointerTons1__RecipeParam' for type 'ns1:RecipeParam' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam (161)
#endif

/* std::vector<ns1__OutboundSFC *>  has binding name 'std__vectorTemplateOfPointerTons1__OutboundSFC' for type 'ns1:OutboundSFC' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC (158)
#endif

/* std::vector<ns1__ApiResponseSFCForScada *>  has binding name 'std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada' for type 'ns1:ApiResponseSFCForScada' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada (155)
#endif

/* std::vector<ns1__EquipmentProductProcessParamSFC *>  has binding name 'std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC' for type 'ns1:EquipmentProductProcessParamSFC' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC (152)
#endif

/* std::vector<ns1__ParamDTO *>  has binding name 'std__vectorTemplateOfPointerTons1__ParamDTO' for type 'ns1:ParamDTO' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO (150)
#endif

/* std::vector<ns1__DownReason *>  has binding name 'std__vectorTemplateOfPointerTons1__DownReason' for type 'ns1:DownReason' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason (148)
#endif

/* std::vector<ns1__CCDFileUploadCompleteSFC *>  has binding name 'std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC' for type 'ns1:CCDFileUploadCompleteSFC' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC (145)
#endif

/* std::vector<std::wstring>  has binding name 'std__vectorTemplateOfstd__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__wstring
#define SOAP_TYPE_std__vectorTemplateOfstd__wstring (143)
#endif

/* std::vector<ns1__BindContainerSFC *>  has binding name 'std__vectorTemplateOfPointerTons1__BindContainerSFC' for type 'ns1:BindContainerSFC' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC (142)
#endif

/* std::vector<ns1__Alarm *>  has binding name 'std__vectorTemplateOfPointerTons1__Alarm' for type 'ns1:Alarm' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm (136)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
