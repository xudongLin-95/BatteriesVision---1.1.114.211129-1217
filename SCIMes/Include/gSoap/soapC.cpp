/* soapC.cpp
   Generated by gSOAP 2.8.108 for mes_cc2_1.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.108 2020-10-22 18:07:42 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		return soap_in_ns1__UnBindSFCByScadaDTO(soap, tag, NULL, "ns1:UnBindSFCByScadaDTO");
	case SOAP_TYPE_ns1__ToolLife:
		return soap_in_ns1__ToolLife(soap, tag, NULL, "ns1:ToolLife");
	case SOAP_TYPE_ns1__ToolBind:
		return soap_in_ns1__ToolBind(soap, tag, NULL, "ns1:ToolBind");
	case SOAP_TYPE_ns1__State:
		return soap_in_ns1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		return soap_in_ns1__RecipeVersionExamine(soap, tag, NULL, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		return soap_in_ns1__RecipeListGetForEqu(soap, tag, NULL, "ns1:RecipeListGetForEqu");
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		return soap_in_ns1__ArrayOfRecipeListGetForEqu(soap, tag, NULL, "ns1:ArrayOfRecipeListGetForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		return soap_in_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu");
	case SOAP_TYPE_ns1__RecipeListGet:
		return soap_in_ns1__RecipeListGet(soap, tag, NULL, "ns1:RecipeListGet");
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		return soap_in_ns1__RecipeGetParamForEqu(soap, tag, NULL, "ns1:RecipeGetParamForEqu");
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		return soap_in_ns1__ArrayOfRecipeGetParamForEqu(soap, tag, NULL, "ns1:ArrayOfRecipeGetParamForEqu");
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		return soap_in_ns1__RecipeGetForEqu(soap, tag, NULL, "ns1:RecipeGetForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		return soap_in_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu");
	case SOAP_TYPE_ns1__RecipeGet:
		return soap_in_ns1__RecipeGet(soap, tag, NULL, "ns1:RecipeGet");
	case SOAP_TYPE_ns1__RecipeParam:
		return soap_in_ns1__RecipeParam(soap, tag, NULL, "ns1:RecipeParam");
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		return soap_in_ns1__ArrayOfRecipeParam(soap, tag, NULL, "ns1:ArrayOfRecipeParam");
	case SOAP_TYPE_ns1__Recipe:
		return soap_in_ns1__Recipe(soap, tag, NULL, "ns1:Recipe");
	case SOAP_TYPE_ns1__OutboundSFC:
		return soap_in_ns1__OutboundSFC(soap, tag, NULL, "ns1:OutboundSFC");
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		return soap_in_ns1__ArrayOfOutboundSFC(soap, tag, NULL, "ns1:ArrayOfOutboundSFC");
	case SOAP_TYPE_ns1__OutboundMore:
		return soap_in_ns1__OutboundMore(soap, tag, NULL, "ns1:OutboundMore");
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		return soap_in_ns1__OutboundInSFCOutputQty(soap, tag, NULL, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_ns1__OutboundInLaminating:
		return soap_in_ns1__OutboundInLaminating(soap, tag, NULL, "ns1:OutboundInLaminating");
	case SOAP_TYPE_ns1__Outbound:
		return soap_in_ns1__Outbound(soap, tag, NULL, "ns1:Outbound");
	case SOAP_TYPE_ns1__OperatorLogin:
		return soap_in_ns1__OperatorLogin(soap, tag, NULL, "ns1:OperatorLogin");
	case SOAP_TYPE_ns1__InboundMore:
		return soap_in_ns1__InboundMore(soap, tag, NULL, "ns1:InboundMore");
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		return soap_in_ns1__InboundInTwoInjectionForEqu(soap, tag, NULL, "ns1:InboundInTwoInjectionForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		return soap_in_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu");
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		return soap_in_ns1__InboundInTwoInjection(soap, tag, NULL, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		return soap_in_ns1__InboundInSFCContainer(soap, tag, NULL, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_ns1__InboundInContainer:
		return soap_in_ns1__InboundInContainer(soap, tag, NULL, "ns1:InboundInContainer");
	case SOAP_TYPE_ns1__Inbound:
		return soap_in_ns1__Inbound(soap, tag, NULL, "ns1:Inbound");
	case SOAP_TYPE_ns1__Heartbeat:
		return soap_in_ns1__Heartbeat(soap, tag, NULL, "ns1:Heartbeat");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		return soap_in_ns1__ApiResponseDataForScadaOfString(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfString");
	case SOAP_TYPE_ns1__GenerateCellSFC:
		return soap_in_ns1__GenerateCellSFC(soap, tag, NULL, "ns1:GenerateCellSFC");
	case SOAP_TYPE_ns1__FillingData:
		return soap_in_ns1__FillingData(soap, tag, NULL, "ns1:FillingData");
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		return soap_in_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag, NULL, "ns1:FeedingDJInLaminatingByScadaDTO");
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		return soap_in_ns1__FeedingByScadaDTO(soap, tag, NULL, "ns1:FeedingByScadaDTO");
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		return soap_in_ns1__ExamineExistsByScadaDTO(soap, tag, NULL, "ns1:ExamineExistsByScadaDTO");
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		return soap_in_ns1__ArrayOfApiResponseSFCForScada(soap, tag, NULL, "ns1:ArrayOfApiResponseSFCForScada");
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		return soap_in_ns1__ApiResponseSFCForScada(soap, tag, NULL, "ns1:ApiResponseSFCForScada");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		return soap_in_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada");
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		return soap_in_ns1__EquipmentProductProcessParamSFC(soap, tag, NULL, "ns1:EquipmentProductProcessParamSFC");
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		return soap_in_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, NULL, "ns1:ArrayOfEquipmentProductProcessParamSFC");
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		return soap_in_ns1__EquipmentProductProcessParam(soap, tag, NULL, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_ns1__ParamDTO:
		return soap_in_ns1__ParamDTO(soap, tag, NULL, "ns1:ParamDTO");
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		return soap_in_ns1__ArrayOfParamDTO(soap, tag, NULL, "ns1:ArrayOfParamDTO");
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		return soap_in_ns1__EquipmentProcessParam(soap, tag, NULL, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_ns1__DownReason:
		return soap_in_ns1__DownReason(soap, tag, NULL, "ns1:DownReason");
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		return soap_in_ns1__ArrayOfDownReason(soap, tag, NULL, "ns1:ArrayOfDownReason");
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		return soap_in_ns1__CCDFileUploadCompleteSFC(soap, tag, NULL, "ns1:CCDFileUploadCompleteSFC");
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		return soap_in_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, NULL, "ns1:ArrayOfCCDFileUploadCompleteSFC");
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		return soap_in_ns1__CCDFileUploadComplete(soap, tag, NULL, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, tag, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		return soap_in_ns1__BindSFCByScadaDTO(soap, tag, NULL, "ns1:BindSFCByScadaDTO");
	case SOAP_TYPE_ns1__BindContainerSFC:
		return soap_in_ns1__BindContainerSFC(soap, tag, NULL, "ns1:BindContainerSFC");
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		return soap_in_ns1__ArrayOfBindContainerSFC(soap, tag, NULL, "ns1:ArrayOfBindContainerSFC");
	case SOAP_TYPE_ns1__BindContainer:
		return soap_in_ns1__BindContainer(soap, tag, NULL, "ns1:BindContainer");
	case SOAP_TYPE_ns1__LoginSoapHeader:
		return soap_in_ns1__LoginSoapHeader(soap, tag, NULL, "ns1:LoginSoapHeader");
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		return soap_in_ns1__BaseApiResponseForScada(soap, tag, NULL, "ns1:BaseApiResponseForScada");
	case SOAP_TYPE_ns1__ApiResponseForScada:
		return soap_in_ns1__ApiResponseForScada(soap, tag, NULL, "ns1:ApiResponseForScada");
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		return soap_in_ns1__BaseApiRequestByScada(soap, tag, NULL, "ns1:BaseApiRequestByScada");
	case SOAP_TYPE_ns1__Alarm:
		return soap_in_ns1__Alarm(soap, tag, NULL, "ns1:Alarm");
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		return soap_in_ns1__ArrayOfAlarm(soap, tag, NULL, "ns1:ArrayOfAlarm");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__UnBindSFC:
		return soap_in_PointerTo_ns1__UnBindSFC(soap, tag, NULL, "ns1:UnBindSFC");
	case SOAP_TYPE_PointerTo_ns1__ToolLife:
		return soap_in_PointerTo_ns1__ToolLife(soap, tag, NULL, "ns1:ToolLife");
	case SOAP_TYPE_PointerTo_ns1__ToolBind:
		return soap_in_PointerTo_ns1__ToolBind(soap, tag, NULL, "ns1:ToolBind");
	case SOAP_TYPE_PointerTo_ns1__State:
		return soap_in_PointerTo_ns1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_PointerTo_ns1__RecipeVersionExamine:
		return soap_in_PointerTo_ns1__RecipeVersionExamine(soap, tag, NULL, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_PointerTo_ns1__GetRecipeList:
		return soap_in_PointerTo_ns1__GetRecipeList(soap, tag, NULL, "ns1:GetRecipeList");
	case SOAP_TYPE_PointerTo_ns1__GetRecipe:
		return soap_in_PointerTo_ns1__GetRecipe(soap, tag, NULL, "ns1:GetRecipe");
	case SOAP_TYPE_PointerTo_ns1__Recipe:
		return soap_in_PointerTo_ns1__Recipe(soap, tag, NULL, "ns1:Recipe");
	case SOAP_TYPE_PointerTo_ns1__OutboundMore:
		return soap_in_PointerTo_ns1__OutboundMore(soap, tag, NULL, "ns1:OutboundMore");
	case SOAP_TYPE_PointerTo_ns1__OutboundInSFCOutputQty:
		return soap_in_PointerTo_ns1__OutboundInSFCOutputQty(soap, tag, NULL, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_PointerTo_ns1__OutboundInLaminating:
		return soap_in_PointerTo_ns1__OutboundInLaminating(soap, tag, NULL, "ns1:OutboundInLaminating");
	case SOAP_TYPE_PointerTo_ns1__Outbound:
		return soap_in_PointerTo_ns1__Outbound(soap, tag, NULL, "ns1:Outbound");
	case SOAP_TYPE_PointerTo_ns1__OperatorLogin:
		return soap_in_PointerTo_ns1__OperatorLogin(soap, tag, NULL, "ns1:OperatorLogin");
	case SOAP_TYPE_PointerTo_ns1__InboundMore:
		return soap_in_PointerTo_ns1__InboundMore(soap, tag, NULL, "ns1:InboundMore");
	case SOAP_TYPE_PointerTo_ns1__InboundInTwoInjection:
		return soap_in_PointerTo_ns1__InboundInTwoInjection(soap, tag, NULL, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_PointerTo_ns1__InboundInSFCContainer:
		return soap_in_PointerTo_ns1__InboundInSFCContainer(soap, tag, NULL, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_PointerTo_ns1__InboundInContainer:
		return soap_in_PointerTo_ns1__InboundInContainer(soap, tag, NULL, "ns1:InboundInContainer");
	case SOAP_TYPE_PointerTo_ns1__Inbound:
		return soap_in_PointerTo_ns1__Inbound(soap, tag, NULL, "ns1:Inbound");
	case SOAP_TYPE_PointerTo_ns1__Heartbeat:
		return soap_in_PointerTo_ns1__Heartbeat(soap, tag, NULL, "ns1:Heartbeat");
	case SOAP_TYPE_PointerTo_ns1__GenerateCellSFC:
		return soap_in_PointerTo_ns1__GenerateCellSFC(soap, tag, NULL, "ns1:GenerateCellSFC");
	case SOAP_TYPE_PointerTo_ns1__FillingData:
		return soap_in_PointerTo_ns1__FillingData(soap, tag, NULL, "ns1:FillingData");
	case SOAP_TYPE_PointerTo_ns1__FeedingDJInLaminating:
		return soap_in_PointerTo_ns1__FeedingDJInLaminating(soap, tag, NULL, "ns1:FeedingDJInLaminating");
	case SOAP_TYPE_PointerTo_ns1__Feeding:
		return soap_in_PointerTo_ns1__Feeding(soap, tag, NULL, "ns1:Feeding");
	case SOAP_TYPE_PointerTo_ns1__ExamineExists:
		return soap_in_PointerTo_ns1__ExamineExists(soap, tag, NULL, "ns1:ExamineExists");
	case SOAP_TYPE_PointerTo_ns1__EquipmentProductProcessParam:
		return soap_in_PointerTo_ns1__EquipmentProductProcessParam(soap, tag, NULL, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_PointerTo_ns1__EquipmentProcessParam:
		return soap_in_PointerTo_ns1__EquipmentProcessParam(soap, tag, NULL, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_PointerTo_ns1__DownReason:
		return soap_in_PointerTo_ns1__DownReason(soap, tag, NULL, "ns1:DownReason");
	case SOAP_TYPE_PointerTo_ns1__CCDFileUploadComplete:
		return soap_in_PointerTo_ns1__CCDFileUploadComplete(soap, tag, NULL, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_PointerTo_ns1__BindSFC:
		return soap_in_PointerTo_ns1__BindSFC(soap, tag, NULL, "ns1:BindSFC");
	case SOAP_TYPE_PointerTo_ns1__BindContainer:
		return soap_in_PointerTo_ns1__BindContainer(soap, tag, NULL, "ns1:BindContainer");
	case SOAP_TYPE_PointerTo_ns1__Alarm:
		return soap_in_PointerTo_ns1__Alarm(soap, tag, NULL, "ns1:Alarm");
	case SOAP_TYPE_PointerTons1__LoginSoapHeader:
		return soap_in_PointerTons1__LoginSoapHeader(soap, tag, NULL, "ns1:LoginSoapHeader");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeListGetForEqu:
		return soap_in_PointerTons1__ArrayOfRecipeListGetForEqu(soap, tag, NULL, "ns1:ArrayOfRecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGetForEqu:
		return soap_in_PointerTons1__RecipeGetForEqu(soap, tag, NULL, "ns1:RecipeGetForEqu");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeParam:
		return soap_in_PointerTons1__ArrayOfRecipeParam(soap, tag, NULL, "ns1:ArrayOfRecipeParam");
	case SOAP_TYPE_PointerTons1__ArrayOfOutboundSFC:
		return soap_in_PointerTons1__ArrayOfOutboundSFC(soap, tag, NULL, "ns1:ArrayOfOutboundSFC");
	case SOAP_TYPE_PointerTons1__InboundInTwoInjectionForEqu:
		return soap_in_PointerTons1__InboundInTwoInjectionForEqu(soap, tag, NULL, "ns1:InboundInTwoInjectionForEqu");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons1__ArrayOfApiResponseSFCForScada:
		return soap_in_PointerTons1__ArrayOfApiResponseSFCForScada(soap, tag, NULL, "ns1:ArrayOfApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfEquipmentProductProcessParamSFC:
		return soap_in_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, NULL, "ns1:ArrayOfEquipmentProductProcessParamSFC");
	case SOAP_TYPE_PointerTons1__ArrayOfCCDFileUploadCompleteSFC:
		return soap_in_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, NULL, "ns1:ArrayOfCCDFileUploadCompleteSFC");
	case SOAP_TYPE_PointerTons1__ArrayOfBindContainerSFC:
		return soap_in_PointerTons1__ArrayOfBindContainerSFC(soap, tag, NULL, "ns1:ArrayOfBindContainerSFC");
	case SOAP_TYPE_PointerTons1__UnBindSFCByScadaDTO:
		return soap_in_PointerTons1__UnBindSFCByScadaDTO(soap, tag, NULL, "ns1:UnBindSFCByScadaDTO");
	case SOAP_TYPE_PointerTons1__ToolLife:
		return soap_in_PointerTons1__ToolLife(soap, tag, NULL, "ns1:ToolLife");
	case SOAP_TYPE_PointerTons1__ToolBind:
		return soap_in_PointerTons1__ToolBind(soap, tag, NULL, "ns1:ToolBind");
	case SOAP_TYPE_PointerTons1__State:
		return soap_in_PointerTons1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_PointerTons1__RecipeVersionExamine:
		return soap_in_PointerTons1__RecipeVersionExamine(soap, tag, NULL, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		return soap_in_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeListGet:
		return soap_in_PointerTons1__RecipeListGet(soap, tag, NULL, "ns1:RecipeListGet");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu:
		return soap_in_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGet:
		return soap_in_PointerTons1__RecipeGet(soap, tag, NULL, "ns1:RecipeGet");
	case SOAP_TYPE_PointerTons1__Recipe:
		return soap_in_PointerTons1__Recipe(soap, tag, NULL, "ns1:Recipe");
	case SOAP_TYPE_PointerTons1__OutboundMore:
		return soap_in_PointerTons1__OutboundMore(soap, tag, NULL, "ns1:OutboundMore");
	case SOAP_TYPE_PointerTons1__OutboundInSFCOutputQty:
		return soap_in_PointerTons1__OutboundInSFCOutputQty(soap, tag, NULL, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_PointerTons1__OutboundInLaminating:
		return soap_in_PointerTons1__OutboundInLaminating(soap, tag, NULL, "ns1:OutboundInLaminating");
	case SOAP_TYPE_PointerTons1__Outbound:
		return soap_in_PointerTons1__Outbound(soap, tag, NULL, "ns1:Outbound");
	case SOAP_TYPE_PointerTons1__OperatorLogin:
		return soap_in_PointerTons1__OperatorLogin(soap, tag, NULL, "ns1:OperatorLogin");
	case SOAP_TYPE_PointerTons1__InboundMore:
		return soap_in_PointerTons1__InboundMore(soap, tag, NULL, "ns1:InboundMore");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		return soap_in_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu");
	case SOAP_TYPE_PointerTons1__InboundInTwoInjection:
		return soap_in_PointerTons1__InboundInTwoInjection(soap, tag, NULL, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_PointerTons1__InboundInSFCContainer:
		return soap_in_PointerTons1__InboundInSFCContainer(soap, tag, NULL, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_PointerTons1__InboundInContainer:
		return soap_in_PointerTons1__InboundInContainer(soap, tag, NULL, "ns1:InboundInContainer");
	case SOAP_TYPE_PointerTons1__Inbound:
		return soap_in_PointerTons1__Inbound(soap, tag, NULL, "ns1:Inbound");
	case SOAP_TYPE_PointerTons1__Heartbeat:
		return soap_in_PointerTons1__Heartbeat(soap, tag, NULL, "ns1:Heartbeat");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfString:
		return soap_in_PointerTons1__ApiResponseDataForScadaOfString(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfString");
	case SOAP_TYPE_PointerTons1__GenerateCellSFC:
		return soap_in_PointerTons1__GenerateCellSFC(soap, tag, NULL, "ns1:GenerateCellSFC");
	case SOAP_TYPE_PointerTons1__FillingData:
		return soap_in_PointerTons1__FillingData(soap, tag, NULL, "ns1:FillingData");
	case SOAP_TYPE_PointerTons1__FeedingDJInLaminatingByScadaDTO:
		return soap_in_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, tag, NULL, "ns1:FeedingDJInLaminatingByScadaDTO");
	case SOAP_TYPE_PointerTons1__FeedingByScadaDTO:
		return soap_in_PointerTons1__FeedingByScadaDTO(soap, tag, NULL, "ns1:FeedingByScadaDTO");
	case SOAP_TYPE_PointerTons1__ExamineExistsByScadaDTO:
		return soap_in_PointerTons1__ExamineExistsByScadaDTO(soap, tag, NULL, "ns1:ExamineExistsByScadaDTO");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		return soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, NULL, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParam:
		return soap_in_PointerTons1__EquipmentProductProcessParam(soap, tag, NULL, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_PointerTons1__EquipmentProcessParam:
		return soap_in_PointerTons1__EquipmentProcessParam(soap, tag, NULL, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_PointerTons1__ArrayOfDownReason:
		return soap_in_PointerTons1__ArrayOfDownReason(soap, tag, NULL, "ns1:ArrayOfDownReason");
	case SOAP_TYPE_PointerTons1__CCDFileUploadComplete:
		return soap_in_PointerTons1__CCDFileUploadComplete(soap, tag, NULL, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_PointerTons1__BindSFCByScadaDTO:
		return soap_in_PointerTons1__BindSFCByScadaDTO(soap, tag, NULL, "ns1:BindSFCByScadaDTO");
	case SOAP_TYPE_PointerTons1__BindContainer:
		return soap_in_PointerTons1__BindContainer(soap, tag, NULL, "ns1:BindContainer");
	case SOAP_TYPE_PointerTons1__ApiResponseForScada:
		return soap_in_PointerTons1__ApiResponseForScada(soap, tag, NULL, "ns1:ApiResponseForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfAlarm:
		return soap_in_PointerTons1__ArrayOfAlarm(soap, tag, NULL, "ns1:ArrayOfAlarm");
	case SOAP_TYPE_PointerTons1__RecipeListGetForEqu:
		return soap_in_PointerTons1__RecipeListGetForEqu(soap, tag, NULL, "ns1:RecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGetParamForEqu:
		return soap_in_PointerTons1__RecipeGetParamForEqu(soap, tag, NULL, "ns1:RecipeGetParamForEqu");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeGetParamForEqu:
		return soap_in_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, tag, NULL, "ns1:ArrayOfRecipeGetParamForEqu");
	case SOAP_TYPE_PointerTons1__RecipeParam:
		return soap_in_PointerTons1__RecipeParam(soap, tag, NULL, "ns1:RecipeParam");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, tag, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__OutboundSFC:
		return soap_in_PointerTons1__OutboundSFC(soap, tag, NULL, "ns1:OutboundSFC");
	case SOAP_TYPE_PointerTons1__ApiResponseSFCForScada:
		return soap_in_PointerTons1__ApiResponseSFCForScada(soap, tag, NULL, "ns1:ApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfParamDTO:
		return soap_in_PointerTons1__ArrayOfParamDTO(soap, tag, NULL, "ns1:ArrayOfParamDTO");
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParamSFC:
		return soap_in_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, NULL, "ns1:EquipmentProductProcessParamSFC");
	case SOAP_TYPE_PointerTons1__ParamDTO:
		return soap_in_PointerTons1__ParamDTO(soap, tag, NULL, "ns1:ParamDTO");
	case SOAP_TYPE_PointerTons1__DownReason:
		return soap_in_PointerTons1__DownReason(soap, tag, NULL, "ns1:DownReason");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__CCDFileUploadCompleteSFC:
		return soap_in_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, NULL, "ns1:CCDFileUploadCompleteSFC");
	case SOAP_TYPE_PointerTons1__BindContainerSFC:
		return soap_in_PointerTons1__BindContainerSFC(soap, tag, NULL, "ns1:BindContainerSFC");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTons1__Alarm:
		return soap_in_PointerTons1__Alarm(soap, tag, NULL, "ns1:Alarm");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:UnBindSFCByScadaDTO"))
		{	*type = SOAP_TYPE_ns1__UnBindSFCByScadaDTO;
			return soap_in_ns1__UnBindSFCByScadaDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolLife"))
		{	*type = SOAP_TYPE_ns1__ToolLife;
			return soap_in_ns1__ToolLife(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolBind"))
		{	*type = SOAP_TYPE_ns1__ToolBind;
			return soap_in_ns1__ToolBind(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:State"))
		{	*type = SOAP_TYPE_ns1__State;
			return soap_in_ns1__State(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeVersionExamine"))
		{	*type = SOAP_TYPE_ns1__RecipeVersionExamine;
			return soap_in_ns1__RecipeVersionExamine(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeListGetForEqu"))
		{	*type = SOAP_TYPE_ns1__RecipeListGetForEqu;
			return soap_in_ns1__RecipeListGetForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfRecipeListGetForEqu"))
		{	*type = SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu;
			return soap_in_ns1__ArrayOfRecipeListGetForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu"))
		{	*type = SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu;
			return soap_in_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeListGet"))
		{	*type = SOAP_TYPE_ns1__RecipeListGet;
			return soap_in_ns1__RecipeListGet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeGetParamForEqu"))
		{	*type = SOAP_TYPE_ns1__RecipeGetParamForEqu;
			return soap_in_ns1__RecipeGetParamForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfRecipeGetParamForEqu"))
		{	*type = SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu;
			return soap_in_ns1__ArrayOfRecipeGetParamForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeGetForEqu"))
		{	*type = SOAP_TYPE_ns1__RecipeGetForEqu;
			return soap_in_ns1__RecipeGetForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu"))
		{	*type = SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu;
			return soap_in_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeGet"))
		{	*type = SOAP_TYPE_ns1__RecipeGet;
			return soap_in_ns1__RecipeGet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeParam"))
		{	*type = SOAP_TYPE_ns1__RecipeParam;
			return soap_in_ns1__RecipeParam(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfRecipeParam"))
		{	*type = SOAP_TYPE_ns1__ArrayOfRecipeParam;
			return soap_in_ns1__ArrayOfRecipeParam(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Recipe"))
		{	*type = SOAP_TYPE_ns1__Recipe;
			return soap_in_ns1__Recipe(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundSFC"))
		{	*type = SOAP_TYPE_ns1__OutboundSFC;
			return soap_in_ns1__OutboundSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfOutboundSFC"))
		{	*type = SOAP_TYPE_ns1__ArrayOfOutboundSFC;
			return soap_in_ns1__ArrayOfOutboundSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundMore"))
		{	*type = SOAP_TYPE_ns1__OutboundMore;
			return soap_in_ns1__OutboundMore(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInSFCOutputQty"))
		{	*type = SOAP_TYPE_ns1__OutboundInSFCOutputQty;
			return soap_in_ns1__OutboundInSFCOutputQty(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInLaminating"))
		{	*type = SOAP_TYPE_ns1__OutboundInLaminating;
			return soap_in_ns1__OutboundInLaminating(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Outbound"))
		{	*type = SOAP_TYPE_ns1__Outbound;
			return soap_in_ns1__Outbound(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperatorLogin"))
		{	*type = SOAP_TYPE_ns1__OperatorLogin;
			return soap_in_ns1__OperatorLogin(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundMore"))
		{	*type = SOAP_TYPE_ns1__InboundMore;
			return soap_in_ns1__InboundMore(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInTwoInjectionForEqu"))
		{	*type = SOAP_TYPE_ns1__InboundInTwoInjectionForEqu;
			return soap_in_ns1__InboundInTwoInjectionForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu"))
		{	*type = SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu;
			return soap_in_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInTwoInjection"))
		{	*type = SOAP_TYPE_ns1__InboundInTwoInjection;
			return soap_in_ns1__InboundInTwoInjection(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInSFCContainer"))
		{	*type = SOAP_TYPE_ns1__InboundInSFCContainer;
			return soap_in_ns1__InboundInSFCContainer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInContainer"))
		{	*type = SOAP_TYPE_ns1__InboundInContainer;
			return soap_in_ns1__InboundInContainer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Inbound"))
		{	*type = SOAP_TYPE_ns1__Inbound;
			return soap_in_ns1__Inbound(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Heartbeat"))
		{	*type = SOAP_TYPE_ns1__Heartbeat;
			return soap_in_ns1__Heartbeat(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseDataForScadaOfString"))
		{	*type = SOAP_TYPE_ns1__ApiResponseDataForScadaOfString;
			return soap_in_ns1__ApiResponseDataForScadaOfString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenerateCellSFC"))
		{	*type = SOAP_TYPE_ns1__GenerateCellSFC;
			return soap_in_ns1__GenerateCellSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FillingData"))
		{	*type = SOAP_TYPE_ns1__FillingData;
			return soap_in_ns1__FillingData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeedingDJInLaminatingByScadaDTO"))
		{	*type = SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO;
			return soap_in_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeedingByScadaDTO"))
		{	*type = SOAP_TYPE_ns1__FeedingByScadaDTO;
			return soap_in_ns1__FeedingByScadaDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExamineExistsByScadaDTO"))
		{	*type = SOAP_TYPE_ns1__ExamineExistsByScadaDTO;
			return soap_in_ns1__ExamineExistsByScadaDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfApiResponseSFCForScada"))
		{	*type = SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada;
			return soap_in_ns1__ArrayOfApiResponseSFCForScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseSFCForScada"))
		{	*type = SOAP_TYPE_ns1__ApiResponseSFCForScada;
			return soap_in_ns1__ApiResponseSFCForScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
		{	*type = SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada;
			return soap_in_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProductProcessParamSFC"))
		{	*type = SOAP_TYPE_ns1__EquipmentProductProcessParamSFC;
			return soap_in_ns1__EquipmentProductProcessParamSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfEquipmentProductProcessParamSFC"))
		{	*type = SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC;
			return soap_in_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProductProcessParam"))
		{	*type = SOAP_TYPE_ns1__EquipmentProductProcessParam;
			return soap_in_ns1__EquipmentProductProcessParam(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ParamDTO"))
		{	*type = SOAP_TYPE_ns1__ParamDTO;
			return soap_in_ns1__ParamDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfParamDTO"))
		{	*type = SOAP_TYPE_ns1__ArrayOfParamDTO;
			return soap_in_ns1__ArrayOfParamDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProcessParam"))
		{	*type = SOAP_TYPE_ns1__EquipmentProcessParam;
			return soap_in_ns1__EquipmentProcessParam(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownReason"))
		{	*type = SOAP_TYPE_ns1__DownReason;
			return soap_in_ns1__DownReason(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDownReason"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDownReason;
			return soap_in_ns1__ArrayOfDownReason(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCDFileUploadCompleteSFC"))
		{	*type = SOAP_TYPE_ns1__CCDFileUploadCompleteSFC;
			return soap_in_ns1__CCDFileUploadCompleteSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCCDFileUploadCompleteSFC"))
		{	*type = SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC;
			return soap_in_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCDFileUploadComplete"))
		{	*type = SOAP_TYPE_ns1__CCDFileUploadComplete;
			return soap_in_ns1__CCDFileUploadComplete(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindSFCByScadaDTO"))
		{	*type = SOAP_TYPE_ns1__BindSFCByScadaDTO;
			return soap_in_ns1__BindSFCByScadaDTO(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindContainerSFC"))
		{	*type = SOAP_TYPE_ns1__BindContainerSFC;
			return soap_in_ns1__BindContainerSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfBindContainerSFC"))
		{	*type = SOAP_TYPE_ns1__ArrayOfBindContainerSFC;
			return soap_in_ns1__ArrayOfBindContainerSFC(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindContainer"))
		{	*type = SOAP_TYPE_ns1__BindContainer;
			return soap_in_ns1__BindContainer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginSoapHeader"))
		{	*type = SOAP_TYPE_ns1__LoginSoapHeader;
			return soap_in_ns1__LoginSoapHeader(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BaseApiResponseForScada"))
		{	*type = SOAP_TYPE_ns1__BaseApiResponseForScada;
			return soap_in_ns1__BaseApiResponseForScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApiResponseForScada"))
		{	*type = SOAP_TYPE_ns1__ApiResponseForScada;
			return soap_in_ns1__ApiResponseForScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BaseApiRequestByScada"))
		{	*type = SOAP_TYPE_ns1__BaseApiRequestByScada;
			return soap_in_ns1__BaseApiRequestByScada(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Alarm"))
		{	*type = SOAP_TYPE_ns1__Alarm;
			return soap_in_ns1__Alarm(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAlarm"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAlarm;
			return soap_in_ns1__ArrayOfAlarm(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	wchar_t **s;
			*type = SOAP_TYPE_wstring;
			s = soap_in_wstring(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:UnBindSFCResponse"))
		{	*type = SOAP_TYPE__ns1__UnBindSFCResponse;
			return soap_in__ns1__UnBindSFCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnBindSFC"))
		{	*type = SOAP_TYPE__ns1__UnBindSFC;
			return soap_in__ns1__UnBindSFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolLifeResponse"))
		{	*type = SOAP_TYPE__ns1__ToolLifeResponse;
			return soap_in__ns1__ToolLifeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolLife"))
		{	*type = SOAP_TYPE__ns1__ToolLife;
			return soap_in__ns1__ToolLife(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolBindResponse"))
		{	*type = SOAP_TYPE__ns1__ToolBindResponse;
			return soap_in__ns1__ToolBindResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ToolBind"))
		{	*type = SOAP_TYPE__ns1__ToolBind;
			return soap_in__ns1__ToolBind(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StateResponse"))
		{	*type = SOAP_TYPE__ns1__StateResponse;
			return soap_in__ns1__StateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:State"))
		{	*type = SOAP_TYPE__ns1__State;
			return soap_in__ns1__State(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeVersionExamineResponse"))
		{	*type = SOAP_TYPE__ns1__RecipeVersionExamineResponse;
			return soap_in__ns1__RecipeVersionExamineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeVersionExamine"))
		{	*type = SOAP_TYPE__ns1__RecipeVersionExamine;
			return soap_in__ns1__RecipeVersionExamine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecipeListResponse"))
		{	*type = SOAP_TYPE__ns1__GetRecipeListResponse;
			return soap_in__ns1__GetRecipeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecipeList"))
		{	*type = SOAP_TYPE__ns1__GetRecipeList;
			return soap_in__ns1__GetRecipeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecipeResponse"))
		{	*type = SOAP_TYPE__ns1__GetRecipeResponse;
			return soap_in__ns1__GetRecipeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecipe"))
		{	*type = SOAP_TYPE__ns1__GetRecipe;
			return soap_in__ns1__GetRecipe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipeResponse"))
		{	*type = SOAP_TYPE__ns1__RecipeResponse;
			return soap_in__ns1__RecipeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Recipe"))
		{	*type = SOAP_TYPE__ns1__Recipe;
			return soap_in__ns1__Recipe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundMoreResponse"))
		{	*type = SOAP_TYPE__ns1__OutboundMoreResponse;
			return soap_in__ns1__OutboundMoreResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundMore"))
		{	*type = SOAP_TYPE__ns1__OutboundMore;
			return soap_in__ns1__OutboundMore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInSFCOutputQtyResponse"))
		{	*type = SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse;
			return soap_in__ns1__OutboundInSFCOutputQtyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInSFCOutputQty"))
		{	*type = SOAP_TYPE__ns1__OutboundInSFCOutputQty;
			return soap_in__ns1__OutboundInSFCOutputQty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInLaminatingResponse"))
		{	*type = SOAP_TYPE__ns1__OutboundInLaminatingResponse;
			return soap_in__ns1__OutboundInLaminatingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundInLaminating"))
		{	*type = SOAP_TYPE__ns1__OutboundInLaminating;
			return soap_in__ns1__OutboundInLaminating(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutboundResponse"))
		{	*type = SOAP_TYPE__ns1__OutboundResponse;
			return soap_in__ns1__OutboundResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Outbound"))
		{	*type = SOAP_TYPE__ns1__Outbound;
			return soap_in__ns1__Outbound(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperatorLoginResponse"))
		{	*type = SOAP_TYPE__ns1__OperatorLoginResponse;
			return soap_in__ns1__OperatorLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperatorLogin"))
		{	*type = SOAP_TYPE__ns1__OperatorLogin;
			return soap_in__ns1__OperatorLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundMoreResponse"))
		{	*type = SOAP_TYPE__ns1__InboundMoreResponse;
			return soap_in__ns1__InboundMoreResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundMore"))
		{	*type = SOAP_TYPE__ns1__InboundMore;
			return soap_in__ns1__InboundMore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInTwoInjectionResponse"))
		{	*type = SOAP_TYPE__ns1__InboundInTwoInjectionResponse;
			return soap_in__ns1__InboundInTwoInjectionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInTwoInjection"))
		{	*type = SOAP_TYPE__ns1__InboundInTwoInjection;
			return soap_in__ns1__InboundInTwoInjection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInSFCContainerResponse"))
		{	*type = SOAP_TYPE__ns1__InboundInSFCContainerResponse;
			return soap_in__ns1__InboundInSFCContainerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInSFCContainer"))
		{	*type = SOAP_TYPE__ns1__InboundInSFCContainer;
			return soap_in__ns1__InboundInSFCContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInContainerResponse"))
		{	*type = SOAP_TYPE__ns1__InboundInContainerResponse;
			return soap_in__ns1__InboundInContainerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundInContainer"))
		{	*type = SOAP_TYPE__ns1__InboundInContainer;
			return soap_in__ns1__InboundInContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InboundResponse"))
		{	*type = SOAP_TYPE__ns1__InboundResponse;
			return soap_in__ns1__InboundResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Inbound"))
		{	*type = SOAP_TYPE__ns1__Inbound;
			return soap_in__ns1__Inbound(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HeartbeatResponse"))
		{	*type = SOAP_TYPE__ns1__HeartbeatResponse;
			return soap_in__ns1__HeartbeatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Heartbeat"))
		{	*type = SOAP_TYPE__ns1__Heartbeat;
			return soap_in__ns1__Heartbeat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenerateCellSFCResponse"))
		{	*type = SOAP_TYPE__ns1__GenerateCellSFCResponse;
			return soap_in__ns1__GenerateCellSFCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenerateCellSFC"))
		{	*type = SOAP_TYPE__ns1__GenerateCellSFC;
			return soap_in__ns1__GenerateCellSFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FillingDataResponse"))
		{	*type = SOAP_TYPE__ns1__FillingDataResponse;
			return soap_in__ns1__FillingDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FillingData"))
		{	*type = SOAP_TYPE__ns1__FillingData;
			return soap_in__ns1__FillingData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeedingDJInLaminatingResponse"))
		{	*type = SOAP_TYPE__ns1__FeedingDJInLaminatingResponse;
			return soap_in__ns1__FeedingDJInLaminatingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeedingDJInLaminating"))
		{	*type = SOAP_TYPE__ns1__FeedingDJInLaminating;
			return soap_in__ns1__FeedingDJInLaminating(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeedingResponse"))
		{	*type = SOAP_TYPE__ns1__FeedingResponse;
			return soap_in__ns1__FeedingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Feeding"))
		{	*type = SOAP_TYPE__ns1__Feeding;
			return soap_in__ns1__Feeding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExamineExistsResponse"))
		{	*type = SOAP_TYPE__ns1__ExamineExistsResponse;
			return soap_in__ns1__ExamineExistsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExamineExists"))
		{	*type = SOAP_TYPE__ns1__ExamineExists;
			return soap_in__ns1__ExamineExists(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProductProcessParamResponse"))
		{	*type = SOAP_TYPE__ns1__EquipmentProductProcessParamResponse;
			return soap_in__ns1__EquipmentProductProcessParamResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProductProcessParam"))
		{	*type = SOAP_TYPE__ns1__EquipmentProductProcessParam;
			return soap_in__ns1__EquipmentProductProcessParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProcessParamResponse"))
		{	*type = SOAP_TYPE__ns1__EquipmentProcessParamResponse;
			return soap_in__ns1__EquipmentProcessParamResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EquipmentProcessParam"))
		{	*type = SOAP_TYPE__ns1__EquipmentProcessParam;
			return soap_in__ns1__EquipmentProcessParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownReasonResponse"))
		{	*type = SOAP_TYPE__ns1__DownReasonResponse;
			return soap_in__ns1__DownReasonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownReason"))
		{	*type = SOAP_TYPE__ns1__DownReason;
			return soap_in__ns1__DownReason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCDFileUploadCompleteResponse"))
		{	*type = SOAP_TYPE__ns1__CCDFileUploadCompleteResponse;
			return soap_in__ns1__CCDFileUploadCompleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCDFileUploadComplete"))
		{	*type = SOAP_TYPE__ns1__CCDFileUploadComplete;
			return soap_in__ns1__CCDFileUploadComplete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindSFCResponse"))
		{	*type = SOAP_TYPE__ns1__BindSFCResponse;
			return soap_in__ns1__BindSFCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindSFC"))
		{	*type = SOAP_TYPE__ns1__BindSFC;
			return soap_in__ns1__BindSFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindContainerResponse"))
		{	*type = SOAP_TYPE__ns1__BindContainerResponse;
			return soap_in__ns1__BindContainerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindContainer"))
		{	*type = SOAP_TYPE__ns1__BindContainer;
			return soap_in__ns1__BindContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmResponse"))
		{	*type = SOAP_TYPE__ns1__AlarmResponse;
			return soap_in__ns1__AlarmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Alarm"))
		{	*type = SOAP_TYPE__ns1__Alarm;
			return soap_in__ns1__Alarm(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__UnBindSFCResponse:
		return ((_ns1__UnBindSFCResponse *)ptr)->soap_out(soap, "ns1:UnBindSFCResponse", id, "");
	case SOAP_TYPE__ns1__UnBindSFC:
		return ((_ns1__UnBindSFC *)ptr)->soap_out(soap, "ns1:UnBindSFC", id, "");
	case SOAP_TYPE__ns1__ToolLifeResponse:
		return ((_ns1__ToolLifeResponse *)ptr)->soap_out(soap, "ns1:ToolLifeResponse", id, "");
	case SOAP_TYPE__ns1__ToolLife:
		return ((_ns1__ToolLife *)ptr)->soap_out(soap, "ns1:ToolLife", id, "");
	case SOAP_TYPE__ns1__ToolBindResponse:
		return ((_ns1__ToolBindResponse *)ptr)->soap_out(soap, "ns1:ToolBindResponse", id, "");
	case SOAP_TYPE__ns1__ToolBind:
		return ((_ns1__ToolBind *)ptr)->soap_out(soap, "ns1:ToolBind", id, "");
	case SOAP_TYPE__ns1__StateResponse:
		return ((_ns1__StateResponse *)ptr)->soap_out(soap, "ns1:StateResponse", id, "");
	case SOAP_TYPE__ns1__State:
		return ((_ns1__State *)ptr)->soap_out(soap, "ns1:State", id, "");
	case SOAP_TYPE__ns1__RecipeVersionExamineResponse:
		return ((_ns1__RecipeVersionExamineResponse *)ptr)->soap_out(soap, "ns1:RecipeVersionExamineResponse", id, "");
	case SOAP_TYPE__ns1__RecipeVersionExamine:
		return ((_ns1__RecipeVersionExamine *)ptr)->soap_out(soap, "ns1:RecipeVersionExamine", id, "");
	case SOAP_TYPE__ns1__GetRecipeListResponse:
		return ((_ns1__GetRecipeListResponse *)ptr)->soap_out(soap, "ns1:GetRecipeListResponse", id, "");
	case SOAP_TYPE__ns1__GetRecipeList:
		return ((_ns1__GetRecipeList *)ptr)->soap_out(soap, "ns1:GetRecipeList", id, "");
	case SOAP_TYPE__ns1__GetRecipeResponse:
		return ((_ns1__GetRecipeResponse *)ptr)->soap_out(soap, "ns1:GetRecipeResponse", id, "");
	case SOAP_TYPE__ns1__GetRecipe:
		return ((_ns1__GetRecipe *)ptr)->soap_out(soap, "ns1:GetRecipe", id, "");
	case SOAP_TYPE__ns1__RecipeResponse:
		return ((_ns1__RecipeResponse *)ptr)->soap_out(soap, "ns1:RecipeResponse", id, "");
	case SOAP_TYPE__ns1__Recipe:
		return ((_ns1__Recipe *)ptr)->soap_out(soap, "ns1:Recipe", id, "");
	case SOAP_TYPE__ns1__OutboundMoreResponse:
		return ((_ns1__OutboundMoreResponse *)ptr)->soap_out(soap, "ns1:OutboundMoreResponse", id, "");
	case SOAP_TYPE__ns1__OutboundMore:
		return ((_ns1__OutboundMore *)ptr)->soap_out(soap, "ns1:OutboundMore", id, "");
	case SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse:
		return ((_ns1__OutboundInSFCOutputQtyResponse *)ptr)->soap_out(soap, "ns1:OutboundInSFCOutputQtyResponse", id, "");
	case SOAP_TYPE__ns1__OutboundInSFCOutputQty:
		return ((_ns1__OutboundInSFCOutputQty *)ptr)->soap_out(soap, "ns1:OutboundInSFCOutputQty", id, "");
	case SOAP_TYPE__ns1__OutboundInLaminatingResponse:
		return ((_ns1__OutboundInLaminatingResponse *)ptr)->soap_out(soap, "ns1:OutboundInLaminatingResponse", id, "");
	case SOAP_TYPE__ns1__OutboundInLaminating:
		return ((_ns1__OutboundInLaminating *)ptr)->soap_out(soap, "ns1:OutboundInLaminating", id, "");
	case SOAP_TYPE__ns1__OutboundResponse:
		return ((_ns1__OutboundResponse *)ptr)->soap_out(soap, "ns1:OutboundResponse", id, "");
	case SOAP_TYPE__ns1__Outbound:
		return ((_ns1__Outbound *)ptr)->soap_out(soap, "ns1:Outbound", id, "");
	case SOAP_TYPE__ns1__OperatorLoginResponse:
		return ((_ns1__OperatorLoginResponse *)ptr)->soap_out(soap, "ns1:OperatorLoginResponse", id, "");
	case SOAP_TYPE__ns1__OperatorLogin:
		return ((_ns1__OperatorLogin *)ptr)->soap_out(soap, "ns1:OperatorLogin", id, "");
	case SOAP_TYPE__ns1__InboundMoreResponse:
		return ((_ns1__InboundMoreResponse *)ptr)->soap_out(soap, "ns1:InboundMoreResponse", id, "");
	case SOAP_TYPE__ns1__InboundMore:
		return ((_ns1__InboundMore *)ptr)->soap_out(soap, "ns1:InboundMore", id, "");
	case SOAP_TYPE__ns1__InboundInTwoInjectionResponse:
		return ((_ns1__InboundInTwoInjectionResponse *)ptr)->soap_out(soap, "ns1:InboundInTwoInjectionResponse", id, "");
	case SOAP_TYPE__ns1__InboundInTwoInjection:
		return ((_ns1__InboundInTwoInjection *)ptr)->soap_out(soap, "ns1:InboundInTwoInjection", id, "");
	case SOAP_TYPE__ns1__InboundInSFCContainerResponse:
		return ((_ns1__InboundInSFCContainerResponse *)ptr)->soap_out(soap, "ns1:InboundInSFCContainerResponse", id, "");
	case SOAP_TYPE__ns1__InboundInSFCContainer:
		return ((_ns1__InboundInSFCContainer *)ptr)->soap_out(soap, "ns1:InboundInSFCContainer", id, "");
	case SOAP_TYPE__ns1__InboundInContainerResponse:
		return ((_ns1__InboundInContainerResponse *)ptr)->soap_out(soap, "ns1:InboundInContainerResponse", id, "");
	case SOAP_TYPE__ns1__InboundInContainer:
		return ((_ns1__InboundInContainer *)ptr)->soap_out(soap, "ns1:InboundInContainer", id, "");
	case SOAP_TYPE__ns1__InboundResponse:
		return ((_ns1__InboundResponse *)ptr)->soap_out(soap, "ns1:InboundResponse", id, "");
	case SOAP_TYPE__ns1__Inbound:
		return ((_ns1__Inbound *)ptr)->soap_out(soap, "ns1:Inbound", id, "");
	case SOAP_TYPE__ns1__HeartbeatResponse:
		return ((_ns1__HeartbeatResponse *)ptr)->soap_out(soap, "ns1:HeartbeatResponse", id, "");
	case SOAP_TYPE__ns1__Heartbeat:
		return ((_ns1__Heartbeat *)ptr)->soap_out(soap, "ns1:Heartbeat", id, "");
	case SOAP_TYPE__ns1__GenerateCellSFCResponse:
		return ((_ns1__GenerateCellSFCResponse *)ptr)->soap_out(soap, "ns1:GenerateCellSFCResponse", id, "");
	case SOAP_TYPE__ns1__GenerateCellSFC:
		return ((_ns1__GenerateCellSFC *)ptr)->soap_out(soap, "ns1:GenerateCellSFC", id, "");
	case SOAP_TYPE__ns1__FillingDataResponse:
		return ((_ns1__FillingDataResponse *)ptr)->soap_out(soap, "ns1:FillingDataResponse", id, "");
	case SOAP_TYPE__ns1__FillingData:
		return ((_ns1__FillingData *)ptr)->soap_out(soap, "ns1:FillingData", id, "");
	case SOAP_TYPE__ns1__FeedingDJInLaminatingResponse:
		return ((_ns1__FeedingDJInLaminatingResponse *)ptr)->soap_out(soap, "ns1:FeedingDJInLaminatingResponse", id, "");
	case SOAP_TYPE__ns1__FeedingDJInLaminating:
		return ((_ns1__FeedingDJInLaminating *)ptr)->soap_out(soap, "ns1:FeedingDJInLaminating", id, "");
	case SOAP_TYPE__ns1__FeedingResponse:
		return ((_ns1__FeedingResponse *)ptr)->soap_out(soap, "ns1:FeedingResponse", id, "");
	case SOAP_TYPE__ns1__Feeding:
		return ((_ns1__Feeding *)ptr)->soap_out(soap, "ns1:Feeding", id, "");
	case SOAP_TYPE__ns1__ExamineExistsResponse:
		return ((_ns1__ExamineExistsResponse *)ptr)->soap_out(soap, "ns1:ExamineExistsResponse", id, "");
	case SOAP_TYPE__ns1__ExamineExists:
		return ((_ns1__ExamineExists *)ptr)->soap_out(soap, "ns1:ExamineExists", id, "");
	case SOAP_TYPE__ns1__EquipmentProductProcessParamResponse:
		return ((_ns1__EquipmentProductProcessParamResponse *)ptr)->soap_out(soap, "ns1:EquipmentProductProcessParamResponse", id, "");
	case SOAP_TYPE__ns1__EquipmentProductProcessParam:
		return ((_ns1__EquipmentProductProcessParam *)ptr)->soap_out(soap, "ns1:EquipmentProductProcessParam", id, "");
	case SOAP_TYPE__ns1__EquipmentProcessParamResponse:
		return ((_ns1__EquipmentProcessParamResponse *)ptr)->soap_out(soap, "ns1:EquipmentProcessParamResponse", id, "");
	case SOAP_TYPE__ns1__EquipmentProcessParam:
		return ((_ns1__EquipmentProcessParam *)ptr)->soap_out(soap, "ns1:EquipmentProcessParam", id, "");
	case SOAP_TYPE__ns1__DownReasonResponse:
		return ((_ns1__DownReasonResponse *)ptr)->soap_out(soap, "ns1:DownReasonResponse", id, "");
	case SOAP_TYPE__ns1__DownReason:
		return ((_ns1__DownReason *)ptr)->soap_out(soap, "ns1:DownReason", id, "");
	case SOAP_TYPE__ns1__CCDFileUploadCompleteResponse:
		return ((_ns1__CCDFileUploadCompleteResponse *)ptr)->soap_out(soap, "ns1:CCDFileUploadCompleteResponse", id, "");
	case SOAP_TYPE__ns1__CCDFileUploadComplete:
		return ((_ns1__CCDFileUploadComplete *)ptr)->soap_out(soap, "ns1:CCDFileUploadComplete", id, "");
	case SOAP_TYPE__ns1__BindSFCResponse:
		return ((_ns1__BindSFCResponse *)ptr)->soap_out(soap, "ns1:BindSFCResponse", id, "");
	case SOAP_TYPE__ns1__BindSFC:
		return ((_ns1__BindSFC *)ptr)->soap_out(soap, "ns1:BindSFC", id, "");
	case SOAP_TYPE__ns1__BindContainerResponse:
		return ((_ns1__BindContainerResponse *)ptr)->soap_out(soap, "ns1:BindContainerResponse", id, "");
	case SOAP_TYPE__ns1__BindContainer:
		return ((_ns1__BindContainer *)ptr)->soap_out(soap, "ns1:BindContainer", id, "");
	case SOAP_TYPE__ns1__AlarmResponse:
		return ((_ns1__AlarmResponse *)ptr)->soap_out(soap, "ns1:AlarmResponse", id, "");
	case SOAP_TYPE__ns1__Alarm:
		return ((_ns1__Alarm *)ptr)->soap_out(soap, "ns1:Alarm", id, "");
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		return ((ns1__UnBindSFCByScadaDTO *)ptr)->soap_out(soap, tag, id, "ns1:UnBindSFCByScadaDTO");
	case SOAP_TYPE_ns1__ToolLife:
		return ((ns1__ToolLife *)ptr)->soap_out(soap, tag, id, "ns1:ToolLife");
	case SOAP_TYPE_ns1__ToolBind:
		return ((ns1__ToolBind *)ptr)->soap_out(soap, tag, id, "ns1:ToolBind");
	case SOAP_TYPE_ns1__State:
		return ((ns1__State *)ptr)->soap_out(soap, tag, id, "ns1:State");
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		return ((ns1__RecipeVersionExamine *)ptr)->soap_out(soap, tag, id, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		return ((ns1__RecipeListGetForEqu *)ptr)->soap_out(soap, tag, id, "ns1:RecipeListGetForEqu");
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		return ((ns1__ArrayOfRecipeListGetForEqu *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfRecipeListGetForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		return ((ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu");
	case SOAP_TYPE_ns1__RecipeListGet:
		return ((ns1__RecipeListGet *)ptr)->soap_out(soap, tag, id, "ns1:RecipeListGet");
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		return ((ns1__RecipeGetParamForEqu *)ptr)->soap_out(soap, tag, id, "ns1:RecipeGetParamForEqu");
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		return ((ns1__ArrayOfRecipeGetParamForEqu *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfRecipeGetParamForEqu");
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		return ((ns1__RecipeGetForEqu *)ptr)->soap_out(soap, tag, id, "ns1:RecipeGetForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		return ((ns1__ApiResponseDataForScadaOfRecipeGetForEqu *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu");
	case SOAP_TYPE_ns1__RecipeGet:
		return ((ns1__RecipeGet *)ptr)->soap_out(soap, tag, id, "ns1:RecipeGet");
	case SOAP_TYPE_ns1__RecipeParam:
		return ((ns1__RecipeParam *)ptr)->soap_out(soap, tag, id, "ns1:RecipeParam");
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		return ((ns1__ArrayOfRecipeParam *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfRecipeParam");
	case SOAP_TYPE_ns1__Recipe:
		return ((ns1__Recipe *)ptr)->soap_out(soap, tag, id, "ns1:Recipe");
	case SOAP_TYPE_ns1__OutboundSFC:
		return ((ns1__OutboundSFC *)ptr)->soap_out(soap, tag, id, "ns1:OutboundSFC");
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		return ((ns1__ArrayOfOutboundSFC *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfOutboundSFC");
	case SOAP_TYPE_ns1__OutboundMore:
		return ((ns1__OutboundMore *)ptr)->soap_out(soap, tag, id, "ns1:OutboundMore");
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		return ((ns1__OutboundInSFCOutputQty *)ptr)->soap_out(soap, tag, id, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_ns1__OutboundInLaminating:
		return ((ns1__OutboundInLaminating *)ptr)->soap_out(soap, tag, id, "ns1:OutboundInLaminating");
	case SOAP_TYPE_ns1__Outbound:
		return ((ns1__Outbound *)ptr)->soap_out(soap, tag, id, "ns1:Outbound");
	case SOAP_TYPE_ns1__OperatorLogin:
		return ((ns1__OperatorLogin *)ptr)->soap_out(soap, tag, id, "ns1:OperatorLogin");
	case SOAP_TYPE_ns1__InboundMore:
		return ((ns1__InboundMore *)ptr)->soap_out(soap, tag, id, "ns1:InboundMore");
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		return ((ns1__InboundInTwoInjectionForEqu *)ptr)->soap_out(soap, tag, id, "ns1:InboundInTwoInjectionForEqu");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		return ((ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu");
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		return ((ns1__InboundInTwoInjection *)ptr)->soap_out(soap, tag, id, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		return ((ns1__InboundInSFCContainer *)ptr)->soap_out(soap, tag, id, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_ns1__InboundInContainer:
		return ((ns1__InboundInContainer *)ptr)->soap_out(soap, tag, id, "ns1:InboundInContainer");
	case SOAP_TYPE_ns1__Inbound:
		return ((ns1__Inbound *)ptr)->soap_out(soap, tag, id, "ns1:Inbound");
	case SOAP_TYPE_ns1__Heartbeat:
		return ((ns1__Heartbeat *)ptr)->soap_out(soap, tag, id, "ns1:Heartbeat");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		return ((ns1__ApiResponseDataForScadaOfString *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseDataForScadaOfString");
	case SOAP_TYPE_ns1__GenerateCellSFC:
		return ((ns1__GenerateCellSFC *)ptr)->soap_out(soap, tag, id, "ns1:GenerateCellSFC");
	case SOAP_TYPE_ns1__FillingData:
		return ((ns1__FillingData *)ptr)->soap_out(soap, tag, id, "ns1:FillingData");
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		return ((ns1__FeedingDJInLaminatingByScadaDTO *)ptr)->soap_out(soap, tag, id, "ns1:FeedingDJInLaminatingByScadaDTO");
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		return ((ns1__FeedingByScadaDTO *)ptr)->soap_out(soap, tag, id, "ns1:FeedingByScadaDTO");
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		return ((ns1__ExamineExistsByScadaDTO *)ptr)->soap_out(soap, tag, id, "ns1:ExamineExistsByScadaDTO");
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		return ((ns1__ArrayOfApiResponseSFCForScada *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfApiResponseSFCForScada");
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		return ((ns1__ApiResponseSFCForScada *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseSFCForScada");
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		return ((ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada");
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		return ((ns1__EquipmentProductProcessParamSFC *)ptr)->soap_out(soap, tag, id, "ns1:EquipmentProductProcessParamSFC");
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		return ((ns1__ArrayOfEquipmentProductProcessParamSFC *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfEquipmentProductProcessParamSFC");
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		return ((ns1__EquipmentProductProcessParam *)ptr)->soap_out(soap, tag, id, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_ns1__ParamDTO:
		return ((ns1__ParamDTO *)ptr)->soap_out(soap, tag, id, "ns1:ParamDTO");
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		return ((ns1__ArrayOfParamDTO *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfParamDTO");
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		return ((ns1__EquipmentProcessParam *)ptr)->soap_out(soap, tag, id, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_ns1__DownReason:
		return ((ns1__DownReason *)ptr)->soap_out(soap, tag, id, "ns1:DownReason");
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		return ((ns1__ArrayOfDownReason *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDownReason");
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		return ((ns1__CCDFileUploadCompleteSFC *)ptr)->soap_out(soap, tag, id, "ns1:CCDFileUploadCompleteSFC");
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		return ((ns1__ArrayOfCCDFileUploadCompleteSFC *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCCDFileUploadCompleteSFC");
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		return ((ns1__CCDFileUploadComplete *)ptr)->soap_out(soap, tag, id, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		return ((ns1__BindSFCByScadaDTO *)ptr)->soap_out(soap, tag, id, "ns1:BindSFCByScadaDTO");
	case SOAP_TYPE_ns1__BindContainerSFC:
		return ((ns1__BindContainerSFC *)ptr)->soap_out(soap, tag, id, "ns1:BindContainerSFC");
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		return ((ns1__ArrayOfBindContainerSFC *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfBindContainerSFC");
	case SOAP_TYPE_ns1__BindContainer:
		return ((ns1__BindContainer *)ptr)->soap_out(soap, tag, id, "ns1:BindContainer");
	case SOAP_TYPE_ns1__LoginSoapHeader:
		return ((ns1__LoginSoapHeader *)ptr)->soap_out(soap, tag, id, "ns1:LoginSoapHeader");
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		return ((ns1__BaseApiResponseForScada *)ptr)->soap_out(soap, tag, id, "ns1:BaseApiResponseForScada");
	case SOAP_TYPE_ns1__ApiResponseForScada:
		return ((ns1__ApiResponseForScada *)ptr)->soap_out(soap, tag, id, "ns1:ApiResponseForScada");
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		return ((ns1__BaseApiRequestByScada *)ptr)->soap_out(soap, tag, id, "ns1:BaseApiRequestByScada");
	case SOAP_TYPE_ns1__Alarm:
		return ((ns1__Alarm *)ptr)->soap_out(soap, tag, id, "ns1:Alarm");
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		return ((ns1__ArrayOfAlarm *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAlarm");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::wstring *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__UnBindSFC:
		return soap_out_PointerTo_ns1__UnBindSFC(soap, tag, id, (_ns1__UnBindSFC *const*)ptr, "ns1:UnBindSFC");
	case SOAP_TYPE_PointerTo_ns1__ToolLife:
		return soap_out_PointerTo_ns1__ToolLife(soap, tag, id, (_ns1__ToolLife *const*)ptr, "ns1:ToolLife");
	case SOAP_TYPE_PointerTo_ns1__ToolBind:
		return soap_out_PointerTo_ns1__ToolBind(soap, tag, id, (_ns1__ToolBind *const*)ptr, "ns1:ToolBind");
	case SOAP_TYPE_PointerTo_ns1__State:
		return soap_out_PointerTo_ns1__State(soap, tag, id, (_ns1__State *const*)ptr, "ns1:State");
	case SOAP_TYPE_PointerTo_ns1__RecipeVersionExamine:
		return soap_out_PointerTo_ns1__RecipeVersionExamine(soap, tag, id, (_ns1__RecipeVersionExamine *const*)ptr, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_PointerTo_ns1__GetRecipeList:
		return soap_out_PointerTo_ns1__GetRecipeList(soap, tag, id, (_ns1__GetRecipeList *const*)ptr, "ns1:GetRecipeList");
	case SOAP_TYPE_PointerTo_ns1__GetRecipe:
		return soap_out_PointerTo_ns1__GetRecipe(soap, tag, id, (_ns1__GetRecipe *const*)ptr, "ns1:GetRecipe");
	case SOAP_TYPE_PointerTo_ns1__Recipe:
		return soap_out_PointerTo_ns1__Recipe(soap, tag, id, (_ns1__Recipe *const*)ptr, "ns1:Recipe");
	case SOAP_TYPE_PointerTo_ns1__OutboundMore:
		return soap_out_PointerTo_ns1__OutboundMore(soap, tag, id, (_ns1__OutboundMore *const*)ptr, "ns1:OutboundMore");
	case SOAP_TYPE_PointerTo_ns1__OutboundInSFCOutputQty:
		return soap_out_PointerTo_ns1__OutboundInSFCOutputQty(soap, tag, id, (_ns1__OutboundInSFCOutputQty *const*)ptr, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_PointerTo_ns1__OutboundInLaminating:
		return soap_out_PointerTo_ns1__OutboundInLaminating(soap, tag, id, (_ns1__OutboundInLaminating *const*)ptr, "ns1:OutboundInLaminating");
	case SOAP_TYPE_PointerTo_ns1__Outbound:
		return soap_out_PointerTo_ns1__Outbound(soap, tag, id, (_ns1__Outbound *const*)ptr, "ns1:Outbound");
	case SOAP_TYPE_PointerTo_ns1__OperatorLogin:
		return soap_out_PointerTo_ns1__OperatorLogin(soap, tag, id, (_ns1__OperatorLogin *const*)ptr, "ns1:OperatorLogin");
	case SOAP_TYPE_PointerTo_ns1__InboundMore:
		return soap_out_PointerTo_ns1__InboundMore(soap, tag, id, (_ns1__InboundMore *const*)ptr, "ns1:InboundMore");
	case SOAP_TYPE_PointerTo_ns1__InboundInTwoInjection:
		return soap_out_PointerTo_ns1__InboundInTwoInjection(soap, tag, id, (_ns1__InboundInTwoInjection *const*)ptr, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_PointerTo_ns1__InboundInSFCContainer:
		return soap_out_PointerTo_ns1__InboundInSFCContainer(soap, tag, id, (_ns1__InboundInSFCContainer *const*)ptr, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_PointerTo_ns1__InboundInContainer:
		return soap_out_PointerTo_ns1__InboundInContainer(soap, tag, id, (_ns1__InboundInContainer *const*)ptr, "ns1:InboundInContainer");
	case SOAP_TYPE_PointerTo_ns1__Inbound:
		return soap_out_PointerTo_ns1__Inbound(soap, tag, id, (_ns1__Inbound *const*)ptr, "ns1:Inbound");
	case SOAP_TYPE_PointerTo_ns1__Heartbeat:
		return soap_out_PointerTo_ns1__Heartbeat(soap, tag, id, (_ns1__Heartbeat *const*)ptr, "ns1:Heartbeat");
	case SOAP_TYPE_PointerTo_ns1__GenerateCellSFC:
		return soap_out_PointerTo_ns1__GenerateCellSFC(soap, tag, id, (_ns1__GenerateCellSFC *const*)ptr, "ns1:GenerateCellSFC");
	case SOAP_TYPE_PointerTo_ns1__FillingData:
		return soap_out_PointerTo_ns1__FillingData(soap, tag, id, (_ns1__FillingData *const*)ptr, "ns1:FillingData");
	case SOAP_TYPE_PointerTo_ns1__FeedingDJInLaminating:
		return soap_out_PointerTo_ns1__FeedingDJInLaminating(soap, tag, id, (_ns1__FeedingDJInLaminating *const*)ptr, "ns1:FeedingDJInLaminating");
	case SOAP_TYPE_PointerTo_ns1__Feeding:
		return soap_out_PointerTo_ns1__Feeding(soap, tag, id, (_ns1__Feeding *const*)ptr, "ns1:Feeding");
	case SOAP_TYPE_PointerTo_ns1__ExamineExists:
		return soap_out_PointerTo_ns1__ExamineExists(soap, tag, id, (_ns1__ExamineExists *const*)ptr, "ns1:ExamineExists");
	case SOAP_TYPE_PointerTo_ns1__EquipmentProductProcessParam:
		return soap_out_PointerTo_ns1__EquipmentProductProcessParam(soap, tag, id, (_ns1__EquipmentProductProcessParam *const*)ptr, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_PointerTo_ns1__EquipmentProcessParam:
		return soap_out_PointerTo_ns1__EquipmentProcessParam(soap, tag, id, (_ns1__EquipmentProcessParam *const*)ptr, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_PointerTo_ns1__DownReason:
		return soap_out_PointerTo_ns1__DownReason(soap, tag, id, (_ns1__DownReason *const*)ptr, "ns1:DownReason");
	case SOAP_TYPE_PointerTo_ns1__CCDFileUploadComplete:
		return soap_out_PointerTo_ns1__CCDFileUploadComplete(soap, tag, id, (_ns1__CCDFileUploadComplete *const*)ptr, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_PointerTo_ns1__BindSFC:
		return soap_out_PointerTo_ns1__BindSFC(soap, tag, id, (_ns1__BindSFC *const*)ptr, "ns1:BindSFC");
	case SOAP_TYPE_PointerTo_ns1__BindContainer:
		return soap_out_PointerTo_ns1__BindContainer(soap, tag, id, (_ns1__BindContainer *const*)ptr, "ns1:BindContainer");
	case SOAP_TYPE_PointerTo_ns1__Alarm:
		return soap_out_PointerTo_ns1__Alarm(soap, tag, id, (_ns1__Alarm *const*)ptr, "ns1:Alarm");
	case SOAP_TYPE_PointerTons1__LoginSoapHeader:
		return soap_out_PointerTons1__LoginSoapHeader(soap, tag, id, (ns1__LoginSoapHeader *const*)ptr, "ns1:LoginSoapHeader");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeListGetForEqu:
		return soap_out_PointerTons1__ArrayOfRecipeListGetForEqu(soap, tag, id, (ns1__ArrayOfRecipeListGetForEqu *const*)ptr, "ns1:ArrayOfRecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGetForEqu:
		return soap_out_PointerTons1__RecipeGetForEqu(soap, tag, id, (ns1__RecipeGetForEqu *const*)ptr, "ns1:RecipeGetForEqu");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeParam:
		return soap_out_PointerTons1__ArrayOfRecipeParam(soap, tag, id, (ns1__ArrayOfRecipeParam *const*)ptr, "ns1:ArrayOfRecipeParam");
	case SOAP_TYPE_PointerTons1__ArrayOfOutboundSFC:
		return soap_out_PointerTons1__ArrayOfOutboundSFC(soap, tag, id, (ns1__ArrayOfOutboundSFC *const*)ptr, "ns1:ArrayOfOutboundSFC");
	case SOAP_TYPE_PointerTons1__InboundInTwoInjectionForEqu:
		return soap_out_PointerTons1__InboundInTwoInjectionForEqu(soap, tag, id, (ns1__InboundInTwoInjectionForEqu *const*)ptr, "ns1:InboundInTwoInjectionForEqu");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::wstring *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons1__ArrayOfApiResponseSFCForScada:
		return soap_out_PointerTons1__ArrayOfApiResponseSFCForScada(soap, tag, id, (ns1__ArrayOfApiResponseSFCForScada *const*)ptr, "ns1:ArrayOfApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfEquipmentProductProcessParamSFC:
		return soap_out_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, id, (ns1__ArrayOfEquipmentProductProcessParamSFC *const*)ptr, "ns1:ArrayOfEquipmentProductProcessParamSFC");
	case SOAP_TYPE_PointerTons1__ArrayOfCCDFileUploadCompleteSFC:
		return soap_out_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, id, (ns1__ArrayOfCCDFileUploadCompleteSFC *const*)ptr, "ns1:ArrayOfCCDFileUploadCompleteSFC");
	case SOAP_TYPE_PointerTons1__ArrayOfBindContainerSFC:
		return soap_out_PointerTons1__ArrayOfBindContainerSFC(soap, tag, id, (ns1__ArrayOfBindContainerSFC *const*)ptr, "ns1:ArrayOfBindContainerSFC");
	case SOAP_TYPE_PointerTons1__UnBindSFCByScadaDTO:
		return soap_out_PointerTons1__UnBindSFCByScadaDTO(soap, tag, id, (ns1__UnBindSFCByScadaDTO *const*)ptr, "ns1:UnBindSFCByScadaDTO");
	case SOAP_TYPE_PointerTons1__ToolLife:
		return soap_out_PointerTons1__ToolLife(soap, tag, id, (ns1__ToolLife *const*)ptr, "ns1:ToolLife");
	case SOAP_TYPE_PointerTons1__ToolBind:
		return soap_out_PointerTons1__ToolBind(soap, tag, id, (ns1__ToolBind *const*)ptr, "ns1:ToolBind");
	case SOAP_TYPE_PointerTons1__State:
		return soap_out_PointerTons1__State(soap, tag, id, (ns1__State *const*)ptr, "ns1:State");
	case SOAP_TYPE_PointerTons1__RecipeVersionExamine:
		return soap_out_PointerTons1__RecipeVersionExamine(soap, tag, id, (ns1__RecipeVersionExamine *const*)ptr, "ns1:RecipeVersionExamine");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		return soap_out_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, id, (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *const*)ptr, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeListGet:
		return soap_out_PointerTons1__RecipeListGet(soap, tag, id, (ns1__RecipeListGet *const*)ptr, "ns1:RecipeListGet");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu:
		return soap_out_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, id, (ns1__ApiResponseDataForScadaOfRecipeGetForEqu *const*)ptr, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGet:
		return soap_out_PointerTons1__RecipeGet(soap, tag, id, (ns1__RecipeGet *const*)ptr, "ns1:RecipeGet");
	case SOAP_TYPE_PointerTons1__Recipe:
		return soap_out_PointerTons1__Recipe(soap, tag, id, (ns1__Recipe *const*)ptr, "ns1:Recipe");
	case SOAP_TYPE_PointerTons1__OutboundMore:
		return soap_out_PointerTons1__OutboundMore(soap, tag, id, (ns1__OutboundMore *const*)ptr, "ns1:OutboundMore");
	case SOAP_TYPE_PointerTons1__OutboundInSFCOutputQty:
		return soap_out_PointerTons1__OutboundInSFCOutputQty(soap, tag, id, (ns1__OutboundInSFCOutputQty *const*)ptr, "ns1:OutboundInSFCOutputQty");
	case SOAP_TYPE_PointerTons1__OutboundInLaminating:
		return soap_out_PointerTons1__OutboundInLaminating(soap, tag, id, (ns1__OutboundInLaminating *const*)ptr, "ns1:OutboundInLaminating");
	case SOAP_TYPE_PointerTons1__Outbound:
		return soap_out_PointerTons1__Outbound(soap, tag, id, (ns1__Outbound *const*)ptr, "ns1:Outbound");
	case SOAP_TYPE_PointerTons1__OperatorLogin:
		return soap_out_PointerTons1__OperatorLogin(soap, tag, id, (ns1__OperatorLogin *const*)ptr, "ns1:OperatorLogin");
	case SOAP_TYPE_PointerTons1__InboundMore:
		return soap_out_PointerTons1__InboundMore(soap, tag, id, (ns1__InboundMore *const*)ptr, "ns1:InboundMore");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		return soap_out_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, id, (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *const*)ptr, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu");
	case SOAP_TYPE_PointerTons1__InboundInTwoInjection:
		return soap_out_PointerTons1__InboundInTwoInjection(soap, tag, id, (ns1__InboundInTwoInjection *const*)ptr, "ns1:InboundInTwoInjection");
	case SOAP_TYPE_PointerTons1__InboundInSFCContainer:
		return soap_out_PointerTons1__InboundInSFCContainer(soap, tag, id, (ns1__InboundInSFCContainer *const*)ptr, "ns1:InboundInSFCContainer");
	case SOAP_TYPE_PointerTons1__InboundInContainer:
		return soap_out_PointerTons1__InboundInContainer(soap, tag, id, (ns1__InboundInContainer *const*)ptr, "ns1:InboundInContainer");
	case SOAP_TYPE_PointerTons1__Inbound:
		return soap_out_PointerTons1__Inbound(soap, tag, id, (ns1__Inbound *const*)ptr, "ns1:Inbound");
	case SOAP_TYPE_PointerTons1__Heartbeat:
		return soap_out_PointerTons1__Heartbeat(soap, tag, id, (ns1__Heartbeat *const*)ptr, "ns1:Heartbeat");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfString:
		return soap_out_PointerTons1__ApiResponseDataForScadaOfString(soap, tag, id, (ns1__ApiResponseDataForScadaOfString *const*)ptr, "ns1:ApiResponseDataForScadaOfString");
	case SOAP_TYPE_PointerTons1__GenerateCellSFC:
		return soap_out_PointerTons1__GenerateCellSFC(soap, tag, id, (ns1__GenerateCellSFC *const*)ptr, "ns1:GenerateCellSFC");
	case SOAP_TYPE_PointerTons1__FillingData:
		return soap_out_PointerTons1__FillingData(soap, tag, id, (ns1__FillingData *const*)ptr, "ns1:FillingData");
	case SOAP_TYPE_PointerTons1__FeedingDJInLaminatingByScadaDTO:
		return soap_out_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, tag, id, (ns1__FeedingDJInLaminatingByScadaDTO *const*)ptr, "ns1:FeedingDJInLaminatingByScadaDTO");
	case SOAP_TYPE_PointerTons1__FeedingByScadaDTO:
		return soap_out_PointerTons1__FeedingByScadaDTO(soap, tag, id, (ns1__FeedingByScadaDTO *const*)ptr, "ns1:FeedingByScadaDTO");
	case SOAP_TYPE_PointerTons1__ExamineExistsByScadaDTO:
		return soap_out_PointerTons1__ExamineExistsByScadaDTO(soap, tag, id, (ns1__ExamineExistsByScadaDTO *const*)ptr, "ns1:ExamineExistsByScadaDTO");
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		return soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, id, (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *const*)ptr, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParam:
		return soap_out_PointerTons1__EquipmentProductProcessParam(soap, tag, id, (ns1__EquipmentProductProcessParam *const*)ptr, "ns1:EquipmentProductProcessParam");
	case SOAP_TYPE_PointerTons1__EquipmentProcessParam:
		return soap_out_PointerTons1__EquipmentProcessParam(soap, tag, id, (ns1__EquipmentProcessParam *const*)ptr, "ns1:EquipmentProcessParam");
	case SOAP_TYPE_PointerTons1__ArrayOfDownReason:
		return soap_out_PointerTons1__ArrayOfDownReason(soap, tag, id, (ns1__ArrayOfDownReason *const*)ptr, "ns1:ArrayOfDownReason");
	case SOAP_TYPE_PointerTons1__CCDFileUploadComplete:
		return soap_out_PointerTons1__CCDFileUploadComplete(soap, tag, id, (ns1__CCDFileUploadComplete *const*)ptr, "ns1:CCDFileUploadComplete");
	case SOAP_TYPE_PointerTons1__BindSFCByScadaDTO:
		return soap_out_PointerTons1__BindSFCByScadaDTO(soap, tag, id, (ns1__BindSFCByScadaDTO *const*)ptr, "ns1:BindSFCByScadaDTO");
	case SOAP_TYPE_PointerTons1__BindContainer:
		return soap_out_PointerTons1__BindContainer(soap, tag, id, (ns1__BindContainer *const*)ptr, "ns1:BindContainer");
	case SOAP_TYPE_PointerTons1__ApiResponseForScada:
		return soap_out_PointerTons1__ApiResponseForScada(soap, tag, id, (ns1__ApiResponseForScada *const*)ptr, "ns1:ApiResponseForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfAlarm:
		return soap_out_PointerTons1__ArrayOfAlarm(soap, tag, id, (ns1__ArrayOfAlarm *const*)ptr, "ns1:ArrayOfAlarm");
	case SOAP_TYPE_PointerTons1__RecipeListGetForEqu:
		return soap_out_PointerTons1__RecipeListGetForEqu(soap, tag, id, (ns1__RecipeListGetForEqu *const*)ptr, "ns1:RecipeListGetForEqu");
	case SOAP_TYPE_PointerTons1__RecipeGetParamForEqu:
		return soap_out_PointerTons1__RecipeGetParamForEqu(soap, tag, id, (ns1__RecipeGetParamForEqu *const*)ptr, "ns1:RecipeGetParamForEqu");
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeGetParamForEqu:
		return soap_out_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, tag, id, (ns1__ArrayOfRecipeGetParamForEqu *const*)ptr, "ns1:ArrayOfRecipeGetParamForEqu");
	case SOAP_TYPE_PointerTons1__RecipeParam:
		return soap_out_PointerTons1__RecipeParam(soap, tag, id, (ns1__RecipeParam *const*)ptr, "ns1:RecipeParam");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__OutboundSFC:
		return soap_out_PointerTons1__OutboundSFC(soap, tag, id, (ns1__OutboundSFC *const*)ptr, "ns1:OutboundSFC");
	case SOAP_TYPE_PointerTons1__ApiResponseSFCForScada:
		return soap_out_PointerTons1__ApiResponseSFCForScada(soap, tag, id, (ns1__ApiResponseSFCForScada *const*)ptr, "ns1:ApiResponseSFCForScada");
	case SOAP_TYPE_PointerTons1__ArrayOfParamDTO:
		return soap_out_PointerTons1__ArrayOfParamDTO(soap, tag, id, (ns1__ArrayOfParamDTO *const*)ptr, "ns1:ArrayOfParamDTO");
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParamSFC:
		return soap_out_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, id, (ns1__EquipmentProductProcessParamSFC *const*)ptr, "ns1:EquipmentProductProcessParamSFC");
	case SOAP_TYPE_PointerTons1__ParamDTO:
		return soap_out_PointerTons1__ParamDTO(soap, tag, id, (ns1__ParamDTO *const*)ptr, "ns1:ParamDTO");
	case SOAP_TYPE_PointerTons1__DownReason:
		return soap_out_PointerTons1__DownReason(soap, tag, id, (ns1__DownReason *const*)ptr, "ns1:DownReason");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__CCDFileUploadCompleteSFC:
		return soap_out_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, id, (ns1__CCDFileUploadCompleteSFC *const*)ptr, "ns1:CCDFileUploadCompleteSFC");
	case SOAP_TYPE_PointerTons1__BindContainerSFC:
		return soap_out_PointerTons1__BindContainerSFC(soap, tag, id, (ns1__BindContainerSFC *const*)ptr, "ns1:BindContainerSFC");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__Alarm:
		return soap_out_PointerTons1__Alarm(soap, tag, id, (ns1__Alarm *const*)ptr, "ns1:Alarm");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__UnBindSFCResponse:
		((_ns1__UnBindSFCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnBindSFC:
		((_ns1__UnBindSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ToolLifeResponse:
		((_ns1__ToolLifeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ToolLife:
		((_ns1__ToolLife *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ToolBindResponse:
		((_ns1__ToolBindResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ToolBind:
		((_ns1__ToolBind *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StateResponse:
		((_ns1__StateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__State:
		((_ns1__State *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamineResponse:
		((_ns1__RecipeVersionExamineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamine:
		((_ns1__RecipeVersionExamine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecipeListResponse:
		((_ns1__GetRecipeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecipeList:
		((_ns1__GetRecipeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecipeResponse:
		((_ns1__GetRecipeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecipe:
		((_ns1__GetRecipe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RecipeResponse:
		((_ns1__RecipeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Recipe:
		((_ns1__Recipe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundMoreResponse:
		((_ns1__OutboundMoreResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundMore:
		((_ns1__OutboundMore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse:
		((_ns1__OutboundInSFCOutputQtyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQty:
		((_ns1__OutboundInSFCOutputQty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundInLaminatingResponse:
		((_ns1__OutboundInLaminatingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundInLaminating:
		((_ns1__OutboundInLaminating *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutboundResponse:
		((_ns1__OutboundResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Outbound:
		((_ns1__Outbound *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OperatorLoginResponse:
		((_ns1__OperatorLoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OperatorLogin:
		((_ns1__OperatorLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundMoreResponse:
		((_ns1__InboundMoreResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundMore:
		((_ns1__InboundMore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjectionResponse:
		((_ns1__InboundInTwoInjectionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjection:
		((_ns1__InboundInTwoInjection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainerResponse:
		((_ns1__InboundInSFCContainerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainer:
		((_ns1__InboundInSFCContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInContainerResponse:
		((_ns1__InboundInContainerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundInContainer:
		((_ns1__InboundInContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InboundResponse:
		((_ns1__InboundResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Inbound:
		((_ns1__Inbound *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HeartbeatResponse:
		((_ns1__HeartbeatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Heartbeat:
		((_ns1__Heartbeat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GenerateCellSFCResponse:
		((_ns1__GenerateCellSFCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GenerateCellSFC:
		((_ns1__GenerateCellSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FillingDataResponse:
		((_ns1__FillingDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FillingData:
		((_ns1__FillingData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminatingResponse:
		((_ns1__FeedingDJInLaminatingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminating:
		((_ns1__FeedingDJInLaminating *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FeedingResponse:
		((_ns1__FeedingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Feeding:
		((_ns1__Feeding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExamineExistsResponse:
		((_ns1__ExamineExistsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExamineExists:
		((_ns1__ExamineExists *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParamResponse:
		((_ns1__EquipmentProductProcessParamResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParam:
		((_ns1__EquipmentProductProcessParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParamResponse:
		((_ns1__EquipmentProcessParamResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParam:
		((_ns1__EquipmentProcessParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownReasonResponse:
		((_ns1__DownReasonResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownReason:
		((_ns1__DownReason *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CCDFileUploadCompleteResponse:
		((_ns1__CCDFileUploadCompleteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CCDFileUploadComplete:
		((_ns1__CCDFileUploadComplete *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindSFCResponse:
		((_ns1__BindSFCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindSFC:
		((_ns1__BindSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindContainerResponse:
		((_ns1__BindContainerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindContainer:
		((_ns1__BindContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlarmResponse:
		((_ns1__AlarmResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Alarm:
		((_ns1__Alarm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		((ns1__UnBindSFCByScadaDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ToolLife:
		((ns1__ToolLife *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ToolBind:
		((ns1__ToolBind *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__State:
		((ns1__State *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		((ns1__RecipeVersionExamine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		((ns1__RecipeListGetForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		((ns1__ArrayOfRecipeListGetForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		((ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeListGet:
		((ns1__RecipeListGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		((ns1__RecipeGetParamForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		((ns1__ArrayOfRecipeGetParamForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		((ns1__RecipeGetForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		((ns1__ApiResponseDataForScadaOfRecipeGetForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeGet:
		((ns1__RecipeGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RecipeParam:
		((ns1__RecipeParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		((ns1__ArrayOfRecipeParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Recipe:
		((ns1__Recipe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OutboundSFC:
		((ns1__OutboundSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		((ns1__ArrayOfOutboundSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OutboundMore:
		((ns1__OutboundMore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		((ns1__OutboundInSFCOutputQty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OutboundInLaminating:
		((ns1__OutboundInLaminating *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Outbound:
		((ns1__Outbound *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OperatorLogin:
		((ns1__OperatorLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InboundMore:
		((ns1__InboundMore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		((ns1__InboundInTwoInjectionForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		((ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		((ns1__InboundInTwoInjection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		((ns1__InboundInSFCContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InboundInContainer:
		((ns1__InboundInContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Inbound:
		((ns1__Inbound *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Heartbeat:
		((ns1__Heartbeat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		((ns1__ApiResponseDataForScadaOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenerateCellSFC:
		((ns1__GenerateCellSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FillingData:
		((ns1__FillingData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		((ns1__FeedingDJInLaminatingByScadaDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		((ns1__FeedingByScadaDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		((ns1__ExamineExistsByScadaDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		((ns1__ArrayOfApiResponseSFCForScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		((ns1__ApiResponseSFCForScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		((ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		((ns1__EquipmentProductProcessParamSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		((ns1__ArrayOfEquipmentProductProcessParamSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		((ns1__EquipmentProductProcessParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ParamDTO:
		((ns1__ParamDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		((ns1__ArrayOfParamDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		((ns1__EquipmentProcessParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DownReason:
		((ns1__DownReason *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		((ns1__ArrayOfDownReason *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		((ns1__CCDFileUploadCompleteSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		((ns1__ArrayOfCCDFileUploadCompleteSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		((ns1__CCDFileUploadComplete *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		((ns1__BindSFCByScadaDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BindContainerSFC:
		((ns1__BindContainerSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		((ns1__ArrayOfBindContainerSFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BindContainer:
		((ns1__BindContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LoginSoapHeader:
		((ns1__LoginSoapHeader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		((ns1__BaseApiResponseForScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApiResponseForScada:
		((ns1__ApiResponseForScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		((ns1__BaseApiRequestByScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Alarm:
		((ns1__Alarm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		((ns1__ArrayOfAlarm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE___ns1__UnBindSFC_:
		soap_serialize___ns1__UnBindSFC_(soap, (const struct __ns1__UnBindSFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UnBindSFC:
		soap_serialize___ns1__UnBindSFC(soap, (const struct __ns1__UnBindSFC *)ptr);
		break;
	case SOAP_TYPE___ns1__ToolLife_:
		soap_serialize___ns1__ToolLife_(soap, (const struct __ns1__ToolLife_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ToolLife:
		soap_serialize___ns1__ToolLife(soap, (const struct __ns1__ToolLife *)ptr);
		break;
	case SOAP_TYPE___ns1__ToolBind_:
		soap_serialize___ns1__ToolBind_(soap, (const struct __ns1__ToolBind_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ToolBind:
		soap_serialize___ns1__ToolBind(soap, (const struct __ns1__ToolBind *)ptr);
		break;
	case SOAP_TYPE___ns1__State_:
		soap_serialize___ns1__State_(soap, (const struct __ns1__State_ *)ptr);
		break;
	case SOAP_TYPE___ns1__State:
		soap_serialize___ns1__State(soap, (const struct __ns1__State *)ptr);
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine_:
		soap_serialize___ns1__RecipeVersionExamine_(soap, (const struct __ns1__RecipeVersionExamine_ *)ptr);
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine:
		soap_serialize___ns1__RecipeVersionExamine(soap, (const struct __ns1__RecipeVersionExamine *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRecipeList_:
		soap_serialize___ns1__GetRecipeList_(soap, (const struct __ns1__GetRecipeList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRecipeList:
		soap_serialize___ns1__GetRecipeList(soap, (const struct __ns1__GetRecipeList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRecipe_:
		soap_serialize___ns1__GetRecipe_(soap, (const struct __ns1__GetRecipe_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRecipe:
		soap_serialize___ns1__GetRecipe(soap, (const struct __ns1__GetRecipe *)ptr);
		break;
	case SOAP_TYPE___ns1__Recipe_:
		soap_serialize___ns1__Recipe_(soap, (const struct __ns1__Recipe_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Recipe:
		soap_serialize___ns1__Recipe(soap, (const struct __ns1__Recipe *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundMore_:
		soap_serialize___ns1__OutboundMore_(soap, (const struct __ns1__OutboundMore_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundMore:
		soap_serialize___ns1__OutboundMore(soap, (const struct __ns1__OutboundMore *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty_:
		soap_serialize___ns1__OutboundInSFCOutputQty_(soap, (const struct __ns1__OutboundInSFCOutputQty_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty:
		soap_serialize___ns1__OutboundInSFCOutputQty(soap, (const struct __ns1__OutboundInSFCOutputQty *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating_:
		soap_serialize___ns1__OutboundInLaminating_(soap, (const struct __ns1__OutboundInLaminating_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating:
		soap_serialize___ns1__OutboundInLaminating(soap, (const struct __ns1__OutboundInLaminating *)ptr);
		break;
	case SOAP_TYPE___ns1__Outbound_:
		soap_serialize___ns1__Outbound_(soap, (const struct __ns1__Outbound_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Outbound:
		soap_serialize___ns1__Outbound(soap, (const struct __ns1__Outbound *)ptr);
		break;
	case SOAP_TYPE___ns1__OperatorLogin_:
		soap_serialize___ns1__OperatorLogin_(soap, (const struct __ns1__OperatorLogin_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OperatorLogin:
		soap_serialize___ns1__OperatorLogin(soap, (const struct __ns1__OperatorLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundMore_:
		soap_serialize___ns1__InboundMore_(soap, (const struct __ns1__InboundMore_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundMore:
		soap_serialize___ns1__InboundMore(soap, (const struct __ns1__InboundMore *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection_:
		soap_serialize___ns1__InboundInTwoInjection_(soap, (const struct __ns1__InboundInTwoInjection_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection:
		soap_serialize___ns1__InboundInTwoInjection(soap, (const struct __ns1__InboundInTwoInjection *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer_:
		soap_serialize___ns1__InboundInSFCContainer_(soap, (const struct __ns1__InboundInSFCContainer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer:
		soap_serialize___ns1__InboundInSFCContainer(soap, (const struct __ns1__InboundInSFCContainer *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInContainer_:
		soap_serialize___ns1__InboundInContainer_(soap, (const struct __ns1__InboundInContainer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InboundInContainer:
		soap_serialize___ns1__InboundInContainer(soap, (const struct __ns1__InboundInContainer *)ptr);
		break;
	case SOAP_TYPE___ns1__Inbound_:
		soap_serialize___ns1__Inbound_(soap, (const struct __ns1__Inbound_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Inbound:
		soap_serialize___ns1__Inbound(soap, (const struct __ns1__Inbound *)ptr);
		break;
	case SOAP_TYPE___ns1__Heartbeat_:
		soap_serialize___ns1__Heartbeat_(soap, (const struct __ns1__Heartbeat_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Heartbeat:
		soap_serialize___ns1__Heartbeat(soap, (const struct __ns1__Heartbeat *)ptr);
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC_:
		soap_serialize___ns1__GenerateCellSFC_(soap, (const struct __ns1__GenerateCellSFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC:
		soap_serialize___ns1__GenerateCellSFC(soap, (const struct __ns1__GenerateCellSFC *)ptr);
		break;
	case SOAP_TYPE___ns1__FillingData_:
		soap_serialize___ns1__FillingData_(soap, (const struct __ns1__FillingData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__FillingData:
		soap_serialize___ns1__FillingData(soap, (const struct __ns1__FillingData *)ptr);
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating_:
		soap_serialize___ns1__FeedingDJInLaminating_(soap, (const struct __ns1__FeedingDJInLaminating_ *)ptr);
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating:
		soap_serialize___ns1__FeedingDJInLaminating(soap, (const struct __ns1__FeedingDJInLaminating *)ptr);
		break;
	case SOAP_TYPE___ns1__Feeding_:
		soap_serialize___ns1__Feeding_(soap, (const struct __ns1__Feeding_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Feeding:
		soap_serialize___ns1__Feeding(soap, (const struct __ns1__Feeding *)ptr);
		break;
	case SOAP_TYPE___ns1__ExamineExists_:
		soap_serialize___ns1__ExamineExists_(soap, (const struct __ns1__ExamineExists_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ExamineExists:
		soap_serialize___ns1__ExamineExists(soap, (const struct __ns1__ExamineExists *)ptr);
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam_:
		soap_serialize___ns1__EquipmentProductProcessParam_(soap, (const struct __ns1__EquipmentProductProcessParam_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam:
		soap_serialize___ns1__EquipmentProductProcessParam(soap, (const struct __ns1__EquipmentProductProcessParam *)ptr);
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam_:
		soap_serialize___ns1__EquipmentProcessParam_(soap, (const struct __ns1__EquipmentProcessParam_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam:
		soap_serialize___ns1__EquipmentProcessParam(soap, (const struct __ns1__EquipmentProcessParam *)ptr);
		break;
	case SOAP_TYPE___ns1__DownReason_:
		soap_serialize___ns1__DownReason_(soap, (const struct __ns1__DownReason_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownReason:
		soap_serialize___ns1__DownReason(soap, (const struct __ns1__DownReason *)ptr);
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete_:
		soap_serialize___ns1__CCDFileUploadComplete_(soap, (const struct __ns1__CCDFileUploadComplete_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete:
		soap_serialize___ns1__CCDFileUploadComplete(soap, (const struct __ns1__CCDFileUploadComplete *)ptr);
		break;
	case SOAP_TYPE___ns1__BindSFC_:
		soap_serialize___ns1__BindSFC_(soap, (const struct __ns1__BindSFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BindSFC:
		soap_serialize___ns1__BindSFC(soap, (const struct __ns1__BindSFC *)ptr);
		break;
	case SOAP_TYPE___ns1__BindContainer_:
		soap_serialize___ns1__BindContainer_(soap, (const struct __ns1__BindContainer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BindContainer:
		soap_serialize___ns1__BindContainer(soap, (const struct __ns1__BindContainer *)ptr);
		break;
	case SOAP_TYPE___ns1__Alarm_:
		soap_serialize___ns1__Alarm_(soap, (const struct __ns1__Alarm_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Alarm:
		soap_serialize___ns1__Alarm(soap, (const struct __ns1__Alarm *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UnBindSFC:
		soap_serialize_PointerTo_ns1__UnBindSFC(soap, (_ns1__UnBindSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ToolLife:
		soap_serialize_PointerTo_ns1__ToolLife(soap, (_ns1__ToolLife *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ToolBind:
		soap_serialize_PointerTo_ns1__ToolBind(soap, (_ns1__ToolBind *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__State:
		soap_serialize_PointerTo_ns1__State(soap, (_ns1__State *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RecipeVersionExamine:
		soap_serialize_PointerTo_ns1__RecipeVersionExamine(soap, (_ns1__RecipeVersionExamine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRecipeList:
		soap_serialize_PointerTo_ns1__GetRecipeList(soap, (_ns1__GetRecipeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRecipe:
		soap_serialize_PointerTo_ns1__GetRecipe(soap, (_ns1__GetRecipe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Recipe:
		soap_serialize_PointerTo_ns1__Recipe(soap, (_ns1__Recipe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OutboundMore:
		soap_serialize_PointerTo_ns1__OutboundMore(soap, (_ns1__OutboundMore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OutboundInSFCOutputQty:
		soap_serialize_PointerTo_ns1__OutboundInSFCOutputQty(soap, (_ns1__OutboundInSFCOutputQty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OutboundInLaminating:
		soap_serialize_PointerTo_ns1__OutboundInLaminating(soap, (_ns1__OutboundInLaminating *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Outbound:
		soap_serialize_PointerTo_ns1__Outbound(soap, (_ns1__Outbound *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OperatorLogin:
		soap_serialize_PointerTo_ns1__OperatorLogin(soap, (_ns1__OperatorLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InboundMore:
		soap_serialize_PointerTo_ns1__InboundMore(soap, (_ns1__InboundMore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InboundInTwoInjection:
		soap_serialize_PointerTo_ns1__InboundInTwoInjection(soap, (_ns1__InboundInTwoInjection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InboundInSFCContainer:
		soap_serialize_PointerTo_ns1__InboundInSFCContainer(soap, (_ns1__InboundInSFCContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InboundInContainer:
		soap_serialize_PointerTo_ns1__InboundInContainer(soap, (_ns1__InboundInContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Inbound:
		soap_serialize_PointerTo_ns1__Inbound(soap, (_ns1__Inbound *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Heartbeat:
		soap_serialize_PointerTo_ns1__Heartbeat(soap, (_ns1__Heartbeat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GenerateCellSFC:
		soap_serialize_PointerTo_ns1__GenerateCellSFC(soap, (_ns1__GenerateCellSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FillingData:
		soap_serialize_PointerTo_ns1__FillingData(soap, (_ns1__FillingData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FeedingDJInLaminating:
		soap_serialize_PointerTo_ns1__FeedingDJInLaminating(soap, (_ns1__FeedingDJInLaminating *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Feeding:
		soap_serialize_PointerTo_ns1__Feeding(soap, (_ns1__Feeding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExamineExists:
		soap_serialize_PointerTo_ns1__ExamineExists(soap, (_ns1__ExamineExists *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EquipmentProductProcessParam:
		soap_serialize_PointerTo_ns1__EquipmentProductProcessParam(soap, (_ns1__EquipmentProductProcessParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EquipmentProcessParam:
		soap_serialize_PointerTo_ns1__EquipmentProcessParam(soap, (_ns1__EquipmentProcessParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownReason:
		soap_serialize_PointerTo_ns1__DownReason(soap, (_ns1__DownReason *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CCDFileUploadComplete:
		soap_serialize_PointerTo_ns1__CCDFileUploadComplete(soap, (_ns1__CCDFileUploadComplete *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BindSFC:
		soap_serialize_PointerTo_ns1__BindSFC(soap, (_ns1__BindSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BindContainer:
		soap_serialize_PointerTo_ns1__BindContainer(soap, (_ns1__BindContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Alarm:
		soap_serialize_PointerTo_ns1__Alarm(soap, (_ns1__Alarm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LoginSoapHeader:
		soap_serialize_PointerTons1__LoginSoapHeader(soap, (ns1__LoginSoapHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeListGetForEqu:
		soap_serialize_PointerTons1__ArrayOfRecipeListGetForEqu(soap, (ns1__ArrayOfRecipeListGetForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeGetForEqu:
		soap_serialize_PointerTons1__RecipeGetForEqu(soap, (ns1__RecipeGetForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeParam:
		soap_serialize_PointerTons1__ArrayOfRecipeParam(soap, (ns1__ArrayOfRecipeParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfOutboundSFC:
		soap_serialize_PointerTons1__ArrayOfOutboundSFC(soap, (ns1__ArrayOfOutboundSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InboundInTwoInjectionForEqu:
		soap_serialize_PointerTons1__InboundInTwoInjectionForEqu(soap, (ns1__InboundInTwoInjectionForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfApiResponseSFCForScada:
		soap_serialize_PointerTons1__ArrayOfApiResponseSFCForScada(soap, (ns1__ArrayOfApiResponseSFCForScada *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfEquipmentProductProcessParamSFC:
		soap_serialize_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, (ns1__ArrayOfEquipmentProductProcessParamSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfCCDFileUploadCompleteSFC:
		soap_serialize_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, (ns1__ArrayOfCCDFileUploadCompleteSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfBindContainerSFC:
		soap_serialize_PointerTons1__ArrayOfBindContainerSFC(soap, (ns1__ArrayOfBindContainerSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UnBindSFCByScadaDTO:
		soap_serialize_PointerTons1__UnBindSFCByScadaDTO(soap, (ns1__UnBindSFCByScadaDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ToolLife:
		soap_serialize_PointerTons1__ToolLife(soap, (ns1__ToolLife *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ToolBind:
		soap_serialize_PointerTons1__ToolBind(soap, (ns1__ToolBind *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__State:
		soap_serialize_PointerTons1__State(soap, (ns1__State *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeVersionExamine:
		soap_serialize_PointerTons1__RecipeVersionExamine(soap, (ns1__RecipeVersionExamine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeListGet:
		soap_serialize_PointerTons1__RecipeListGet(soap, (ns1__RecipeListGet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu:
		soap_serialize_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, (ns1__ApiResponseDataForScadaOfRecipeGetForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeGet:
		soap_serialize_PointerTons1__RecipeGet(soap, (ns1__RecipeGet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Recipe:
		soap_serialize_PointerTons1__Recipe(soap, (ns1__Recipe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OutboundMore:
		soap_serialize_PointerTons1__OutboundMore(soap, (ns1__OutboundMore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OutboundInSFCOutputQty:
		soap_serialize_PointerTons1__OutboundInSFCOutputQty(soap, (ns1__OutboundInSFCOutputQty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OutboundInLaminating:
		soap_serialize_PointerTons1__OutboundInLaminating(soap, (ns1__OutboundInLaminating *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Outbound:
		soap_serialize_PointerTons1__Outbound(soap, (ns1__Outbound *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OperatorLogin:
		soap_serialize_PointerTons1__OperatorLogin(soap, (ns1__OperatorLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InboundMore:
		soap_serialize_PointerTons1__InboundMore(soap, (ns1__InboundMore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		soap_serialize_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InboundInTwoInjection:
		soap_serialize_PointerTons1__InboundInTwoInjection(soap, (ns1__InboundInTwoInjection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InboundInSFCContainer:
		soap_serialize_PointerTons1__InboundInSFCContainer(soap, (ns1__InboundInSFCContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InboundInContainer:
		soap_serialize_PointerTons1__InboundInContainer(soap, (ns1__InboundInContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Inbound:
		soap_serialize_PointerTons1__Inbound(soap, (ns1__Inbound *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Heartbeat:
		soap_serialize_PointerTons1__Heartbeat(soap, (ns1__Heartbeat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfString:
		soap_serialize_PointerTons1__ApiResponseDataForScadaOfString(soap, (ns1__ApiResponseDataForScadaOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenerateCellSFC:
		soap_serialize_PointerTons1__GenerateCellSFC(soap, (ns1__GenerateCellSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FillingData:
		soap_serialize_PointerTons1__FillingData(soap, (ns1__FillingData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FeedingDJInLaminatingByScadaDTO:
		soap_serialize_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, (ns1__FeedingDJInLaminatingByScadaDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FeedingByScadaDTO:
		soap_serialize_PointerTons1__FeedingByScadaDTO(soap, (ns1__FeedingByScadaDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExamineExistsByScadaDTO:
		soap_serialize_PointerTons1__ExamineExistsByScadaDTO(soap, (ns1__ExamineExistsByScadaDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParam:
		soap_serialize_PointerTons1__EquipmentProductProcessParam(soap, (ns1__EquipmentProductProcessParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EquipmentProcessParam:
		soap_serialize_PointerTons1__EquipmentProcessParam(soap, (ns1__EquipmentProcessParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDownReason:
		soap_serialize_PointerTons1__ArrayOfDownReason(soap, (ns1__ArrayOfDownReason *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CCDFileUploadComplete:
		soap_serialize_PointerTons1__CCDFileUploadComplete(soap, (ns1__CCDFileUploadComplete *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BindSFCByScadaDTO:
		soap_serialize_PointerTons1__BindSFCByScadaDTO(soap, (ns1__BindSFCByScadaDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BindContainer:
		soap_serialize_PointerTons1__BindContainer(soap, (ns1__BindContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseForScada:
		soap_serialize_PointerTons1__ApiResponseForScada(soap, (ns1__ApiResponseForScada *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAlarm:
		soap_serialize_PointerTons1__ArrayOfAlarm(soap, (ns1__ArrayOfAlarm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeListGetForEqu:
		soap_serialize_PointerTons1__RecipeListGetForEqu(soap, (ns1__RecipeListGetForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeGetParamForEqu:
		soap_serialize_PointerTons1__RecipeGetParamForEqu(soap, (ns1__RecipeGetParamForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfRecipeGetParamForEqu:
		soap_serialize_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, (ns1__ArrayOfRecipeGetParamForEqu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipeParam:
		soap_serialize_PointerTons1__RecipeParam(soap, (ns1__RecipeParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OutboundSFC:
		soap_serialize_PointerTons1__OutboundSFC(soap, (ns1__OutboundSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApiResponseSFCForScada:
		soap_serialize_PointerTons1__ApiResponseSFCForScada(soap, (ns1__ApiResponseSFCForScada *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfParamDTO:
		soap_serialize_PointerTons1__ArrayOfParamDTO(soap, (ns1__ArrayOfParamDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EquipmentProductProcessParamSFC:
		soap_serialize_PointerTons1__EquipmentProductProcessParamSFC(soap, (ns1__EquipmentProductProcessParamSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ParamDTO:
		soap_serialize_PointerTons1__ParamDTO(soap, (ns1__ParamDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DownReason:
		soap_serialize_PointerTons1__DownReason(soap, (ns1__DownReason *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CCDFileUploadCompleteSFC:
		soap_serialize_PointerTons1__CCDFileUploadCompleteSFC(soap, (ns1__CCDFileUploadCompleteSFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BindContainerSFC:
		soap_serialize_PointerTons1__BindContainerSFC(soap, (ns1__BindContainerSFC *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTons1__Alarm:
		soap_serialize_PointerTons1__Alarm(soap, (ns1__Alarm *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		return (void*)soap_instantiate_ns1__ArrayOfAlarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		return (void*)soap_instantiate_ns1__BaseApiRequestByScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		return (void*)soap_instantiate_ns1__BaseApiResponseForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoginSoapHeader:
		return (void*)soap_instantiate_ns1__LoginSoapHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		return (void*)soap_instantiate_ns1__ArrayOfBindContainerSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BindContainerSFC:
		return (void*)soap_instantiate_ns1__BindContainerSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		return (void*)soap_instantiate_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		return (void*)soap_instantiate_ns1__CCDFileUploadCompleteSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		return (void*)soap_instantiate_ns1__ArrayOfDownReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		return (void*)soap_instantiate_ns1__ArrayOfParamDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ParamDTO:
		return (void*)soap_instantiate_ns1__ParamDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		return (void*)soap_instantiate_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		return (void*)soap_instantiate_ns1__EquipmentProductProcessParamSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		return (void*)soap_instantiate_ns1__ArrayOfApiResponseSFCForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		return (void*)soap_instantiate_ns1__InboundInTwoInjectionForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		return (void*)soap_instantiate_ns1__ArrayOfOutboundSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OutboundSFC:
		return (void*)soap_instantiate_ns1__OutboundSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		return (void*)soap_instantiate_ns1__ArrayOfRecipeParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeParam:
		return (void*)soap_instantiate_ns1__RecipeParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		return (void*)soap_instantiate_ns1__RecipeGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		return (void*)soap_instantiate_ns1__ArrayOfRecipeGetParamForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		return (void*)soap_instantiate_ns1__RecipeGetParamForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		return (void*)soap_instantiate_ns1__ArrayOfRecipeListGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		return (void*)soap_instantiate_ns1__RecipeListGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Alarm:
		return (void*)soap_instantiate__ns1__Alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlarmResponse:
		return (void*)soap_instantiate__ns1__AlarmResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindContainer:
		return (void*)soap_instantiate__ns1__BindContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindContainerResponse:
		return (void*)soap_instantiate__ns1__BindContainerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindSFC:
		return (void*)soap_instantiate__ns1__BindSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindSFCResponse:
		return (void*)soap_instantiate__ns1__BindSFCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CCDFileUploadComplete:
		return (void*)soap_instantiate__ns1__CCDFileUploadComplete(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CCDFileUploadCompleteResponse:
		return (void*)soap_instantiate__ns1__CCDFileUploadCompleteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownReason:
		return (void*)soap_instantiate__ns1__DownReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownReasonResponse:
		return (void*)soap_instantiate__ns1__DownReasonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EquipmentProcessParam:
		return (void*)soap_instantiate__ns1__EquipmentProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EquipmentProcessParamResponse:
		return (void*)soap_instantiate__ns1__EquipmentProcessParamResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EquipmentProductProcessParam:
		return (void*)soap_instantiate__ns1__EquipmentProductProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EquipmentProductProcessParamResponse:
		return (void*)soap_instantiate__ns1__EquipmentProductProcessParamResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExamineExists:
		return (void*)soap_instantiate__ns1__ExamineExists(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExamineExistsResponse:
		return (void*)soap_instantiate__ns1__ExamineExistsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Feeding:
		return (void*)soap_instantiate__ns1__Feeding(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FeedingResponse:
		return (void*)soap_instantiate__ns1__FeedingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FeedingDJInLaminating:
		return (void*)soap_instantiate__ns1__FeedingDJInLaminating(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FeedingDJInLaminatingResponse:
		return (void*)soap_instantiate__ns1__FeedingDJInLaminatingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FillingData:
		return (void*)soap_instantiate__ns1__FillingData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FillingDataResponse:
		return (void*)soap_instantiate__ns1__FillingDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GenerateCellSFC:
		return (void*)soap_instantiate__ns1__GenerateCellSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GenerateCellSFCResponse:
		return (void*)soap_instantiate__ns1__GenerateCellSFCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Heartbeat:
		return (void*)soap_instantiate__ns1__Heartbeat(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HeartbeatResponse:
		return (void*)soap_instantiate__ns1__HeartbeatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Inbound:
		return (void*)soap_instantiate__ns1__Inbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundResponse:
		return (void*)soap_instantiate__ns1__InboundResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInContainer:
		return (void*)soap_instantiate__ns1__InboundInContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInContainerResponse:
		return (void*)soap_instantiate__ns1__InboundInContainerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInSFCContainer:
		return (void*)soap_instantiate__ns1__InboundInSFCContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInSFCContainerResponse:
		return (void*)soap_instantiate__ns1__InboundInSFCContainerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInTwoInjection:
		return (void*)soap_instantiate__ns1__InboundInTwoInjection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundInTwoInjectionResponse:
		return (void*)soap_instantiate__ns1__InboundInTwoInjectionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundMore:
		return (void*)soap_instantiate__ns1__InboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InboundMoreResponse:
		return (void*)soap_instantiate__ns1__InboundMoreResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OperatorLogin:
		return (void*)soap_instantiate__ns1__OperatorLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OperatorLoginResponse:
		return (void*)soap_instantiate__ns1__OperatorLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Outbound:
		return (void*)soap_instantiate__ns1__Outbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundResponse:
		return (void*)soap_instantiate__ns1__OutboundResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundInLaminating:
		return (void*)soap_instantiate__ns1__OutboundInLaminating(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundInLaminatingResponse:
		return (void*)soap_instantiate__ns1__OutboundInLaminatingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundInSFCOutputQty:
		return (void*)soap_instantiate__ns1__OutboundInSFCOutputQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse:
		return (void*)soap_instantiate__ns1__OutboundInSFCOutputQtyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundMore:
		return (void*)soap_instantiate__ns1__OutboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutboundMoreResponse:
		return (void*)soap_instantiate__ns1__OutboundMoreResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Recipe:
		return (void*)soap_instantiate__ns1__Recipe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RecipeResponse:
		return (void*)soap_instantiate__ns1__RecipeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecipe:
		return (void*)soap_instantiate__ns1__GetRecipe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecipeResponse:
		return (void*)soap_instantiate__ns1__GetRecipeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecipeList:
		return (void*)soap_instantiate__ns1__GetRecipeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecipeListResponse:
		return (void*)soap_instantiate__ns1__GetRecipeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RecipeVersionExamine:
		return (void*)soap_instantiate__ns1__RecipeVersionExamine(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RecipeVersionExamineResponse:
		return (void*)soap_instantiate__ns1__RecipeVersionExamineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__State:
		return (void*)soap_instantiate__ns1__State(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StateResponse:
		return (void*)soap_instantiate__ns1__StateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ToolBind:
		return (void*)soap_instantiate__ns1__ToolBind(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ToolBindResponse:
		return (void*)soap_instantiate__ns1__ToolBindResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ToolLife:
		return (void*)soap_instantiate__ns1__ToolLife(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ToolLifeResponse:
		return (void*)soap_instantiate__ns1__ToolLifeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnBindSFC:
		return (void*)soap_instantiate__ns1__UnBindSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnBindSFCResponse:
		return (void*)soap_instantiate__ns1__UnBindSFCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Alarm:
		return (void*)soap_instantiate_ns1__Alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseForScada:
		return (void*)soap_instantiate_ns1__ApiResponseForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BindContainer:
		return (void*)soap_instantiate_ns1__BindContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		return (void*)soap_instantiate_ns1__BindSFCByScadaDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		return (void*)soap_instantiate_ns1__CCDFileUploadComplete(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DownReason:
		return (void*)soap_instantiate_ns1__DownReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		return (void*)soap_instantiate_ns1__EquipmentProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		return (void*)soap_instantiate_ns1__EquipmentProductProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		return (void*)soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		return (void*)soap_instantiate_ns1__ApiResponseSFCForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		return (void*)soap_instantiate_ns1__ExamineExistsByScadaDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		return (void*)soap_instantiate_ns1__FeedingByScadaDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		return (void*)soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FillingData:
		return (void*)soap_instantiate_ns1__FillingData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenerateCellSFC:
		return (void*)soap_instantiate_ns1__GenerateCellSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		return (void*)soap_instantiate_ns1__ApiResponseDataForScadaOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Heartbeat:
		return (void*)soap_instantiate_ns1__Heartbeat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Inbound:
		return (void*)soap_instantiate_ns1__Inbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InboundInContainer:
		return (void*)soap_instantiate_ns1__InboundInContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		return (void*)soap_instantiate_ns1__InboundInSFCContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		return (void*)soap_instantiate_ns1__InboundInTwoInjection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		return (void*)soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InboundMore:
		return (void*)soap_instantiate_ns1__InboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OperatorLogin:
		return (void*)soap_instantiate_ns1__OperatorLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Outbound:
		return (void*)soap_instantiate_ns1__Outbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OutboundInLaminating:
		return (void*)soap_instantiate_ns1__OutboundInLaminating(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		return (void*)soap_instantiate_ns1__OutboundInSFCOutputQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OutboundMore:
		return (void*)soap_instantiate_ns1__OutboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Recipe:
		return (void*)soap_instantiate_ns1__Recipe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeGet:
		return (void*)soap_instantiate_ns1__RecipeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		return (void*)soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeListGet:
		return (void*)soap_instantiate_ns1__RecipeListGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		return (void*)soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		return (void*)soap_instantiate_ns1__RecipeVersionExamine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__State:
		return (void*)soap_instantiate_ns1__State(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ToolBind:
		return (void*)soap_instantiate_ns1__ToolBind(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ToolLife:
		return (void*)soap_instantiate_ns1__ToolLife(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		return (void*)soap_instantiate_ns1__UnBindSFCByScadaDTO(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__Alarm:
		return (void*)soap_instantiate___ns1__Alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Alarm_:
		return (void*)soap_instantiate___ns1__Alarm_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindContainer:
		return (void*)soap_instantiate___ns1__BindContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindContainer_:
		return (void*)soap_instantiate___ns1__BindContainer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindSFC:
		return (void*)soap_instantiate___ns1__BindSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindSFC_:
		return (void*)soap_instantiate___ns1__BindSFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CCDFileUploadComplete:
		return (void*)soap_instantiate___ns1__CCDFileUploadComplete(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CCDFileUploadComplete_:
		return (void*)soap_instantiate___ns1__CCDFileUploadComplete_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownReason:
		return (void*)soap_instantiate___ns1__DownReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownReason_:
		return (void*)soap_instantiate___ns1__DownReason_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EquipmentProcessParam:
		return (void*)soap_instantiate___ns1__EquipmentProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EquipmentProcessParam_:
		return (void*)soap_instantiate___ns1__EquipmentProcessParam_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EquipmentProductProcessParam:
		return (void*)soap_instantiate___ns1__EquipmentProductProcessParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EquipmentProductProcessParam_:
		return (void*)soap_instantiate___ns1__EquipmentProductProcessParam_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExamineExists:
		return (void*)soap_instantiate___ns1__ExamineExists(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExamineExists_:
		return (void*)soap_instantiate___ns1__ExamineExists_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Feeding:
		return (void*)soap_instantiate___ns1__Feeding(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Feeding_:
		return (void*)soap_instantiate___ns1__Feeding_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FeedingDJInLaminating:
		return (void*)soap_instantiate___ns1__FeedingDJInLaminating(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FeedingDJInLaminating_:
		return (void*)soap_instantiate___ns1__FeedingDJInLaminating_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FillingData:
		return (void*)soap_instantiate___ns1__FillingData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FillingData_:
		return (void*)soap_instantiate___ns1__FillingData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GenerateCellSFC:
		return (void*)soap_instantiate___ns1__GenerateCellSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GenerateCellSFC_:
		return (void*)soap_instantiate___ns1__GenerateCellSFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Heartbeat:
		return (void*)soap_instantiate___ns1__Heartbeat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Heartbeat_:
		return (void*)soap_instantiate___ns1__Heartbeat_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Inbound:
		return (void*)soap_instantiate___ns1__Inbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Inbound_:
		return (void*)soap_instantiate___ns1__Inbound_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInContainer:
		return (void*)soap_instantiate___ns1__InboundInContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInContainer_:
		return (void*)soap_instantiate___ns1__InboundInContainer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInSFCContainer:
		return (void*)soap_instantiate___ns1__InboundInSFCContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInSFCContainer_:
		return (void*)soap_instantiate___ns1__InboundInSFCContainer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInTwoInjection:
		return (void*)soap_instantiate___ns1__InboundInTwoInjection(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundInTwoInjection_:
		return (void*)soap_instantiate___ns1__InboundInTwoInjection_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundMore:
		return (void*)soap_instantiate___ns1__InboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InboundMore_:
		return (void*)soap_instantiate___ns1__InboundMore_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OperatorLogin:
		return (void*)soap_instantiate___ns1__OperatorLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OperatorLogin_:
		return (void*)soap_instantiate___ns1__OperatorLogin_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Outbound:
		return (void*)soap_instantiate___ns1__Outbound(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Outbound_:
		return (void*)soap_instantiate___ns1__Outbound_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundInLaminating:
		return (void*)soap_instantiate___ns1__OutboundInLaminating(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundInLaminating_:
		return (void*)soap_instantiate___ns1__OutboundInLaminating_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty:
		return (void*)soap_instantiate___ns1__OutboundInSFCOutputQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty_:
		return (void*)soap_instantiate___ns1__OutboundInSFCOutputQty_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundMore:
		return (void*)soap_instantiate___ns1__OutboundMore(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutboundMore_:
		return (void*)soap_instantiate___ns1__OutboundMore_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Recipe:
		return (void*)soap_instantiate___ns1__Recipe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Recipe_:
		return (void*)soap_instantiate___ns1__Recipe_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRecipe:
		return (void*)soap_instantiate___ns1__GetRecipe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRecipe_:
		return (void*)soap_instantiate___ns1__GetRecipe_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRecipeList:
		return (void*)soap_instantiate___ns1__GetRecipeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRecipeList_:
		return (void*)soap_instantiate___ns1__GetRecipeList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RecipeVersionExamine:
		return (void*)soap_instantiate___ns1__RecipeVersionExamine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RecipeVersionExamine_:
		return (void*)soap_instantiate___ns1__RecipeVersionExamine_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__State:
		return (void*)soap_instantiate___ns1__State(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__State_:
		return (void*)soap_instantiate___ns1__State_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ToolBind:
		return (void*)soap_instantiate___ns1__ToolBind(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ToolBind_:
		return (void*)soap_instantiate___ns1__ToolBind_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ToolLife:
		return (void*)soap_instantiate___ns1__ToolLife(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ToolLife_:
		return (void*)soap_instantiate___ns1__ToolLife_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UnBindSFC:
		return (void*)soap_instantiate___ns1__UnBindSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UnBindSFC_:
		return (void*)soap_instantiate___ns1__UnBindSFC_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__OutboundSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ParamDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DownReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Alarm(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::wstring*>(p->ptr), std::wstring);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::wstring*>(p->ptr), std::wstring);
		break;
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfAlarm*>(p->ptr), ns1__ArrayOfAlarm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfAlarm*>(p->ptr), ns1__ArrayOfAlarm);
		break;
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BaseApiRequestByScada*>(p->ptr), ns1__BaseApiRequestByScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BaseApiRequestByScada*>(p->ptr), ns1__BaseApiRequestByScada);
		break;
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BaseApiResponseForScada*>(p->ptr), ns1__BaseApiResponseForScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BaseApiResponseForScada*>(p->ptr), ns1__BaseApiResponseForScada);
		break;
	case SOAP_TYPE_ns1__LoginSoapHeader:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__LoginSoapHeader*>(p->ptr), ns1__LoginSoapHeader);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__LoginSoapHeader*>(p->ptr), ns1__LoginSoapHeader);
		break;
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfBindContainerSFC*>(p->ptr), ns1__ArrayOfBindContainerSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfBindContainerSFC*>(p->ptr), ns1__ArrayOfBindContainerSFC);
		break;
	case SOAP_TYPE_ns1__BindContainerSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BindContainerSFC*>(p->ptr), ns1__BindContainerSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BindContainerSFC*>(p->ptr), ns1__BindContainerSFC);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfString*>(p->ptr), ns1__ArrayOfString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfString*>(p->ptr), ns1__ArrayOfString);
		break;
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfCCDFileUploadCompleteSFC*>(p->ptr), ns1__ArrayOfCCDFileUploadCompleteSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfCCDFileUploadCompleteSFC*>(p->ptr), ns1__ArrayOfCCDFileUploadCompleteSFC);
		break;
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCDFileUploadCompleteSFC*>(p->ptr), ns1__CCDFileUploadCompleteSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCDFileUploadCompleteSFC*>(p->ptr), ns1__CCDFileUploadCompleteSFC);
		break;
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfDownReason*>(p->ptr), ns1__ArrayOfDownReason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfDownReason*>(p->ptr), ns1__ArrayOfDownReason);
		break;
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfParamDTO*>(p->ptr), ns1__ArrayOfParamDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfParamDTO*>(p->ptr), ns1__ArrayOfParamDTO);
		break;
	case SOAP_TYPE_ns1__ParamDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ParamDTO*>(p->ptr), ns1__ParamDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ParamDTO*>(p->ptr), ns1__ParamDTO);
		break;
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfEquipmentProductProcessParamSFC*>(p->ptr), ns1__ArrayOfEquipmentProductProcessParamSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfEquipmentProductProcessParamSFC*>(p->ptr), ns1__ArrayOfEquipmentProductProcessParamSFC);
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__EquipmentProductProcessParamSFC*>(p->ptr), ns1__EquipmentProductProcessParamSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__EquipmentProductProcessParamSFC*>(p->ptr), ns1__EquipmentProductProcessParamSFC);
		break;
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfApiResponseSFCForScada*>(p->ptr), ns1__ArrayOfApiResponseSFCForScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfApiResponseSFCForScada*>(p->ptr), ns1__ArrayOfApiResponseSFCForScada);
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InboundInTwoInjectionForEqu*>(p->ptr), ns1__InboundInTwoInjectionForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InboundInTwoInjectionForEqu*>(p->ptr), ns1__InboundInTwoInjectionForEqu);
		break;
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfOutboundSFC*>(p->ptr), ns1__ArrayOfOutboundSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfOutboundSFC*>(p->ptr), ns1__ArrayOfOutboundSFC);
		break;
	case SOAP_TYPE_ns1__OutboundSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OutboundSFC*>(p->ptr), ns1__OutboundSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OutboundSFC*>(p->ptr), ns1__OutboundSFC);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfRecipeParam*>(p->ptr), ns1__ArrayOfRecipeParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfRecipeParam*>(p->ptr), ns1__ArrayOfRecipeParam);
		break;
	case SOAP_TYPE_ns1__RecipeParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeParam*>(p->ptr), ns1__RecipeParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeParam*>(p->ptr), ns1__RecipeParam);
		break;
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeGetForEqu*>(p->ptr), ns1__RecipeGetForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeGetForEqu*>(p->ptr), ns1__RecipeGetForEqu);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfRecipeGetParamForEqu*>(p->ptr), ns1__ArrayOfRecipeGetParamForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfRecipeGetParamForEqu*>(p->ptr), ns1__ArrayOfRecipeGetParamForEqu);
		break;
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeGetParamForEqu*>(p->ptr), ns1__RecipeGetParamForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeGetParamForEqu*>(p->ptr), ns1__RecipeGetParamForEqu);
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfRecipeListGetForEqu*>(p->ptr), ns1__ArrayOfRecipeListGetForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfRecipeListGetForEqu*>(p->ptr), ns1__ArrayOfRecipeListGetForEqu);
		break;
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeListGetForEqu*>(p->ptr), ns1__RecipeListGetForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeListGetForEqu*>(p->ptr), ns1__RecipeListGetForEqu);
		break;
	case SOAP_TYPE__ns1__Alarm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Alarm*>(p->ptr), _ns1__Alarm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Alarm*>(p->ptr), _ns1__Alarm);
		break;
	case SOAP_TYPE__ns1__AlarmResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AlarmResponse*>(p->ptr), _ns1__AlarmResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AlarmResponse*>(p->ptr), _ns1__AlarmResponse);
		break;
	case SOAP_TYPE__ns1__BindContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindContainer*>(p->ptr), _ns1__BindContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindContainer*>(p->ptr), _ns1__BindContainer);
		break;
	case SOAP_TYPE__ns1__BindContainerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindContainerResponse*>(p->ptr), _ns1__BindContainerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindContainerResponse*>(p->ptr), _ns1__BindContainerResponse);
		break;
	case SOAP_TYPE__ns1__BindSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindSFC*>(p->ptr), _ns1__BindSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindSFC*>(p->ptr), _ns1__BindSFC);
		break;
	case SOAP_TYPE__ns1__BindSFCResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindSFCResponse*>(p->ptr), _ns1__BindSFCResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindSFCResponse*>(p->ptr), _ns1__BindSFCResponse);
		break;
	case SOAP_TYPE__ns1__CCDFileUploadComplete:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CCDFileUploadComplete*>(p->ptr), _ns1__CCDFileUploadComplete);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CCDFileUploadComplete*>(p->ptr), _ns1__CCDFileUploadComplete);
		break;
	case SOAP_TYPE__ns1__CCDFileUploadCompleteResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CCDFileUploadCompleteResponse*>(p->ptr), _ns1__CCDFileUploadCompleteResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CCDFileUploadCompleteResponse*>(p->ptr), _ns1__CCDFileUploadCompleteResponse);
		break;
	case SOAP_TYPE__ns1__DownReason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownReason*>(p->ptr), _ns1__DownReason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownReason*>(p->ptr), _ns1__DownReason);
		break;
	case SOAP_TYPE__ns1__DownReasonResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownReasonResponse*>(p->ptr), _ns1__DownReasonResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownReasonResponse*>(p->ptr), _ns1__DownReasonResponse);
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EquipmentProcessParam*>(p->ptr), _ns1__EquipmentProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EquipmentProcessParam*>(p->ptr), _ns1__EquipmentProcessParam);
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParamResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EquipmentProcessParamResponse*>(p->ptr), _ns1__EquipmentProcessParamResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EquipmentProcessParamResponse*>(p->ptr), _ns1__EquipmentProcessParamResponse);
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EquipmentProductProcessParam*>(p->ptr), _ns1__EquipmentProductProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EquipmentProductProcessParam*>(p->ptr), _ns1__EquipmentProductProcessParam);
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParamResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EquipmentProductProcessParamResponse*>(p->ptr), _ns1__EquipmentProductProcessParamResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EquipmentProductProcessParamResponse*>(p->ptr), _ns1__EquipmentProductProcessParamResponse);
		break;
	case SOAP_TYPE__ns1__ExamineExists:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExamineExists*>(p->ptr), _ns1__ExamineExists);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExamineExists*>(p->ptr), _ns1__ExamineExists);
		break;
	case SOAP_TYPE__ns1__ExamineExistsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExamineExistsResponse*>(p->ptr), _ns1__ExamineExistsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExamineExistsResponse*>(p->ptr), _ns1__ExamineExistsResponse);
		break;
	case SOAP_TYPE__ns1__Feeding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Feeding*>(p->ptr), _ns1__Feeding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Feeding*>(p->ptr), _ns1__Feeding);
		break;
	case SOAP_TYPE__ns1__FeedingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FeedingResponse*>(p->ptr), _ns1__FeedingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FeedingResponse*>(p->ptr), _ns1__FeedingResponse);
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FeedingDJInLaminating*>(p->ptr), _ns1__FeedingDJInLaminating);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FeedingDJInLaminating*>(p->ptr), _ns1__FeedingDJInLaminating);
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminatingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FeedingDJInLaminatingResponse*>(p->ptr), _ns1__FeedingDJInLaminatingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FeedingDJInLaminatingResponse*>(p->ptr), _ns1__FeedingDJInLaminatingResponse);
		break;
	case SOAP_TYPE__ns1__FillingData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FillingData*>(p->ptr), _ns1__FillingData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FillingData*>(p->ptr), _ns1__FillingData);
		break;
	case SOAP_TYPE__ns1__FillingDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FillingDataResponse*>(p->ptr), _ns1__FillingDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FillingDataResponse*>(p->ptr), _ns1__FillingDataResponse);
		break;
	case SOAP_TYPE__ns1__GenerateCellSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GenerateCellSFC*>(p->ptr), _ns1__GenerateCellSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GenerateCellSFC*>(p->ptr), _ns1__GenerateCellSFC);
		break;
	case SOAP_TYPE__ns1__GenerateCellSFCResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GenerateCellSFCResponse*>(p->ptr), _ns1__GenerateCellSFCResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GenerateCellSFCResponse*>(p->ptr), _ns1__GenerateCellSFCResponse);
		break;
	case SOAP_TYPE__ns1__Heartbeat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Heartbeat*>(p->ptr), _ns1__Heartbeat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Heartbeat*>(p->ptr), _ns1__Heartbeat);
		break;
	case SOAP_TYPE__ns1__HeartbeatResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__HeartbeatResponse*>(p->ptr), _ns1__HeartbeatResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__HeartbeatResponse*>(p->ptr), _ns1__HeartbeatResponse);
		break;
	case SOAP_TYPE__ns1__Inbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Inbound*>(p->ptr), _ns1__Inbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Inbound*>(p->ptr), _ns1__Inbound);
		break;
	case SOAP_TYPE__ns1__InboundResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundResponse*>(p->ptr), _ns1__InboundResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundResponse*>(p->ptr), _ns1__InboundResponse);
		break;
	case SOAP_TYPE__ns1__InboundInContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInContainer*>(p->ptr), _ns1__InboundInContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInContainer*>(p->ptr), _ns1__InboundInContainer);
		break;
	case SOAP_TYPE__ns1__InboundInContainerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInContainerResponse*>(p->ptr), _ns1__InboundInContainerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInContainerResponse*>(p->ptr), _ns1__InboundInContainerResponse);
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInSFCContainer*>(p->ptr), _ns1__InboundInSFCContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInSFCContainer*>(p->ptr), _ns1__InboundInSFCContainer);
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInSFCContainerResponse*>(p->ptr), _ns1__InboundInSFCContainerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInSFCContainerResponse*>(p->ptr), _ns1__InboundInSFCContainerResponse);
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInTwoInjection*>(p->ptr), _ns1__InboundInTwoInjection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInTwoInjection*>(p->ptr), _ns1__InboundInTwoInjection);
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjectionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundInTwoInjectionResponse*>(p->ptr), _ns1__InboundInTwoInjectionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundInTwoInjectionResponse*>(p->ptr), _ns1__InboundInTwoInjectionResponse);
		break;
	case SOAP_TYPE__ns1__InboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundMore*>(p->ptr), _ns1__InboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundMore*>(p->ptr), _ns1__InboundMore);
		break;
	case SOAP_TYPE__ns1__InboundMoreResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__InboundMoreResponse*>(p->ptr), _ns1__InboundMoreResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__InboundMoreResponse*>(p->ptr), _ns1__InboundMoreResponse);
		break;
	case SOAP_TYPE__ns1__OperatorLogin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OperatorLogin*>(p->ptr), _ns1__OperatorLogin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OperatorLogin*>(p->ptr), _ns1__OperatorLogin);
		break;
	case SOAP_TYPE__ns1__OperatorLoginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OperatorLoginResponse*>(p->ptr), _ns1__OperatorLoginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OperatorLoginResponse*>(p->ptr), _ns1__OperatorLoginResponse);
		break;
	case SOAP_TYPE__ns1__Outbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Outbound*>(p->ptr), _ns1__Outbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Outbound*>(p->ptr), _ns1__Outbound);
		break;
	case SOAP_TYPE__ns1__OutboundResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundResponse*>(p->ptr), _ns1__OutboundResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundResponse*>(p->ptr), _ns1__OutboundResponse);
		break;
	case SOAP_TYPE__ns1__OutboundInLaminating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundInLaminating*>(p->ptr), _ns1__OutboundInLaminating);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundInLaminating*>(p->ptr), _ns1__OutboundInLaminating);
		break;
	case SOAP_TYPE__ns1__OutboundInLaminatingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundInLaminatingResponse*>(p->ptr), _ns1__OutboundInLaminatingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundInLaminatingResponse*>(p->ptr), _ns1__OutboundInLaminatingResponse);
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQty:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundInSFCOutputQty*>(p->ptr), _ns1__OutboundInSFCOutputQty);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundInSFCOutputQty*>(p->ptr), _ns1__OutboundInSFCOutputQty);
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundInSFCOutputQtyResponse*>(p->ptr), _ns1__OutboundInSFCOutputQtyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundInSFCOutputQtyResponse*>(p->ptr), _ns1__OutboundInSFCOutputQtyResponse);
		break;
	case SOAP_TYPE__ns1__OutboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundMore*>(p->ptr), _ns1__OutboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundMore*>(p->ptr), _ns1__OutboundMore);
		break;
	case SOAP_TYPE__ns1__OutboundMoreResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OutboundMoreResponse*>(p->ptr), _ns1__OutboundMoreResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OutboundMoreResponse*>(p->ptr), _ns1__OutboundMoreResponse);
		break;
	case SOAP_TYPE__ns1__Recipe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Recipe*>(p->ptr), _ns1__Recipe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Recipe*>(p->ptr), _ns1__Recipe);
		break;
	case SOAP_TYPE__ns1__RecipeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__RecipeResponse*>(p->ptr), _ns1__RecipeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__RecipeResponse*>(p->ptr), _ns1__RecipeResponse);
		break;
	case SOAP_TYPE__ns1__GetRecipe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRecipe*>(p->ptr), _ns1__GetRecipe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRecipe*>(p->ptr), _ns1__GetRecipe);
		break;
	case SOAP_TYPE__ns1__GetRecipeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRecipeResponse*>(p->ptr), _ns1__GetRecipeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRecipeResponse*>(p->ptr), _ns1__GetRecipeResponse);
		break;
	case SOAP_TYPE__ns1__GetRecipeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRecipeList*>(p->ptr), _ns1__GetRecipeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRecipeList*>(p->ptr), _ns1__GetRecipeList);
		break;
	case SOAP_TYPE__ns1__GetRecipeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRecipeListResponse*>(p->ptr), _ns1__GetRecipeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRecipeListResponse*>(p->ptr), _ns1__GetRecipeListResponse);
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamine:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__RecipeVersionExamine*>(p->ptr), _ns1__RecipeVersionExamine);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__RecipeVersionExamine*>(p->ptr), _ns1__RecipeVersionExamine);
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamineResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__RecipeVersionExamineResponse*>(p->ptr), _ns1__RecipeVersionExamineResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__RecipeVersionExamineResponse*>(p->ptr), _ns1__RecipeVersionExamineResponse);
		break;
	case SOAP_TYPE__ns1__State:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__State*>(p->ptr), _ns1__State);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__State*>(p->ptr), _ns1__State);
		break;
	case SOAP_TYPE__ns1__StateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__StateResponse*>(p->ptr), _ns1__StateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__StateResponse*>(p->ptr), _ns1__StateResponse);
		break;
	case SOAP_TYPE__ns1__ToolBind:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ToolBind*>(p->ptr), _ns1__ToolBind);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ToolBind*>(p->ptr), _ns1__ToolBind);
		break;
	case SOAP_TYPE__ns1__ToolBindResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ToolBindResponse*>(p->ptr), _ns1__ToolBindResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ToolBindResponse*>(p->ptr), _ns1__ToolBindResponse);
		break;
	case SOAP_TYPE__ns1__ToolLife:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ToolLife*>(p->ptr), _ns1__ToolLife);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ToolLife*>(p->ptr), _ns1__ToolLife);
		break;
	case SOAP_TYPE__ns1__ToolLifeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ToolLifeResponse*>(p->ptr), _ns1__ToolLifeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ToolLifeResponse*>(p->ptr), _ns1__ToolLifeResponse);
		break;
	case SOAP_TYPE__ns1__UnBindSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UnBindSFC*>(p->ptr), _ns1__UnBindSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UnBindSFC*>(p->ptr), _ns1__UnBindSFC);
		break;
	case SOAP_TYPE__ns1__UnBindSFCResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UnBindSFCResponse*>(p->ptr), _ns1__UnBindSFCResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UnBindSFCResponse*>(p->ptr), _ns1__UnBindSFCResponse);
		break;
	case SOAP_TYPE_ns1__Alarm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Alarm*>(p->ptr), ns1__Alarm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Alarm*>(p->ptr), ns1__Alarm);
		break;
	case SOAP_TYPE_ns1__ApiResponseForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseForScada*>(p->ptr), ns1__ApiResponseForScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseForScada*>(p->ptr), ns1__ApiResponseForScada);
		break;
	case SOAP_TYPE_ns1__BindContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BindContainer*>(p->ptr), ns1__BindContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BindContainer*>(p->ptr), ns1__BindContainer);
		break;
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BindSFCByScadaDTO*>(p->ptr), ns1__BindSFCByScadaDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BindSFCByScadaDTO*>(p->ptr), ns1__BindSFCByScadaDTO);
		break;
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCDFileUploadComplete*>(p->ptr), ns1__CCDFileUploadComplete);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCDFileUploadComplete*>(p->ptr), ns1__CCDFileUploadComplete);
		break;
	case SOAP_TYPE_ns1__DownReason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DownReason*>(p->ptr), ns1__DownReason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DownReason*>(p->ptr), ns1__DownReason);
		break;
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__EquipmentProcessParam*>(p->ptr), ns1__EquipmentProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__EquipmentProcessParam*>(p->ptr), ns1__EquipmentProcessParam);
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__EquipmentProductProcessParam*>(p->ptr), ns1__EquipmentProductProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__EquipmentProductProcessParam*>(p->ptr), ns1__EquipmentProductProcessParam);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada*>(p->ptr), ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada*>(p->ptr), ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada);
		break;
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseSFCForScada*>(p->ptr), ns1__ApiResponseSFCForScada);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseSFCForScada*>(p->ptr), ns1__ApiResponseSFCForScada);
		break;
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ExamineExistsByScadaDTO*>(p->ptr), ns1__ExamineExistsByScadaDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ExamineExistsByScadaDTO*>(p->ptr), ns1__ExamineExistsByScadaDTO);
		break;
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FeedingByScadaDTO*>(p->ptr), ns1__FeedingByScadaDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FeedingByScadaDTO*>(p->ptr), ns1__FeedingByScadaDTO);
		break;
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FeedingDJInLaminatingByScadaDTO*>(p->ptr), ns1__FeedingDJInLaminatingByScadaDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FeedingDJInLaminatingByScadaDTO*>(p->ptr), ns1__FeedingDJInLaminatingByScadaDTO);
		break;
	case SOAP_TYPE_ns1__FillingData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FillingData*>(p->ptr), ns1__FillingData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FillingData*>(p->ptr), ns1__FillingData);
		break;
	case SOAP_TYPE_ns1__GenerateCellSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenerateCellSFC*>(p->ptr), ns1__GenerateCellSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenerateCellSFC*>(p->ptr), ns1__GenerateCellSFC);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseDataForScadaOfString*>(p->ptr), ns1__ApiResponseDataForScadaOfString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseDataForScadaOfString*>(p->ptr), ns1__ApiResponseDataForScadaOfString);
		break;
	case SOAP_TYPE_ns1__Heartbeat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Heartbeat*>(p->ptr), ns1__Heartbeat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Heartbeat*>(p->ptr), ns1__Heartbeat);
		break;
	case SOAP_TYPE_ns1__Inbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Inbound*>(p->ptr), ns1__Inbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Inbound*>(p->ptr), ns1__Inbound);
		break;
	case SOAP_TYPE_ns1__InboundInContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InboundInContainer*>(p->ptr), ns1__InboundInContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InboundInContainer*>(p->ptr), ns1__InboundInContainer);
		break;
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InboundInSFCContainer*>(p->ptr), ns1__InboundInSFCContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InboundInSFCContainer*>(p->ptr), ns1__InboundInSFCContainer);
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InboundInTwoInjection*>(p->ptr), ns1__InboundInTwoInjection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InboundInTwoInjection*>(p->ptr), ns1__InboundInTwoInjection);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu);
		break;
	case SOAP_TYPE_ns1__InboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InboundMore*>(p->ptr), ns1__InboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InboundMore*>(p->ptr), ns1__InboundMore);
		break;
	case SOAP_TYPE_ns1__OperatorLogin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OperatorLogin*>(p->ptr), ns1__OperatorLogin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OperatorLogin*>(p->ptr), ns1__OperatorLogin);
		break;
	case SOAP_TYPE_ns1__Outbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Outbound*>(p->ptr), ns1__Outbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Outbound*>(p->ptr), ns1__Outbound);
		break;
	case SOAP_TYPE_ns1__OutboundInLaminating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OutboundInLaminating*>(p->ptr), ns1__OutboundInLaminating);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OutboundInLaminating*>(p->ptr), ns1__OutboundInLaminating);
		break;
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OutboundInSFCOutputQty*>(p->ptr), ns1__OutboundInSFCOutputQty);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OutboundInSFCOutputQty*>(p->ptr), ns1__OutboundInSFCOutputQty);
		break;
	case SOAP_TYPE_ns1__OutboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OutboundMore*>(p->ptr), ns1__OutboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OutboundMore*>(p->ptr), ns1__OutboundMore);
		break;
	case SOAP_TYPE_ns1__Recipe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Recipe*>(p->ptr), ns1__Recipe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Recipe*>(p->ptr), ns1__Recipe);
		break;
	case SOAP_TYPE_ns1__RecipeGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeGet*>(p->ptr), ns1__RecipeGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeGet*>(p->ptr), ns1__RecipeGet);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseDataForScadaOfRecipeGetForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfRecipeGetForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseDataForScadaOfRecipeGetForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfRecipeGetForEqu);
		break;
	case SOAP_TYPE_ns1__RecipeListGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeListGet*>(p->ptr), ns1__RecipeListGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeListGet*>(p->ptr), ns1__RecipeListGet);
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu*>(p->ptr), ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu);
		break;
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RecipeVersionExamine*>(p->ptr), ns1__RecipeVersionExamine);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RecipeVersionExamine*>(p->ptr), ns1__RecipeVersionExamine);
		break;
	case SOAP_TYPE_ns1__State:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__State*>(p->ptr), ns1__State);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__State*>(p->ptr), ns1__State);
		break;
	case SOAP_TYPE_ns1__ToolBind:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ToolBind*>(p->ptr), ns1__ToolBind);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ToolBind*>(p->ptr), ns1__ToolBind);
		break;
	case SOAP_TYPE_ns1__ToolLife:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ToolLife*>(p->ptr), ns1__ToolLife);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ToolLife*>(p->ptr), ns1__ToolLife);
		break;
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__UnBindSFCByScadaDTO*>(p->ptr), ns1__UnBindSFCByScadaDTO);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__UnBindSFCByScadaDTO*>(p->ptr), ns1__UnBindSFCByScadaDTO);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
	case SOAP_TYPE___ns1__Alarm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Alarm*>(p->ptr), struct __ns1__Alarm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Alarm*>(p->ptr), struct __ns1__Alarm);
		break;
	case SOAP_TYPE___ns1__Alarm_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Alarm_*>(p->ptr), struct __ns1__Alarm_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Alarm_*>(p->ptr), struct __ns1__Alarm_);
		break;
	case SOAP_TYPE___ns1__BindContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindContainer*>(p->ptr), struct __ns1__BindContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindContainer*>(p->ptr), struct __ns1__BindContainer);
		break;
	case SOAP_TYPE___ns1__BindContainer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindContainer_*>(p->ptr), struct __ns1__BindContainer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindContainer_*>(p->ptr), struct __ns1__BindContainer_);
		break;
	case SOAP_TYPE___ns1__BindSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindSFC*>(p->ptr), struct __ns1__BindSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindSFC*>(p->ptr), struct __ns1__BindSFC);
		break;
	case SOAP_TYPE___ns1__BindSFC_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindSFC_*>(p->ptr), struct __ns1__BindSFC_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindSFC_*>(p->ptr), struct __ns1__BindSFC_);
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CCDFileUploadComplete*>(p->ptr), struct __ns1__CCDFileUploadComplete);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CCDFileUploadComplete*>(p->ptr), struct __ns1__CCDFileUploadComplete);
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CCDFileUploadComplete_*>(p->ptr), struct __ns1__CCDFileUploadComplete_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CCDFileUploadComplete_*>(p->ptr), struct __ns1__CCDFileUploadComplete_);
		break;
	case SOAP_TYPE___ns1__DownReason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownReason*>(p->ptr), struct __ns1__DownReason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownReason*>(p->ptr), struct __ns1__DownReason);
		break;
	case SOAP_TYPE___ns1__DownReason_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownReason_*>(p->ptr), struct __ns1__DownReason_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownReason_*>(p->ptr), struct __ns1__DownReason_);
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EquipmentProcessParam*>(p->ptr), struct __ns1__EquipmentProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EquipmentProcessParam*>(p->ptr), struct __ns1__EquipmentProcessParam);
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EquipmentProcessParam_*>(p->ptr), struct __ns1__EquipmentProcessParam_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EquipmentProcessParam_*>(p->ptr), struct __ns1__EquipmentProcessParam_);
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EquipmentProductProcessParam*>(p->ptr), struct __ns1__EquipmentProductProcessParam);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EquipmentProductProcessParam*>(p->ptr), struct __ns1__EquipmentProductProcessParam);
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EquipmentProductProcessParam_*>(p->ptr), struct __ns1__EquipmentProductProcessParam_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EquipmentProductProcessParam_*>(p->ptr), struct __ns1__EquipmentProductProcessParam_);
		break;
	case SOAP_TYPE___ns1__ExamineExists:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExamineExists*>(p->ptr), struct __ns1__ExamineExists);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExamineExists*>(p->ptr), struct __ns1__ExamineExists);
		break;
	case SOAP_TYPE___ns1__ExamineExists_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExamineExists_*>(p->ptr), struct __ns1__ExamineExists_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExamineExists_*>(p->ptr), struct __ns1__ExamineExists_);
		break;
	case SOAP_TYPE___ns1__Feeding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Feeding*>(p->ptr), struct __ns1__Feeding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Feeding*>(p->ptr), struct __ns1__Feeding);
		break;
	case SOAP_TYPE___ns1__Feeding_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Feeding_*>(p->ptr), struct __ns1__Feeding_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Feeding_*>(p->ptr), struct __ns1__Feeding_);
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FeedingDJInLaminating*>(p->ptr), struct __ns1__FeedingDJInLaminating);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FeedingDJInLaminating*>(p->ptr), struct __ns1__FeedingDJInLaminating);
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FeedingDJInLaminating_*>(p->ptr), struct __ns1__FeedingDJInLaminating_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FeedingDJInLaminating_*>(p->ptr), struct __ns1__FeedingDJInLaminating_);
		break;
	case SOAP_TYPE___ns1__FillingData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FillingData*>(p->ptr), struct __ns1__FillingData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FillingData*>(p->ptr), struct __ns1__FillingData);
		break;
	case SOAP_TYPE___ns1__FillingData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FillingData_*>(p->ptr), struct __ns1__FillingData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FillingData_*>(p->ptr), struct __ns1__FillingData_);
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GenerateCellSFC*>(p->ptr), struct __ns1__GenerateCellSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GenerateCellSFC*>(p->ptr), struct __ns1__GenerateCellSFC);
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GenerateCellSFC_*>(p->ptr), struct __ns1__GenerateCellSFC_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GenerateCellSFC_*>(p->ptr), struct __ns1__GenerateCellSFC_);
		break;
	case SOAP_TYPE___ns1__Heartbeat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Heartbeat*>(p->ptr), struct __ns1__Heartbeat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Heartbeat*>(p->ptr), struct __ns1__Heartbeat);
		break;
	case SOAP_TYPE___ns1__Heartbeat_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Heartbeat_*>(p->ptr), struct __ns1__Heartbeat_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Heartbeat_*>(p->ptr), struct __ns1__Heartbeat_);
		break;
	case SOAP_TYPE___ns1__Inbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Inbound*>(p->ptr), struct __ns1__Inbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Inbound*>(p->ptr), struct __ns1__Inbound);
		break;
	case SOAP_TYPE___ns1__Inbound_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Inbound_*>(p->ptr), struct __ns1__Inbound_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Inbound_*>(p->ptr), struct __ns1__Inbound_);
		break;
	case SOAP_TYPE___ns1__InboundInContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInContainer*>(p->ptr), struct __ns1__InboundInContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInContainer*>(p->ptr), struct __ns1__InboundInContainer);
		break;
	case SOAP_TYPE___ns1__InboundInContainer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInContainer_*>(p->ptr), struct __ns1__InboundInContainer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInContainer_*>(p->ptr), struct __ns1__InboundInContainer_);
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInSFCContainer*>(p->ptr), struct __ns1__InboundInSFCContainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInSFCContainer*>(p->ptr), struct __ns1__InboundInSFCContainer);
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInSFCContainer_*>(p->ptr), struct __ns1__InboundInSFCContainer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInSFCContainer_*>(p->ptr), struct __ns1__InboundInSFCContainer_);
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInTwoInjection*>(p->ptr), struct __ns1__InboundInTwoInjection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInTwoInjection*>(p->ptr), struct __ns1__InboundInTwoInjection);
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundInTwoInjection_*>(p->ptr), struct __ns1__InboundInTwoInjection_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundInTwoInjection_*>(p->ptr), struct __ns1__InboundInTwoInjection_);
		break;
	case SOAP_TYPE___ns1__InboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundMore*>(p->ptr), struct __ns1__InboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundMore*>(p->ptr), struct __ns1__InboundMore);
		break;
	case SOAP_TYPE___ns1__InboundMore_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InboundMore_*>(p->ptr), struct __ns1__InboundMore_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InboundMore_*>(p->ptr), struct __ns1__InboundMore_);
		break;
	case SOAP_TYPE___ns1__OperatorLogin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OperatorLogin*>(p->ptr), struct __ns1__OperatorLogin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OperatorLogin*>(p->ptr), struct __ns1__OperatorLogin);
		break;
	case SOAP_TYPE___ns1__OperatorLogin_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OperatorLogin_*>(p->ptr), struct __ns1__OperatorLogin_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OperatorLogin_*>(p->ptr), struct __ns1__OperatorLogin_);
		break;
	case SOAP_TYPE___ns1__Outbound:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Outbound*>(p->ptr), struct __ns1__Outbound);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Outbound*>(p->ptr), struct __ns1__Outbound);
		break;
	case SOAP_TYPE___ns1__Outbound_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Outbound_*>(p->ptr), struct __ns1__Outbound_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Outbound_*>(p->ptr), struct __ns1__Outbound_);
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundInLaminating*>(p->ptr), struct __ns1__OutboundInLaminating);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundInLaminating*>(p->ptr), struct __ns1__OutboundInLaminating);
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundInLaminating_*>(p->ptr), struct __ns1__OutboundInLaminating_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundInLaminating_*>(p->ptr), struct __ns1__OutboundInLaminating_);
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundInSFCOutputQty*>(p->ptr), struct __ns1__OutboundInSFCOutputQty);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundInSFCOutputQty*>(p->ptr), struct __ns1__OutboundInSFCOutputQty);
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundInSFCOutputQty_*>(p->ptr), struct __ns1__OutboundInSFCOutputQty_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundInSFCOutputQty_*>(p->ptr), struct __ns1__OutboundInSFCOutputQty_);
		break;
	case SOAP_TYPE___ns1__OutboundMore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundMore*>(p->ptr), struct __ns1__OutboundMore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundMore*>(p->ptr), struct __ns1__OutboundMore);
		break;
	case SOAP_TYPE___ns1__OutboundMore_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OutboundMore_*>(p->ptr), struct __ns1__OutboundMore_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OutboundMore_*>(p->ptr), struct __ns1__OutboundMore_);
		break;
	case SOAP_TYPE___ns1__Recipe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Recipe*>(p->ptr), struct __ns1__Recipe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Recipe*>(p->ptr), struct __ns1__Recipe);
		break;
	case SOAP_TYPE___ns1__Recipe_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Recipe_*>(p->ptr), struct __ns1__Recipe_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Recipe_*>(p->ptr), struct __ns1__Recipe_);
		break;
	case SOAP_TYPE___ns1__GetRecipe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRecipe*>(p->ptr), struct __ns1__GetRecipe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRecipe*>(p->ptr), struct __ns1__GetRecipe);
		break;
	case SOAP_TYPE___ns1__GetRecipe_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRecipe_*>(p->ptr), struct __ns1__GetRecipe_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRecipe_*>(p->ptr), struct __ns1__GetRecipe_);
		break;
	case SOAP_TYPE___ns1__GetRecipeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRecipeList*>(p->ptr), struct __ns1__GetRecipeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRecipeList*>(p->ptr), struct __ns1__GetRecipeList);
		break;
	case SOAP_TYPE___ns1__GetRecipeList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRecipeList_*>(p->ptr), struct __ns1__GetRecipeList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRecipeList_*>(p->ptr), struct __ns1__GetRecipeList_);
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__RecipeVersionExamine*>(p->ptr), struct __ns1__RecipeVersionExamine);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__RecipeVersionExamine*>(p->ptr), struct __ns1__RecipeVersionExamine);
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__RecipeVersionExamine_*>(p->ptr), struct __ns1__RecipeVersionExamine_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__RecipeVersionExamine_*>(p->ptr), struct __ns1__RecipeVersionExamine_);
		break;
	case SOAP_TYPE___ns1__State:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__State*>(p->ptr), struct __ns1__State);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__State*>(p->ptr), struct __ns1__State);
		break;
	case SOAP_TYPE___ns1__State_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__State_*>(p->ptr), struct __ns1__State_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__State_*>(p->ptr), struct __ns1__State_);
		break;
	case SOAP_TYPE___ns1__ToolBind:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ToolBind*>(p->ptr), struct __ns1__ToolBind);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ToolBind*>(p->ptr), struct __ns1__ToolBind);
		break;
	case SOAP_TYPE___ns1__ToolBind_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ToolBind_*>(p->ptr), struct __ns1__ToolBind_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ToolBind_*>(p->ptr), struct __ns1__ToolBind_);
		break;
	case SOAP_TYPE___ns1__ToolLife:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ToolLife*>(p->ptr), struct __ns1__ToolLife);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ToolLife*>(p->ptr), struct __ns1__ToolLife);
		break;
	case SOAP_TYPE___ns1__ToolLife_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ToolLife_*>(p->ptr), struct __ns1__ToolLife_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ToolLife_*>(p->ptr), struct __ns1__ToolLife_);
		break;
	case SOAP_TYPE___ns1__UnBindSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UnBindSFC*>(p->ptr), struct __ns1__UnBindSFC);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UnBindSFC*>(p->ptr), struct __ns1__UnBindSFC);
		break;
	case SOAP_TYPE___ns1__UnBindSFC_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UnBindSFC_*>(p->ptr), struct __ns1__UnBindSFC_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UnBindSFC_*>(p->ptr), struct __ns1__UnBindSFC_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::wstring*>(p->ptr), std::wstring);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::wstring*>(p->ptr), std::wstring);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RecipeListGetForEqu *> *>(p->ptr), std::vector<ns1__RecipeListGetForEqu *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RecipeListGetForEqu *> *>(p->ptr), std::vector<ns1__RecipeListGetForEqu *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RecipeGetParamForEqu *> *>(p->ptr), std::vector<ns1__RecipeGetParamForEqu *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RecipeGetParamForEqu *> *>(p->ptr), std::vector<ns1__RecipeGetParamForEqu *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__RecipeParam *> *>(p->ptr), std::vector<ns1__RecipeParam *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__RecipeParam *> *>(p->ptr), std::vector<ns1__RecipeParam *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__OutboundSFC *> *>(p->ptr), std::vector<ns1__OutboundSFC *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__OutboundSFC *> *>(p->ptr), std::vector<ns1__OutboundSFC *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ApiResponseSFCForScada *> *>(p->ptr), std::vector<ns1__ApiResponseSFCForScada *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ApiResponseSFCForScada *> *>(p->ptr), std::vector<ns1__ApiResponseSFCForScada *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__EquipmentProductProcessParamSFC *> *>(p->ptr), std::vector<ns1__EquipmentProductProcessParamSFC *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__EquipmentProductProcessParamSFC *> *>(p->ptr), std::vector<ns1__EquipmentProductProcessParamSFC *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ParamDTO *> *>(p->ptr), std::vector<ns1__ParamDTO *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ParamDTO *> *>(p->ptr), std::vector<ns1__ParamDTO *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DownReason *> *>(p->ptr), std::vector<ns1__DownReason *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DownReason *> *>(p->ptr), std::vector<ns1__DownReason *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__CCDFileUploadCompleteSFC *> *>(p->ptr), std::vector<ns1__CCDFileUploadCompleteSFC *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__CCDFileUploadCompleteSFC *> *>(p->ptr), std::vector<ns1__CCDFileUploadCompleteSFC *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::wstring> *>(p->ptr), std::vector<std::wstring> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::wstring> *>(p->ptr), std::vector<std::wstring> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__BindContainerSFC *> *>(p->ptr), std::vector<ns1__BindContainerSFC *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__BindContainerSFC *> *>(p->ptr), std::vector<ns1__BindContainerSFC *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Alarm *> *>(p->ptr), std::vector<ns1__Alarm *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Alarm *> *>(p->ptr), std::vector<ns1__Alarm *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_ns1__Alarm: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseForScada: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__BindContainer: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__BindSFCByScadaDTO: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__CCDFileUploadComplete: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__DownReason: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__EquipmentProcessParam: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__EquipmentProductProcessParam: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__ApiResponseSFCForScada: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__ExamineExistsByScadaDTO: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__FeedingByScadaDTO: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__FillingData: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__GenerateCellSFC: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__Heartbeat: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__Inbound: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__InboundInContainer: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__InboundInSFCContainer: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__InboundInTwoInjection: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__InboundMore: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__OperatorLogin: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__Outbound: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__OutboundInLaminating: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__OutboundInSFCOutputQty: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__OutboundMore: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__Recipe: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__RecipeGet: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__RecipeListGet: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu: t = SOAP_TYPE_ns1__BaseApiResponseForScada; break;
		case SOAP_TYPE_ns1__RecipeVersionExamine: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__State: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ToolBind: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__ToolLife: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		case SOAP_TYPE_ns1__UnBindSFCByScadaDTO: t = SOAP_TYPE_ns1__BaseApiRequestByScada; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu:
		if (t == SOAP_TYPE_ns1__RecipeListGetForEqu || soap_fbase(t, SOAP_TYPE_ns1__RecipeListGetForEqu))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RecipeListGetForEqu *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RecipeListGetForEqu *> *)p)[index] = *(ns1__RecipeListGetForEqu **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu:
		if (t == SOAP_TYPE_ns1__RecipeGetParamForEqu || soap_fbase(t, SOAP_TYPE_ns1__RecipeGetParamForEqu))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RecipeGetParamForEqu *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RecipeGetParamForEqu *> *)p)[index] = *(ns1__RecipeGetParamForEqu **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam:
		if (t == SOAP_TYPE_ns1__RecipeParam || soap_fbase(t, SOAP_TYPE_ns1__RecipeParam))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__RecipeParam *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__RecipeParam *> *)p)[index] = *(ns1__RecipeParam **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC:
		if (t == SOAP_TYPE_ns1__OutboundSFC || soap_fbase(t, SOAP_TYPE_ns1__OutboundSFC))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__OutboundSFC *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__OutboundSFC *> *)p)[index] = *(ns1__OutboundSFC **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada:
		if (t == SOAP_TYPE_ns1__ApiResponseSFCForScada || soap_fbase(t, SOAP_TYPE_ns1__ApiResponseSFCForScada))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ApiResponseSFCForScada *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ApiResponseSFCForScada *> *)p)[index] = *(ns1__ApiResponseSFCForScada **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC:
		if (t == SOAP_TYPE_ns1__EquipmentProductProcessParamSFC || soap_fbase(t, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__EquipmentProductProcessParamSFC *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__EquipmentProductProcessParamSFC *> *)p)[index] = *(ns1__EquipmentProductProcessParamSFC **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO:
		if (t == SOAP_TYPE_ns1__ParamDTO || soap_fbase(t, SOAP_TYPE_ns1__ParamDTO))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ParamDTO *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ParamDTO *> *)p)[index] = *(ns1__ParamDTO **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason:
		if (t == SOAP_TYPE_ns1__DownReason || soap_fbase(t, SOAP_TYPE_ns1__DownReason))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DownReason *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DownReason *> *)p)[index] = *(ns1__DownReason **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC:
		if (t == SOAP_TYPE_ns1__CCDFileUploadCompleteSFC || soap_fbase(t, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__CCDFileUploadCompleteSFC *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__CCDFileUploadCompleteSFC *> *)p)[index] = *(ns1__CCDFileUploadCompleteSFC **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		if (t == SOAP_TYPE_std__wstring)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::wstring>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::wstring> *)p)[index] = *(std::wstring *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC:
		if (t == SOAP_TYPE_ns1__BindContainerSFC || soap_fbase(t, SOAP_TYPE_ns1__BindContainerSFC))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__BindContainerSFC *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__BindContainerSFC *> *)p)[index] = *(ns1__BindContainerSFC **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm:
		if (t == SOAP_TYPE_ns1__Alarm || soap_fbase(t, SOAP_TYPE_ns1__Alarm))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Alarm *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Alarm *> *)p)[index] = *(ns1__Alarm **)q;
		}
		break;
	case SOAP_TYPE_std__wstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfAlarm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfAlarm type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfAlarm*)p = *(ns1__ArrayOfAlarm*)q;
		break;
	case SOAP_TYPE_ns1__BaseApiRequestByScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BaseApiRequestByScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BaseApiRequestByScada*)p = *(ns1__BaseApiRequestByScada*)q;
		break;
	case SOAP_TYPE_ns1__BaseApiResponseForScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BaseApiResponseForScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BaseApiResponseForScada*)p = *(ns1__BaseApiResponseForScada*)q;
		break;
	case SOAP_TYPE_ns1__LoginSoapHeader:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LoginSoapHeader type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LoginSoapHeader*)p = *(ns1__LoginSoapHeader*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfBindContainerSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfBindContainerSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfBindContainerSFC*)p = *(ns1__ArrayOfBindContainerSFC*)q;
		break;
	case SOAP_TYPE_ns1__BindContainerSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BindContainerSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BindContainerSFC*)p = *(ns1__BindContainerSFC*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfString type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfCCDFileUploadCompleteSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfCCDFileUploadCompleteSFC*)p = *(ns1__ArrayOfCCDFileUploadCompleteSFC*)q;
		break;
	case SOAP_TYPE_ns1__CCDFileUploadCompleteSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCDFileUploadCompleteSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCDFileUploadCompleteSFC*)p = *(ns1__CCDFileUploadCompleteSFC*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfDownReason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfDownReason type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfDownReason*)p = *(ns1__ArrayOfDownReason*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfParamDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfParamDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfParamDTO*)p = *(ns1__ArrayOfParamDTO*)q;
		break;
	case SOAP_TYPE_ns1__ParamDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ParamDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ParamDTO*)p = *(ns1__ParamDTO*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfEquipmentProductProcessParamSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfEquipmentProductProcessParamSFC*)p = *(ns1__ArrayOfEquipmentProductProcessParamSFC*)q;
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParamSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__EquipmentProductProcessParamSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__EquipmentProductProcessParamSFC*)p = *(ns1__EquipmentProductProcessParamSFC*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfApiResponseSFCForScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfApiResponseSFCForScada*)p = *(ns1__ArrayOfApiResponseSFCForScada*)q;
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjectionForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InboundInTwoInjectionForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InboundInTwoInjectionForEqu*)p = *(ns1__InboundInTwoInjectionForEqu*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfOutboundSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfOutboundSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfOutboundSFC*)p = *(ns1__ArrayOfOutboundSFC*)q;
		break;
	case SOAP_TYPE_ns1__OutboundSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OutboundSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OutboundSFC*)p = *(ns1__OutboundSFC*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfRecipeParam type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfRecipeParam*)p = *(ns1__ArrayOfRecipeParam*)q;
		break;
	case SOAP_TYPE_ns1__RecipeParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeParam type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeParam*)p = *(ns1__RecipeParam*)q;
		break;
	case SOAP_TYPE_ns1__RecipeGetForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeGetForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeGetForEqu*)p = *(ns1__RecipeGetForEqu*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfRecipeGetParamForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfRecipeGetParamForEqu*)p = *(ns1__ArrayOfRecipeGetParamForEqu*)q;
		break;
	case SOAP_TYPE_ns1__RecipeGetParamForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeGetParamForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeGetParamForEqu*)p = *(ns1__RecipeGetParamForEqu*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfRecipeListGetForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfRecipeListGetForEqu*)p = *(ns1__ArrayOfRecipeListGetForEqu*)q;
		break;
	case SOAP_TYPE_ns1__RecipeListGetForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeListGetForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeListGetForEqu*)p = *(ns1__RecipeListGetForEqu*)q;
		break;
	case SOAP_TYPE__ns1__Alarm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Alarm type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Alarm*)p = *(_ns1__Alarm*)q;
		break;
	case SOAP_TYPE__ns1__AlarmResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AlarmResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AlarmResponse*)p = *(_ns1__AlarmResponse*)q;
		break;
	case SOAP_TYPE__ns1__BindContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindContainer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindContainer*)p = *(_ns1__BindContainer*)q;
		break;
	case SOAP_TYPE__ns1__BindContainerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindContainerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindContainerResponse*)p = *(_ns1__BindContainerResponse*)q;
		break;
	case SOAP_TYPE__ns1__BindSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindSFC type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindSFC*)p = *(_ns1__BindSFC*)q;
		break;
	case SOAP_TYPE__ns1__BindSFCResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindSFCResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindSFCResponse*)p = *(_ns1__BindSFCResponse*)q;
		break;
	case SOAP_TYPE__ns1__CCDFileUploadComplete:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CCDFileUploadComplete type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CCDFileUploadComplete*)p = *(_ns1__CCDFileUploadComplete*)q;
		break;
	case SOAP_TYPE__ns1__CCDFileUploadCompleteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CCDFileUploadCompleteResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CCDFileUploadCompleteResponse*)p = *(_ns1__CCDFileUploadCompleteResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownReason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownReason type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownReason*)p = *(_ns1__DownReason*)q;
		break;
	case SOAP_TYPE__ns1__DownReasonResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownReasonResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownReasonResponse*)p = *(_ns1__DownReasonResponse*)q;
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EquipmentProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EquipmentProcessParam*)p = *(_ns1__EquipmentProcessParam*)q;
		break;
	case SOAP_TYPE__ns1__EquipmentProcessParamResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EquipmentProcessParamResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EquipmentProcessParamResponse*)p = *(_ns1__EquipmentProcessParamResponse*)q;
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EquipmentProductProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EquipmentProductProcessParam*)p = *(_ns1__EquipmentProductProcessParam*)q;
		break;
	case SOAP_TYPE__ns1__EquipmentProductProcessParamResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EquipmentProductProcessParamResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EquipmentProductProcessParamResponse*)p = *(_ns1__EquipmentProductProcessParamResponse*)q;
		break;
	case SOAP_TYPE__ns1__ExamineExists:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExamineExists type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExamineExists*)p = *(_ns1__ExamineExists*)q;
		break;
	case SOAP_TYPE__ns1__ExamineExistsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExamineExistsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExamineExistsResponse*)p = *(_ns1__ExamineExistsResponse*)q;
		break;
	case SOAP_TYPE__ns1__Feeding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Feeding type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Feeding*)p = *(_ns1__Feeding*)q;
		break;
	case SOAP_TYPE__ns1__FeedingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FeedingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FeedingResponse*)p = *(_ns1__FeedingResponse*)q;
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FeedingDJInLaminating type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FeedingDJInLaminating*)p = *(_ns1__FeedingDJInLaminating*)q;
		break;
	case SOAP_TYPE__ns1__FeedingDJInLaminatingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FeedingDJInLaminatingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FeedingDJInLaminatingResponse*)p = *(_ns1__FeedingDJInLaminatingResponse*)q;
		break;
	case SOAP_TYPE__ns1__FillingData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FillingData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FillingData*)p = *(_ns1__FillingData*)q;
		break;
	case SOAP_TYPE__ns1__FillingDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FillingDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FillingDataResponse*)p = *(_ns1__FillingDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GenerateCellSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GenerateCellSFC type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GenerateCellSFC*)p = *(_ns1__GenerateCellSFC*)q;
		break;
	case SOAP_TYPE__ns1__GenerateCellSFCResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GenerateCellSFCResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GenerateCellSFCResponse*)p = *(_ns1__GenerateCellSFCResponse*)q;
		break;
	case SOAP_TYPE__ns1__Heartbeat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Heartbeat type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Heartbeat*)p = *(_ns1__Heartbeat*)q;
		break;
	case SOAP_TYPE__ns1__HeartbeatResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HeartbeatResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HeartbeatResponse*)p = *(_ns1__HeartbeatResponse*)q;
		break;
	case SOAP_TYPE__ns1__Inbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Inbound type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Inbound*)p = *(_ns1__Inbound*)q;
		break;
	case SOAP_TYPE__ns1__InboundResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundResponse*)p = *(_ns1__InboundResponse*)q;
		break;
	case SOAP_TYPE__ns1__InboundInContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInContainer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInContainer*)p = *(_ns1__InboundInContainer*)q;
		break;
	case SOAP_TYPE__ns1__InboundInContainerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInContainerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInContainerResponse*)p = *(_ns1__InboundInContainerResponse*)q;
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInSFCContainer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInSFCContainer*)p = *(_ns1__InboundInSFCContainer*)q;
		break;
	case SOAP_TYPE__ns1__InboundInSFCContainerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInSFCContainerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInSFCContainerResponse*)p = *(_ns1__InboundInSFCContainerResponse*)q;
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInTwoInjection type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInTwoInjection*)p = *(_ns1__InboundInTwoInjection*)q;
		break;
	case SOAP_TYPE__ns1__InboundInTwoInjectionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundInTwoInjectionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundInTwoInjectionResponse*)p = *(_ns1__InboundInTwoInjectionResponse*)q;
		break;
	case SOAP_TYPE__ns1__InboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundMore type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundMore*)p = *(_ns1__InboundMore*)q;
		break;
	case SOAP_TYPE__ns1__InboundMoreResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InboundMoreResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InboundMoreResponse*)p = *(_ns1__InboundMoreResponse*)q;
		break;
	case SOAP_TYPE__ns1__OperatorLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OperatorLogin type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OperatorLogin*)p = *(_ns1__OperatorLogin*)q;
		break;
	case SOAP_TYPE__ns1__OperatorLoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OperatorLoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OperatorLoginResponse*)p = *(_ns1__OperatorLoginResponse*)q;
		break;
	case SOAP_TYPE__ns1__Outbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Outbound type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Outbound*)p = *(_ns1__Outbound*)q;
		break;
	case SOAP_TYPE__ns1__OutboundResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundResponse*)p = *(_ns1__OutboundResponse*)q;
		break;
	case SOAP_TYPE__ns1__OutboundInLaminating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundInLaminating type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundInLaminating*)p = *(_ns1__OutboundInLaminating*)q;
		break;
	case SOAP_TYPE__ns1__OutboundInLaminatingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundInLaminatingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundInLaminatingResponse*)p = *(_ns1__OutboundInLaminatingResponse*)q;
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundInSFCOutputQty type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundInSFCOutputQty*)p = *(_ns1__OutboundInSFCOutputQty*)q;
		break;
	case SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundInSFCOutputQtyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundInSFCOutputQtyResponse*)p = *(_ns1__OutboundInSFCOutputQtyResponse*)q;
		break;
	case SOAP_TYPE__ns1__OutboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundMore type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundMore*)p = *(_ns1__OutboundMore*)q;
		break;
	case SOAP_TYPE__ns1__OutboundMoreResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutboundMoreResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutboundMoreResponse*)p = *(_ns1__OutboundMoreResponse*)q;
		break;
	case SOAP_TYPE__ns1__Recipe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Recipe type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Recipe*)p = *(_ns1__Recipe*)q;
		break;
	case SOAP_TYPE__ns1__RecipeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RecipeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RecipeResponse*)p = *(_ns1__RecipeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRecipe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecipe type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecipe*)p = *(_ns1__GetRecipe*)q;
		break;
	case SOAP_TYPE__ns1__GetRecipeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecipeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecipeResponse*)p = *(_ns1__GetRecipeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRecipeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecipeList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecipeList*)p = *(_ns1__GetRecipeList*)q;
		break;
	case SOAP_TYPE__ns1__GetRecipeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecipeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecipeListResponse*)p = *(_ns1__GetRecipeListResponse*)q;
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RecipeVersionExamine type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RecipeVersionExamine*)p = *(_ns1__RecipeVersionExamine*)q;
		break;
	case SOAP_TYPE__ns1__RecipeVersionExamineResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RecipeVersionExamineResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RecipeVersionExamineResponse*)p = *(_ns1__RecipeVersionExamineResponse*)q;
		break;
	case SOAP_TYPE__ns1__State:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__State type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__State*)p = *(_ns1__State*)q;
		break;
	case SOAP_TYPE__ns1__StateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StateResponse*)p = *(_ns1__StateResponse*)q;
		break;
	case SOAP_TYPE__ns1__ToolBind:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ToolBind type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ToolBind*)p = *(_ns1__ToolBind*)q;
		break;
	case SOAP_TYPE__ns1__ToolBindResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ToolBindResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ToolBindResponse*)p = *(_ns1__ToolBindResponse*)q;
		break;
	case SOAP_TYPE__ns1__ToolLife:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ToolLife type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ToolLife*)p = *(_ns1__ToolLife*)q;
		break;
	case SOAP_TYPE__ns1__ToolLifeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ToolLifeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ToolLifeResponse*)p = *(_ns1__ToolLifeResponse*)q;
		break;
	case SOAP_TYPE__ns1__UnBindSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnBindSFC type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnBindSFC*)p = *(_ns1__UnBindSFC*)q;
		break;
	case SOAP_TYPE__ns1__UnBindSFCResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnBindSFCResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnBindSFCResponse*)p = *(_ns1__UnBindSFCResponse*)q;
		break;
	case SOAP_TYPE_ns1__Alarm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Alarm type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Alarm*)p = *(ns1__Alarm*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseForScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseForScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseForScada*)p = *(ns1__ApiResponseForScada*)q;
		break;
	case SOAP_TYPE_ns1__BindContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BindContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BindContainer*)p = *(ns1__BindContainer*)q;
		break;
	case SOAP_TYPE_ns1__BindSFCByScadaDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BindSFCByScadaDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BindSFCByScadaDTO*)p = *(ns1__BindSFCByScadaDTO*)q;
		break;
	case SOAP_TYPE_ns1__CCDFileUploadComplete:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCDFileUploadComplete type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCDFileUploadComplete*)p = *(ns1__CCDFileUploadComplete*)q;
		break;
	case SOAP_TYPE_ns1__DownReason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DownReason type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DownReason*)p = *(ns1__DownReason*)q;
		break;
	case SOAP_TYPE_ns1__EquipmentProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__EquipmentProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(ns1__EquipmentProcessParam*)p = *(ns1__EquipmentProcessParam*)q;
		break;
	case SOAP_TYPE_ns1__EquipmentProductProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__EquipmentProductProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(ns1__EquipmentProductProcessParam*)p = *(ns1__EquipmentProductProcessParam*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada*)p = *(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseSFCForScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseSFCForScada type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseSFCForScada*)p = *(ns1__ApiResponseSFCForScada*)q;
		break;
	case SOAP_TYPE_ns1__ExamineExistsByScadaDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ExamineExistsByScadaDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ExamineExistsByScadaDTO*)p = *(ns1__ExamineExistsByScadaDTO*)q;
		break;
	case SOAP_TYPE_ns1__FeedingByScadaDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FeedingByScadaDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FeedingByScadaDTO*)p = *(ns1__FeedingByScadaDTO*)q;
		break;
	case SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FeedingDJInLaminatingByScadaDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FeedingDJInLaminatingByScadaDTO*)p = *(ns1__FeedingDJInLaminatingByScadaDTO*)q;
		break;
	case SOAP_TYPE_ns1__FillingData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FillingData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FillingData*)p = *(ns1__FillingData*)q;
		break;
	case SOAP_TYPE_ns1__GenerateCellSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenerateCellSFC type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenerateCellSFC*)p = *(ns1__GenerateCellSFC*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseDataForScadaOfString type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseDataForScadaOfString*)p = *(ns1__ApiResponseDataForScadaOfString*)q;
		break;
	case SOAP_TYPE_ns1__Heartbeat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Heartbeat type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Heartbeat*)p = *(ns1__Heartbeat*)q;
		break;
	case SOAP_TYPE_ns1__Inbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Inbound type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Inbound*)p = *(ns1__Inbound*)q;
		break;
	case SOAP_TYPE_ns1__InboundInContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InboundInContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InboundInContainer*)p = *(ns1__InboundInContainer*)q;
		break;
	case SOAP_TYPE_ns1__InboundInSFCContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InboundInSFCContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InboundInSFCContainer*)p = *(ns1__InboundInSFCContainer*)q;
		break;
	case SOAP_TYPE_ns1__InboundInTwoInjection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InboundInTwoInjection type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InboundInTwoInjection*)p = *(ns1__InboundInTwoInjection*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu*)p = *(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu*)q;
		break;
	case SOAP_TYPE_ns1__InboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InboundMore type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InboundMore*)p = *(ns1__InboundMore*)q;
		break;
	case SOAP_TYPE_ns1__OperatorLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OperatorLogin type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OperatorLogin*)p = *(ns1__OperatorLogin*)q;
		break;
	case SOAP_TYPE_ns1__Outbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Outbound type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Outbound*)p = *(ns1__Outbound*)q;
		break;
	case SOAP_TYPE_ns1__OutboundInLaminating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OutboundInLaminating type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OutboundInLaminating*)p = *(ns1__OutboundInLaminating*)q;
		break;
	case SOAP_TYPE_ns1__OutboundInSFCOutputQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OutboundInSFCOutputQty type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OutboundInSFCOutputQty*)p = *(ns1__OutboundInSFCOutputQty*)q;
		break;
	case SOAP_TYPE_ns1__OutboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OutboundMore type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OutboundMore*)p = *(ns1__OutboundMore*)q;
		break;
	case SOAP_TYPE_ns1__Recipe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Recipe type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Recipe*)p = *(ns1__Recipe*)q;
		break;
	case SOAP_TYPE_ns1__RecipeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeGet type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeGet*)p = *(ns1__RecipeGet*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseDataForScadaOfRecipeGetForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseDataForScadaOfRecipeGetForEqu*)p = *(ns1__ApiResponseDataForScadaOfRecipeGetForEqu*)q;
		break;
	case SOAP_TYPE_ns1__RecipeListGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeListGet type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeListGet*)p = *(ns1__RecipeListGet*)q;
		break;
	case SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu*)p = *(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu*)q;
		break;
	case SOAP_TYPE_ns1__RecipeVersionExamine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RecipeVersionExamine type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RecipeVersionExamine*)p = *(ns1__RecipeVersionExamine*)q;
		break;
	case SOAP_TYPE_ns1__State:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__State type=%d location=%p object=%p\n", t, p, q));
		*(ns1__State*)p = *(ns1__State*)q;
		break;
	case SOAP_TYPE_ns1__ToolBind:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ToolBind type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ToolBind*)p = *(ns1__ToolBind*)q;
		break;
	case SOAP_TYPE_ns1__ToolLife:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ToolLife type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ToolLife*)p = *(ns1__ToolLife*)q;
		break;
	case SOAP_TYPE_ns1__UnBindSFCByScadaDTO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__UnBindSFCByScadaDTO type=%d location=%p object=%p\n", t, p, q));
		*(ns1__UnBindSFCByScadaDTO*)p = *(ns1__UnBindSFCByScadaDTO*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
	case SOAP_TYPE___ns1__Alarm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Alarm type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Alarm*)p = *(struct __ns1__Alarm*)q;
		break;
	case SOAP_TYPE___ns1__Alarm_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Alarm_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Alarm_*)p = *(struct __ns1__Alarm_*)q;
		break;
	case SOAP_TYPE___ns1__BindContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindContainer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindContainer*)p = *(struct __ns1__BindContainer*)q;
		break;
	case SOAP_TYPE___ns1__BindContainer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindContainer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindContainer_*)p = *(struct __ns1__BindContainer_*)q;
		break;
	case SOAP_TYPE___ns1__BindSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindSFC type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindSFC*)p = *(struct __ns1__BindSFC*)q;
		break;
	case SOAP_TYPE___ns1__BindSFC_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindSFC_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindSFC_*)p = *(struct __ns1__BindSFC_*)q;
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CCDFileUploadComplete type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CCDFileUploadComplete*)p = *(struct __ns1__CCDFileUploadComplete*)q;
		break;
	case SOAP_TYPE___ns1__CCDFileUploadComplete_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CCDFileUploadComplete_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CCDFileUploadComplete_*)p = *(struct __ns1__CCDFileUploadComplete_*)q;
		break;
	case SOAP_TYPE___ns1__DownReason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownReason type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownReason*)p = *(struct __ns1__DownReason*)q;
		break;
	case SOAP_TYPE___ns1__DownReason_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownReason_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownReason_*)p = *(struct __ns1__DownReason_*)q;
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EquipmentProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EquipmentProcessParam*)p = *(struct __ns1__EquipmentProcessParam*)q;
		break;
	case SOAP_TYPE___ns1__EquipmentProcessParam_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EquipmentProcessParam_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EquipmentProcessParam_*)p = *(struct __ns1__EquipmentProcessParam_*)q;
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EquipmentProductProcessParam type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EquipmentProductProcessParam*)p = *(struct __ns1__EquipmentProductProcessParam*)q;
		break;
	case SOAP_TYPE___ns1__EquipmentProductProcessParam_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EquipmentProductProcessParam_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EquipmentProductProcessParam_*)p = *(struct __ns1__EquipmentProductProcessParam_*)q;
		break;
	case SOAP_TYPE___ns1__ExamineExists:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExamineExists type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExamineExists*)p = *(struct __ns1__ExamineExists*)q;
		break;
	case SOAP_TYPE___ns1__ExamineExists_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExamineExists_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExamineExists_*)p = *(struct __ns1__ExamineExists_*)q;
		break;
	case SOAP_TYPE___ns1__Feeding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Feeding type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Feeding*)p = *(struct __ns1__Feeding*)q;
		break;
	case SOAP_TYPE___ns1__Feeding_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Feeding_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Feeding_*)p = *(struct __ns1__Feeding_*)q;
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FeedingDJInLaminating type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FeedingDJInLaminating*)p = *(struct __ns1__FeedingDJInLaminating*)q;
		break;
	case SOAP_TYPE___ns1__FeedingDJInLaminating_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FeedingDJInLaminating_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FeedingDJInLaminating_*)p = *(struct __ns1__FeedingDJInLaminating_*)q;
		break;
	case SOAP_TYPE___ns1__FillingData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FillingData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FillingData*)p = *(struct __ns1__FillingData*)q;
		break;
	case SOAP_TYPE___ns1__FillingData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FillingData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FillingData_*)p = *(struct __ns1__FillingData_*)q;
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GenerateCellSFC type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GenerateCellSFC*)p = *(struct __ns1__GenerateCellSFC*)q;
		break;
	case SOAP_TYPE___ns1__GenerateCellSFC_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GenerateCellSFC_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GenerateCellSFC_*)p = *(struct __ns1__GenerateCellSFC_*)q;
		break;
	case SOAP_TYPE___ns1__Heartbeat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Heartbeat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Heartbeat*)p = *(struct __ns1__Heartbeat*)q;
		break;
	case SOAP_TYPE___ns1__Heartbeat_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Heartbeat_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Heartbeat_*)p = *(struct __ns1__Heartbeat_*)q;
		break;
	case SOAP_TYPE___ns1__Inbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Inbound type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Inbound*)p = *(struct __ns1__Inbound*)q;
		break;
	case SOAP_TYPE___ns1__Inbound_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Inbound_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Inbound_*)p = *(struct __ns1__Inbound_*)q;
		break;
	case SOAP_TYPE___ns1__InboundInContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInContainer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInContainer*)p = *(struct __ns1__InboundInContainer*)q;
		break;
	case SOAP_TYPE___ns1__InboundInContainer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInContainer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInContainer_*)p = *(struct __ns1__InboundInContainer_*)q;
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInSFCContainer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInSFCContainer*)p = *(struct __ns1__InboundInSFCContainer*)q;
		break;
	case SOAP_TYPE___ns1__InboundInSFCContainer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInSFCContainer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInSFCContainer_*)p = *(struct __ns1__InboundInSFCContainer_*)q;
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInTwoInjection type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInTwoInjection*)p = *(struct __ns1__InboundInTwoInjection*)q;
		break;
	case SOAP_TYPE___ns1__InboundInTwoInjection_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundInTwoInjection_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundInTwoInjection_*)p = *(struct __ns1__InboundInTwoInjection_*)q;
		break;
	case SOAP_TYPE___ns1__InboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundMore type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundMore*)p = *(struct __ns1__InboundMore*)q;
		break;
	case SOAP_TYPE___ns1__InboundMore_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InboundMore_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InboundMore_*)p = *(struct __ns1__InboundMore_*)q;
		break;
	case SOAP_TYPE___ns1__OperatorLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OperatorLogin type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OperatorLogin*)p = *(struct __ns1__OperatorLogin*)q;
		break;
	case SOAP_TYPE___ns1__OperatorLogin_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OperatorLogin_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OperatorLogin_*)p = *(struct __ns1__OperatorLogin_*)q;
		break;
	case SOAP_TYPE___ns1__Outbound:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Outbound type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Outbound*)p = *(struct __ns1__Outbound*)q;
		break;
	case SOAP_TYPE___ns1__Outbound_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Outbound_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Outbound_*)p = *(struct __ns1__Outbound_*)q;
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundInLaminating type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundInLaminating*)p = *(struct __ns1__OutboundInLaminating*)q;
		break;
	case SOAP_TYPE___ns1__OutboundInLaminating_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundInLaminating_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundInLaminating_*)p = *(struct __ns1__OutboundInLaminating_*)q;
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundInSFCOutputQty type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundInSFCOutputQty*)p = *(struct __ns1__OutboundInSFCOutputQty*)q;
		break;
	case SOAP_TYPE___ns1__OutboundInSFCOutputQty_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundInSFCOutputQty_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundInSFCOutputQty_*)p = *(struct __ns1__OutboundInSFCOutputQty_*)q;
		break;
	case SOAP_TYPE___ns1__OutboundMore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundMore type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundMore*)p = *(struct __ns1__OutboundMore*)q;
		break;
	case SOAP_TYPE___ns1__OutboundMore_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutboundMore_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutboundMore_*)p = *(struct __ns1__OutboundMore_*)q;
		break;
	case SOAP_TYPE___ns1__Recipe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Recipe type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Recipe*)p = *(struct __ns1__Recipe*)q;
		break;
	case SOAP_TYPE___ns1__Recipe_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Recipe_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Recipe_*)p = *(struct __ns1__Recipe_*)q;
		break;
	case SOAP_TYPE___ns1__GetRecipe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRecipe type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRecipe*)p = *(struct __ns1__GetRecipe*)q;
		break;
	case SOAP_TYPE___ns1__GetRecipe_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRecipe_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRecipe_*)p = *(struct __ns1__GetRecipe_*)q;
		break;
	case SOAP_TYPE___ns1__GetRecipeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRecipeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRecipeList*)p = *(struct __ns1__GetRecipeList*)q;
		break;
	case SOAP_TYPE___ns1__GetRecipeList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRecipeList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRecipeList_*)p = *(struct __ns1__GetRecipeList_*)q;
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__RecipeVersionExamine type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__RecipeVersionExamine*)p = *(struct __ns1__RecipeVersionExamine*)q;
		break;
	case SOAP_TYPE___ns1__RecipeVersionExamine_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__RecipeVersionExamine_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__RecipeVersionExamine_*)p = *(struct __ns1__RecipeVersionExamine_*)q;
		break;
	case SOAP_TYPE___ns1__State:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__State type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__State*)p = *(struct __ns1__State*)q;
		break;
	case SOAP_TYPE___ns1__State_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__State_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__State_*)p = *(struct __ns1__State_*)q;
		break;
	case SOAP_TYPE___ns1__ToolBind:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ToolBind type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ToolBind*)p = *(struct __ns1__ToolBind*)q;
		break;
	case SOAP_TYPE___ns1__ToolBind_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ToolBind_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ToolBind_*)p = *(struct __ns1__ToolBind_*)q;
		break;
	case SOAP_TYPE___ns1__ToolLife:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ToolLife type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ToolLife*)p = *(struct __ns1__ToolLife*)q;
		break;
	case SOAP_TYPE___ns1__ToolLife_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ToolLife_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ToolLife_*)p = *(struct __ns1__ToolLife_*)q;
		break;
	case SOAP_TYPE___ns1__UnBindSFC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UnBindSFC type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UnBindSFC*)p = *(struct __ns1__UnBindSFC*)q;
		break;
	case SOAP_TYPE___ns1__UnBindSFC_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UnBindSFC_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UnBindSFC_*)p = *(struct __ns1__UnBindSFC_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnBindSFCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UnBindSFCResponse::UnBindSFCResult = NULL;
}

void _ns1__UnBindSFCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__UnBindSFCResponse::UnBindSFCResult);
#endif
}

int _ns1__UnBindSFCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnBindSFCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnBindSFCResponse(struct soap *soap, const char *tag, int id, const _ns1__UnBindSFCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnBindSFCResponse), type))
		return soap->error;
	if (a->UnBindSFCResult)
		soap_element_result(soap, "ns1:UnBindSFCResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:UnBindSFCResult", -1, &a->_ns1__UnBindSFCResponse::UnBindSFCResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnBindSFCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__UnBindSFCResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnBindSFCResponse * SOAP_FMAC4 soap_in__ns1__UnBindSFCResponse(struct soap *soap, const char *tag, _ns1__UnBindSFCResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnBindSFCResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnBindSFCResponse, sizeof(_ns1__UnBindSFCResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UnBindSFCResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UnBindSFCResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UnBindSFCResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UnBindSFCResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:UnBindSFCResult", &a->_ns1__UnBindSFCResponse::UnBindSFCResult, "ns1:ApiResponseForScada"))
				{	soap_flag_UnBindSFCResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UnBindSFCResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UnBindSFCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnBindSFCResponse, SOAP_TYPE__ns1__UnBindSFCResponse, sizeof(_ns1__UnBindSFCResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnBindSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__UnBindSFCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnBindSFCResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnBindSFCResponse *p;
	size_t k = sizeof(_ns1__UnBindSFCResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UnBindSFCResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UnBindSFCResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UnBindSFCResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnBindSFCResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UnBindSFCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UnBindSFCResponse(soap, tag ? tag : "ns1:UnBindSFCResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnBindSFCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnBindSFCResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnBindSFCResponse * SOAP_FMAC4 soap_get__ns1__UnBindSFCResponse(struct soap *soap, _ns1__UnBindSFCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnBindSFCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnBindSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UnBindSFC::model = NULL;
}

void _ns1__UnBindSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__UnBindSFCByScadaDTO(soap, &this->_ns1__UnBindSFC::model);
#endif
}

int _ns1__UnBindSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnBindSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnBindSFC(struct soap *soap, const char *tag, int id, const _ns1__UnBindSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnBindSFC), type))
		return soap->error;
	if (soap_out_PointerTons1__UnBindSFCByScadaDTO(soap, "ns1:model", -1, &a->_ns1__UnBindSFC::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnBindSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__UnBindSFC(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnBindSFC * SOAP_FMAC4 soap_in__ns1__UnBindSFC(struct soap *soap, const char *tag, _ns1__UnBindSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnBindSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnBindSFC, sizeof(_ns1__UnBindSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UnBindSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UnBindSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__UnBindSFCByScadaDTO(soap, "ns1:model", &a->_ns1__UnBindSFC::model, "ns1:UnBindSFCByScadaDTO"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UnBindSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnBindSFC, SOAP_TYPE__ns1__UnBindSFC, sizeof(_ns1__UnBindSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnBindSFC * SOAP_FMAC2 soap_instantiate__ns1__UnBindSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnBindSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnBindSFC *p;
	size_t k = sizeof(_ns1__UnBindSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UnBindSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UnBindSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UnBindSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnBindSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UnBindSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UnBindSFC(soap, tag ? tag : "ns1:UnBindSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnBindSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnBindSFC(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnBindSFC * SOAP_FMAC4 soap_get__ns1__UnBindSFC(struct soap *soap, _ns1__UnBindSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnBindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ToolLifeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ToolLifeResponse::ToolLifeResult = NULL;
}

void _ns1__ToolLifeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__ToolLifeResponse::ToolLifeResult);
#endif
}

int _ns1__ToolLifeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ToolLifeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToolLifeResponse(struct soap *soap, const char *tag, int id, const _ns1__ToolLifeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToolLifeResponse), type))
		return soap->error;
	if (a->ToolLifeResult)
		soap_element_result(soap, "ns1:ToolLifeResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:ToolLifeResult", -1, &a->_ns1__ToolLifeResponse::ToolLifeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ToolLifeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ToolLifeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ToolLifeResponse * SOAP_FMAC4 soap_in__ns1__ToolLifeResponse(struct soap *soap, const char *tag, _ns1__ToolLifeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ToolLifeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToolLifeResponse, sizeof(_ns1__ToolLifeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ToolLifeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ToolLifeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ToolLifeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToolLifeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:ToolLifeResult", &a->_ns1__ToolLifeResponse::ToolLifeResult, "ns1:ApiResponseForScada"))
				{	soap_flag_ToolLifeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ToolLifeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ToolLifeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToolLifeResponse, SOAP_TYPE__ns1__ToolLifeResponse, sizeof(_ns1__ToolLifeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ToolLifeResponse * SOAP_FMAC2 soap_instantiate__ns1__ToolLifeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ToolLifeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ToolLifeResponse *p;
	size_t k = sizeof(_ns1__ToolLifeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ToolLifeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ToolLifeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ToolLifeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ToolLifeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ToolLifeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ToolLifeResponse(soap, tag ? tag : "ns1:ToolLifeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ToolLifeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ToolLifeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ToolLifeResponse * SOAP_FMAC4 soap_get__ns1__ToolLifeResponse(struct soap *soap, _ns1__ToolLifeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToolLifeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ToolLife::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ToolLife::model = NULL;
}

void _ns1__ToolLife::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ToolLife(soap, &this->_ns1__ToolLife::model);
#endif
}

int _ns1__ToolLife::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ToolLife(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToolLife(struct soap *soap, const char *tag, int id, const _ns1__ToolLife *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToolLife), type))
		return soap->error;
	if (soap_out_PointerTons1__ToolLife(soap, "ns1:model", -1, &a->_ns1__ToolLife::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ToolLife::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ToolLife(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ToolLife * SOAP_FMAC4 soap_in__ns1__ToolLife(struct soap *soap, const char *tag, _ns1__ToolLife *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ToolLife*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToolLife, sizeof(_ns1__ToolLife), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ToolLife)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ToolLife *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ToolLife(soap, "ns1:model", &a->_ns1__ToolLife::model, "ns1:ToolLife"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ToolLife *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToolLife, SOAP_TYPE__ns1__ToolLife, sizeof(_ns1__ToolLife), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ToolLife * SOAP_FMAC2 soap_instantiate__ns1__ToolLife(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ToolLife(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ToolLife *p;
	size_t k = sizeof(_ns1__ToolLife);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ToolLife, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ToolLife);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ToolLife, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ToolLife location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ToolLife::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ToolLife(soap, tag ? tag : "ns1:ToolLife", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ToolLife::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ToolLife(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ToolLife * SOAP_FMAC4 soap_get__ns1__ToolLife(struct soap *soap, _ns1__ToolLife *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToolLife(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ToolBindResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ToolBindResponse::ToolBindResult = NULL;
}

void _ns1__ToolBindResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__ToolBindResponse::ToolBindResult);
#endif
}

int _ns1__ToolBindResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ToolBindResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToolBindResponse(struct soap *soap, const char *tag, int id, const _ns1__ToolBindResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToolBindResponse), type))
		return soap->error;
	if (a->ToolBindResult)
		soap_element_result(soap, "ns1:ToolBindResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:ToolBindResult", -1, &a->_ns1__ToolBindResponse::ToolBindResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ToolBindResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ToolBindResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ToolBindResponse * SOAP_FMAC4 soap_in__ns1__ToolBindResponse(struct soap *soap, const char *tag, _ns1__ToolBindResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ToolBindResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToolBindResponse, sizeof(_ns1__ToolBindResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ToolBindResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ToolBindResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ToolBindResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToolBindResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:ToolBindResult", &a->_ns1__ToolBindResponse::ToolBindResult, "ns1:ApiResponseForScada"))
				{	soap_flag_ToolBindResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ToolBindResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ToolBindResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToolBindResponse, SOAP_TYPE__ns1__ToolBindResponse, sizeof(_ns1__ToolBindResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ToolBindResponse * SOAP_FMAC2 soap_instantiate__ns1__ToolBindResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ToolBindResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ToolBindResponse *p;
	size_t k = sizeof(_ns1__ToolBindResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ToolBindResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ToolBindResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ToolBindResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ToolBindResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ToolBindResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ToolBindResponse(soap, tag ? tag : "ns1:ToolBindResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ToolBindResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ToolBindResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ToolBindResponse * SOAP_FMAC4 soap_get__ns1__ToolBindResponse(struct soap *soap, _ns1__ToolBindResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToolBindResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ToolBind::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ToolBind::model = NULL;
}

void _ns1__ToolBind::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ToolBind(soap, &this->_ns1__ToolBind::model);
#endif
}

int _ns1__ToolBind::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ToolBind(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ToolBind(struct soap *soap, const char *tag, int id, const _ns1__ToolBind *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ToolBind), type))
		return soap->error;
	if (soap_out_PointerTons1__ToolBind(soap, "ns1:model", -1, &a->_ns1__ToolBind::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ToolBind::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ToolBind(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ToolBind * SOAP_FMAC4 soap_in__ns1__ToolBind(struct soap *soap, const char *tag, _ns1__ToolBind *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ToolBind*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ToolBind, sizeof(_ns1__ToolBind), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ToolBind)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ToolBind *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ToolBind(soap, "ns1:model", &a->_ns1__ToolBind::model, "ns1:ToolBind"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ToolBind *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ToolBind, SOAP_TYPE__ns1__ToolBind, sizeof(_ns1__ToolBind), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ToolBind * SOAP_FMAC2 soap_instantiate__ns1__ToolBind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ToolBind(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ToolBind *p;
	size_t k = sizeof(_ns1__ToolBind);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ToolBind, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ToolBind);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ToolBind, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ToolBind location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ToolBind::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ToolBind(soap, tag ? tag : "ns1:ToolBind", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ToolBind::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ToolBind(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ToolBind * SOAP_FMAC4 soap_get__ns1__ToolBind(struct soap *soap, _ns1__ToolBind *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ToolBind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__StateResponse::StateResult = NULL;
}

void _ns1__StateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__StateResponse::StateResult);
#endif
}

int _ns1__StateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StateResponse(struct soap *soap, const char *tag, int id, const _ns1__StateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StateResponse), type))
		return soap->error;
	if (a->StateResult)
		soap_element_result(soap, "ns1:StateResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:StateResult", -1, &a->_ns1__StateResponse::StateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__StateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StateResponse * SOAP_FMAC4 soap_in__ns1__StateResponse(struct soap *soap, const char *tag, _ns1__StateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StateResponse, sizeof(_ns1__StateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__StateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__StateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StateResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:StateResult", &a->_ns1__StateResponse::StateResult, "ns1:ApiResponseForScada"))
				{	soap_flag_StateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:StateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StateResponse, SOAP_TYPE__ns1__StateResponse, sizeof(_ns1__StateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StateResponse * SOAP_FMAC2 soap_instantiate__ns1__StateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StateResponse *p;
	size_t k = sizeof(_ns1__StateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__StateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__StateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__StateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__StateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__StateResponse(soap, tag ? tag : "ns1:StateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StateResponse * SOAP_FMAC4 soap_get__ns1__StateResponse(struct soap *soap, _ns1__StateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__State::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__State::model = NULL;
}

void _ns1__State::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__State(soap, &this->_ns1__State::model);
#endif
}

int _ns1__State::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__State(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__State(struct soap *soap, const char *tag, int id, const _ns1__State *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__State), type))
		return soap->error;
	if (soap_out_PointerTons1__State(soap, "ns1:model", -1, &a->_ns1__State::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__State::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__State(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__State * SOAP_FMAC4 soap_in__ns1__State(struct soap *soap, const char *tag, _ns1__State *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__State*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__State, sizeof(_ns1__State), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__State)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__State *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__State(soap, "ns1:model", &a->_ns1__State::model, "ns1:State"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__State *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__State, SOAP_TYPE__ns1__State, sizeof(_ns1__State), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__State * SOAP_FMAC2 soap_instantiate__ns1__State(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__State(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__State *p;
	size_t k = sizeof(_ns1__State);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__State, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__State);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__State, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__State location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__State::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__State(soap, tag ? tag : "ns1:State", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__State::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__State(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__State * SOAP_FMAC4 soap_get__ns1__State(struct soap *soap, _ns1__State *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RecipeVersionExamineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RecipeVersionExamineResponse::RecipeVersionExamineResult = NULL;
}

void _ns1__RecipeVersionExamineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__RecipeVersionExamineResponse::RecipeVersionExamineResult);
#endif
}

int _ns1__RecipeVersionExamineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RecipeVersionExamineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RecipeVersionExamineResponse(struct soap *soap, const char *tag, int id, const _ns1__RecipeVersionExamineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RecipeVersionExamineResponse), type))
		return soap->error;
	if (a->RecipeVersionExamineResult)
		soap_element_result(soap, "ns1:RecipeVersionExamineResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:RecipeVersionExamineResult", -1, &a->_ns1__RecipeVersionExamineResponse::RecipeVersionExamineResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RecipeVersionExamineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__RecipeVersionExamineResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RecipeVersionExamineResponse * SOAP_FMAC4 soap_in__ns1__RecipeVersionExamineResponse(struct soap *soap, const char *tag, _ns1__RecipeVersionExamineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RecipeVersionExamineResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RecipeVersionExamineResponse, sizeof(_ns1__RecipeVersionExamineResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RecipeVersionExamineResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RecipeVersionExamineResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecipeVersionExamineResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecipeVersionExamineResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:RecipeVersionExamineResult", &a->_ns1__RecipeVersionExamineResponse::RecipeVersionExamineResult, "ns1:ApiResponseForScada"))
				{	soap_flag_RecipeVersionExamineResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:RecipeVersionExamineResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RecipeVersionExamineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RecipeVersionExamineResponse, SOAP_TYPE__ns1__RecipeVersionExamineResponse, sizeof(_ns1__RecipeVersionExamineResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RecipeVersionExamineResponse * SOAP_FMAC2 soap_instantiate__ns1__RecipeVersionExamineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RecipeVersionExamineResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RecipeVersionExamineResponse *p;
	size_t k = sizeof(_ns1__RecipeVersionExamineResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__RecipeVersionExamineResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__RecipeVersionExamineResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__RecipeVersionExamineResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RecipeVersionExamineResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__RecipeVersionExamineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RecipeVersionExamineResponse(soap, tag ? tag : "ns1:RecipeVersionExamineResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RecipeVersionExamineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RecipeVersionExamineResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RecipeVersionExamineResponse * SOAP_FMAC4 soap_get__ns1__RecipeVersionExamineResponse(struct soap *soap, _ns1__RecipeVersionExamineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RecipeVersionExamineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RecipeVersionExamine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RecipeVersionExamine::model = NULL;
}

void _ns1__RecipeVersionExamine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RecipeVersionExamine(soap, &this->_ns1__RecipeVersionExamine::model);
#endif
}

int _ns1__RecipeVersionExamine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RecipeVersionExamine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RecipeVersionExamine(struct soap *soap, const char *tag, int id, const _ns1__RecipeVersionExamine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RecipeVersionExamine), type))
		return soap->error;
	if (soap_out_PointerTons1__RecipeVersionExamine(soap, "ns1:model", -1, &a->_ns1__RecipeVersionExamine::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RecipeVersionExamine::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__RecipeVersionExamine(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RecipeVersionExamine * SOAP_FMAC4 soap_in__ns1__RecipeVersionExamine(struct soap *soap, const char *tag, _ns1__RecipeVersionExamine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RecipeVersionExamine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RecipeVersionExamine, sizeof(_ns1__RecipeVersionExamine), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RecipeVersionExamine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RecipeVersionExamine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RecipeVersionExamine(soap, "ns1:model", &a->_ns1__RecipeVersionExamine::model, "ns1:RecipeVersionExamine"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RecipeVersionExamine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RecipeVersionExamine, SOAP_TYPE__ns1__RecipeVersionExamine, sizeof(_ns1__RecipeVersionExamine), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate__ns1__RecipeVersionExamine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RecipeVersionExamine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RecipeVersionExamine *p;
	size_t k = sizeof(_ns1__RecipeVersionExamine);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__RecipeVersionExamine, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__RecipeVersionExamine);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__RecipeVersionExamine, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RecipeVersionExamine location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__RecipeVersionExamine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RecipeVersionExamine(soap, tag ? tag : "ns1:RecipeVersionExamine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RecipeVersionExamine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RecipeVersionExamine(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RecipeVersionExamine * SOAP_FMAC4 soap_get__ns1__RecipeVersionExamine(struct soap *soap, _ns1__RecipeVersionExamine *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RecipeVersionExamine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecipeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRecipeListResponse::GetRecipeListResult = NULL;
}

void _ns1__GetRecipeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, &this->_ns1__GetRecipeListResponse::GetRecipeListResult);
#endif
}

int _ns1__GetRecipeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecipeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecipeListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRecipeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecipeListResponse), type))
		return soap->error;
	if (a->GetRecipeListResult)
		soap_element_result(soap, "ns1:GetRecipeListResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, "ns1:GetRecipeListResult", -1, &a->_ns1__GetRecipeListResponse::GetRecipeListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecipeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetRecipeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecipeListResponse * SOAP_FMAC4 soap_in__ns1__GetRecipeListResponse(struct soap *soap, const char *tag, _ns1__GetRecipeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecipeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecipeListResponse, sizeof(_ns1__GetRecipeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRecipeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRecipeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRecipeListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRecipeListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, "ns1:GetRecipeListResult", &a->_ns1__GetRecipeListResponse::GetRecipeListResult, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu"))
				{	soap_flag_GetRecipeListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetRecipeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRecipeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecipeListResponse, SOAP_TYPE__ns1__GetRecipeListResponse, sizeof(_ns1__GetRecipeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecipeListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecipeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecipeListResponse *p;
	size_t k = sizeof(_ns1__GetRecipeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRecipeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRecipeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRecipeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecipeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRecipeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRecipeListResponse(soap, tag ? tag : "ns1:GetRecipeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecipeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecipeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecipeListResponse * SOAP_FMAC4 soap_get__ns1__GetRecipeListResponse(struct soap *soap, _ns1__GetRecipeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecipeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecipeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRecipeList::model = NULL;
}

void _ns1__GetRecipeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RecipeListGet(soap, &this->_ns1__GetRecipeList::model);
#endif
}

int _ns1__GetRecipeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecipeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecipeList(struct soap *soap, const char *tag, int id, const _ns1__GetRecipeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecipeList), type))
		return soap->error;
	if (soap_out_PointerTons1__RecipeListGet(soap, "ns1:model", -1, &a->_ns1__GetRecipeList::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecipeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetRecipeList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecipeList * SOAP_FMAC4 soap_in__ns1__GetRecipeList(struct soap *soap, const char *tag, _ns1__GetRecipeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecipeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecipeList, sizeof(_ns1__GetRecipeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRecipeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRecipeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RecipeListGet(soap, "ns1:model", &a->_ns1__GetRecipeList::model, "ns1:RecipeListGet"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRecipeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecipeList, SOAP_TYPE__ns1__GetRecipeList, sizeof(_ns1__GetRecipeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecipeList * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecipeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecipeList *p;
	size_t k = sizeof(_ns1__GetRecipeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRecipeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRecipeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRecipeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecipeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRecipeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRecipeList(soap, tag ? tag : "ns1:GetRecipeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecipeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecipeList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecipeList * SOAP_FMAC4 soap_get__ns1__GetRecipeList(struct soap *soap, _ns1__GetRecipeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecipeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecipeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRecipeResponse::GetRecipeResult = NULL;
}

void _ns1__GetRecipeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, &this->_ns1__GetRecipeResponse::GetRecipeResult);
#endif
}

int _ns1__GetRecipeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecipeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecipeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRecipeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecipeResponse), type))
		return soap->error;
	if (a->GetRecipeResult)
		soap_element_result(soap, "ns1:GetRecipeResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, "ns1:GetRecipeResult", -1, &a->_ns1__GetRecipeResponse::GetRecipeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecipeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetRecipeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecipeResponse * SOAP_FMAC4 soap_in__ns1__GetRecipeResponse(struct soap *soap, const char *tag, _ns1__GetRecipeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecipeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecipeResponse, sizeof(_ns1__GetRecipeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRecipeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRecipeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRecipeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRecipeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, "ns1:GetRecipeResult", &a->_ns1__GetRecipeResponse::GetRecipeResult, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu"))
				{	soap_flag_GetRecipeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetRecipeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRecipeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecipeResponse, SOAP_TYPE__ns1__GetRecipeResponse, sizeof(_ns1__GetRecipeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecipeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecipeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecipeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecipeResponse *p;
	size_t k = sizeof(_ns1__GetRecipeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRecipeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRecipeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRecipeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecipeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRecipeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRecipeResponse(soap, tag ? tag : "ns1:GetRecipeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecipeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecipeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecipeResponse * SOAP_FMAC4 soap_get__ns1__GetRecipeResponse(struct soap *soap, _ns1__GetRecipeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecipeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecipe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRecipe::model = NULL;
}

void _ns1__GetRecipe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RecipeGet(soap, &this->_ns1__GetRecipe::model);
#endif
}

int _ns1__GetRecipe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecipe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecipe(struct soap *soap, const char *tag, int id, const _ns1__GetRecipe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecipe), type))
		return soap->error;
	if (soap_out_PointerTons1__RecipeGet(soap, "ns1:model", -1, &a->_ns1__GetRecipe::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecipe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetRecipe(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecipe * SOAP_FMAC4 soap_in__ns1__GetRecipe(struct soap *soap, const char *tag, _ns1__GetRecipe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecipe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecipe, sizeof(_ns1__GetRecipe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRecipe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRecipe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RecipeGet(soap, "ns1:model", &a->_ns1__GetRecipe::model, "ns1:RecipeGet"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRecipe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecipe, SOAP_TYPE__ns1__GetRecipe, sizeof(_ns1__GetRecipe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecipe * SOAP_FMAC2 soap_instantiate__ns1__GetRecipe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecipe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecipe *p;
	size_t k = sizeof(_ns1__GetRecipe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRecipe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRecipe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRecipe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecipe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRecipe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRecipe(soap, tag ? tag : "ns1:GetRecipe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecipe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecipe(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecipe * SOAP_FMAC4 soap_get__ns1__GetRecipe(struct soap *soap, _ns1__GetRecipe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RecipeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RecipeResponse::RecipeResult = NULL;
}

void _ns1__RecipeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__RecipeResponse::RecipeResult);
#endif
}

int _ns1__RecipeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RecipeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RecipeResponse(struct soap *soap, const char *tag, int id, const _ns1__RecipeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RecipeResponse), type))
		return soap->error;
	if (a->RecipeResult)
		soap_element_result(soap, "ns1:RecipeResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:RecipeResult", -1, &a->_ns1__RecipeResponse::RecipeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RecipeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__RecipeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RecipeResponse * SOAP_FMAC4 soap_in__ns1__RecipeResponse(struct soap *soap, const char *tag, _ns1__RecipeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RecipeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RecipeResponse, sizeof(_ns1__RecipeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RecipeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RecipeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecipeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecipeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:RecipeResult", &a->_ns1__RecipeResponse::RecipeResult, "ns1:ApiResponseForScada"))
				{	soap_flag_RecipeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:RecipeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RecipeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RecipeResponse, SOAP_TYPE__ns1__RecipeResponse, sizeof(_ns1__RecipeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RecipeResponse * SOAP_FMAC2 soap_instantiate__ns1__RecipeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RecipeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RecipeResponse *p;
	size_t k = sizeof(_ns1__RecipeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__RecipeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__RecipeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__RecipeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RecipeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__RecipeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RecipeResponse(soap, tag ? tag : "ns1:RecipeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RecipeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RecipeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RecipeResponse * SOAP_FMAC4 soap_get__ns1__RecipeResponse(struct soap *soap, _ns1__RecipeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RecipeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Recipe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Recipe::model = NULL;
}

void _ns1__Recipe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Recipe(soap, &this->_ns1__Recipe::model);
#endif
}

int _ns1__Recipe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Recipe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Recipe(struct soap *soap, const char *tag, int id, const _ns1__Recipe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Recipe), type))
		return soap->error;
	if (soap_out_PointerTons1__Recipe(soap, "ns1:model", -1, &a->_ns1__Recipe::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Recipe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Recipe(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Recipe * SOAP_FMAC4 soap_in__ns1__Recipe(struct soap *soap, const char *tag, _ns1__Recipe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Recipe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Recipe, sizeof(_ns1__Recipe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Recipe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Recipe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Recipe(soap, "ns1:model", &a->_ns1__Recipe::model, "ns1:Recipe"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Recipe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Recipe, SOAP_TYPE__ns1__Recipe, sizeof(_ns1__Recipe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Recipe * SOAP_FMAC2 soap_instantiate__ns1__Recipe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Recipe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Recipe *p;
	size_t k = sizeof(_ns1__Recipe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Recipe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Recipe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Recipe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Recipe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Recipe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Recipe(soap, tag ? tag : "ns1:Recipe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Recipe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Recipe(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Recipe * SOAP_FMAC4 soap_get__ns1__Recipe(struct soap *soap, _ns1__Recipe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Recipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundMoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundMoreResponse::OutboundMoreResult = NULL;
}

void _ns1__OutboundMoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, &this->_ns1__OutboundMoreResponse::OutboundMoreResult);
#endif
}

int _ns1__OutboundMoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundMoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundMoreResponse(struct soap *soap, const char *tag, int id, const _ns1__OutboundMoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundMoreResponse), type))
		return soap->error;
	if (a->OutboundMoreResult)
		soap_element_result(soap, "ns1:OutboundMoreResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:OutboundMoreResult", -1, &a->_ns1__OutboundMoreResponse::OutboundMoreResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundMoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundMoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundMoreResponse * SOAP_FMAC4 soap_in__ns1__OutboundMoreResponse(struct soap *soap, const char *tag, _ns1__OutboundMoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundMoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundMoreResponse, sizeof(_ns1__OutboundMoreResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundMoreResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundMoreResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutboundMoreResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutboundMoreResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:OutboundMoreResult", &a->_ns1__OutboundMoreResponse::OutboundMoreResult, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
				{	soap_flag_OutboundMoreResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutboundMoreResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundMoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundMoreResponse, SOAP_TYPE__ns1__OutboundMoreResponse, sizeof(_ns1__OutboundMoreResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundMoreResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundMoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundMoreResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundMoreResponse *p;
	size_t k = sizeof(_ns1__OutboundMoreResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundMoreResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundMoreResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundMoreResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundMoreResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundMoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundMoreResponse(soap, tag ? tag : "ns1:OutboundMoreResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundMoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundMoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundMoreResponse * SOAP_FMAC4 soap_get__ns1__OutboundMoreResponse(struct soap *soap, _ns1__OutboundMoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundMoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundMore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundMore::model = NULL;
}

void _ns1__OutboundMore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__OutboundMore(soap, &this->_ns1__OutboundMore::model);
#endif
}

int _ns1__OutboundMore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundMore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundMore(struct soap *soap, const char *tag, int id, const _ns1__OutboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundMore), type))
		return soap->error;
	if (soap_out_PointerTons1__OutboundMore(soap, "ns1:model", -1, &a->_ns1__OutboundMore::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundMore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundMore(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundMore * SOAP_FMAC4 soap_in__ns1__OutboundMore(struct soap *soap, const char *tag, _ns1__OutboundMore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundMore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundMore, sizeof(_ns1__OutboundMore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundMore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundMore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OutboundMore(soap, "ns1:model", &a->_ns1__OutboundMore::model, "ns1:OutboundMore"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundMore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundMore, SOAP_TYPE__ns1__OutboundMore, sizeof(_ns1__OutboundMore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundMore * SOAP_FMAC2 soap_instantiate__ns1__OutboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundMore *p;
	size_t k = sizeof(_ns1__OutboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundMore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundMore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundMore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundMore(soap, tag ? tag : "ns1:OutboundMore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundMore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundMore(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundMore * SOAP_FMAC4 soap_get__ns1__OutboundMore(struct soap *soap, _ns1__OutboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundInSFCOutputQtyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundInSFCOutputQtyResponse::OutboundInSFCOutputQtyResult = NULL;
}

void _ns1__OutboundInSFCOutputQtyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__OutboundInSFCOutputQtyResponse::OutboundInSFCOutputQtyResult);
#endif
}

int _ns1__OutboundInSFCOutputQtyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundInSFCOutputQtyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundInSFCOutputQtyResponse(struct soap *soap, const char *tag, int id, const _ns1__OutboundInSFCOutputQtyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse), type))
		return soap->error;
	if (a->OutboundInSFCOutputQtyResult)
		soap_element_result(soap, "ns1:OutboundInSFCOutputQtyResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundInSFCOutputQtyResult", -1, &a->_ns1__OutboundInSFCOutputQtyResponse::OutboundInSFCOutputQtyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundInSFCOutputQtyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundInSFCOutputQtyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQtyResponse * SOAP_FMAC4 soap_in__ns1__OutboundInSFCOutputQtyResponse(struct soap *soap, const char *tag, _ns1__OutboundInSFCOutputQtyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundInSFCOutputQtyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse, sizeof(_ns1__OutboundInSFCOutputQtyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundInSFCOutputQtyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutboundInSFCOutputQtyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutboundInSFCOutputQtyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundInSFCOutputQtyResult", &a->_ns1__OutboundInSFCOutputQtyResponse::OutboundInSFCOutputQtyResult, "ns1:ApiResponseForScada"))
				{	soap_flag_OutboundInSFCOutputQtyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutboundInSFCOutputQtyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundInSFCOutputQtyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse, SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse, sizeof(_ns1__OutboundInSFCOutputQtyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundInSFCOutputQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundInSFCOutputQtyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundInSFCOutputQtyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundInSFCOutputQtyResponse *p;
	size_t k = sizeof(_ns1__OutboundInSFCOutputQtyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundInSFCOutputQtyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundInSFCOutputQtyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundInSFCOutputQtyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundInSFCOutputQtyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundInSFCOutputQtyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundInSFCOutputQtyResponse(soap, tag ? tag : "ns1:OutboundInSFCOutputQtyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundInSFCOutputQtyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundInSFCOutputQtyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQtyResponse * SOAP_FMAC4 soap_get__ns1__OutboundInSFCOutputQtyResponse(struct soap *soap, _ns1__OutboundInSFCOutputQtyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundInSFCOutputQtyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundInSFCOutputQty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundInSFCOutputQty::model = NULL;
}

void _ns1__OutboundInSFCOutputQty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__OutboundInSFCOutputQty(soap, &this->_ns1__OutboundInSFCOutputQty::model);
#endif
}

int _ns1__OutboundInSFCOutputQty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundInSFCOutputQty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, int id, const _ns1__OutboundInSFCOutputQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundInSFCOutputQty), type))
		return soap->error;
	if (soap_out_PointerTons1__OutboundInSFCOutputQty(soap, "ns1:model", -1, &a->_ns1__OutboundInSFCOutputQty::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundInSFCOutputQty::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundInSFCOutputQty(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_in__ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, _ns1__OutboundInSFCOutputQty *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundInSFCOutputQty*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundInSFCOutputQty, sizeof(_ns1__OutboundInSFCOutputQty), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundInSFCOutputQty)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundInSFCOutputQty *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OutboundInSFCOutputQty(soap, "ns1:model", &a->_ns1__OutboundInSFCOutputQty::model, "ns1:OutboundInSFCOutputQty"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundInSFCOutputQty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundInSFCOutputQty, SOAP_TYPE__ns1__OutboundInSFCOutputQty, sizeof(_ns1__OutboundInSFCOutputQty), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate__ns1__OutboundInSFCOutputQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundInSFCOutputQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundInSFCOutputQty *p;
	size_t k = sizeof(_ns1__OutboundInSFCOutputQty);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundInSFCOutputQty, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundInSFCOutputQty);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundInSFCOutputQty, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundInSFCOutputQty location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundInSFCOutputQty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundInSFCOutputQty(soap, tag ? tag : "ns1:OutboundInSFCOutputQty", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundInSFCOutputQty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundInSFCOutputQty(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_get__ns1__OutboundInSFCOutputQty(struct soap *soap, _ns1__OutboundInSFCOutputQty *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundInSFCOutputQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundInLaminatingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundInLaminatingResponse::OutboundInLaminatingResult = NULL;
}

void _ns1__OutboundInLaminatingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__OutboundInLaminatingResponse::OutboundInLaminatingResult);
#endif
}

int _ns1__OutboundInLaminatingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundInLaminatingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundInLaminatingResponse(struct soap *soap, const char *tag, int id, const _ns1__OutboundInLaminatingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundInLaminatingResponse), type))
		return soap->error;
	if (a->OutboundInLaminatingResult)
		soap_element_result(soap, "ns1:OutboundInLaminatingResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundInLaminatingResult", -1, &a->_ns1__OutboundInLaminatingResponse::OutboundInLaminatingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundInLaminatingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundInLaminatingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundInLaminatingResponse * SOAP_FMAC4 soap_in__ns1__OutboundInLaminatingResponse(struct soap *soap, const char *tag, _ns1__OutboundInLaminatingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundInLaminatingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundInLaminatingResponse, sizeof(_ns1__OutboundInLaminatingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundInLaminatingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundInLaminatingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutboundInLaminatingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutboundInLaminatingResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundInLaminatingResult", &a->_ns1__OutboundInLaminatingResponse::OutboundInLaminatingResult, "ns1:ApiResponseForScada"))
				{	soap_flag_OutboundInLaminatingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutboundInLaminatingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundInLaminatingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundInLaminatingResponse, SOAP_TYPE__ns1__OutboundInLaminatingResponse, sizeof(_ns1__OutboundInLaminatingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundInLaminatingResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundInLaminatingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundInLaminatingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundInLaminatingResponse *p;
	size_t k = sizeof(_ns1__OutboundInLaminatingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundInLaminatingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundInLaminatingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundInLaminatingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundInLaminatingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundInLaminatingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundInLaminatingResponse(soap, tag ? tag : "ns1:OutboundInLaminatingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundInLaminatingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundInLaminatingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundInLaminatingResponse * SOAP_FMAC4 soap_get__ns1__OutboundInLaminatingResponse(struct soap *soap, _ns1__OutboundInLaminatingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundInLaminatingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundInLaminating::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundInLaminating::model = NULL;
}

void _ns1__OutboundInLaminating::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__OutboundInLaminating(soap, &this->_ns1__OutboundInLaminating::model);
#endif
}

int _ns1__OutboundInLaminating::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundInLaminating(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundInLaminating(struct soap *soap, const char *tag, int id, const _ns1__OutboundInLaminating *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundInLaminating), type))
		return soap->error;
	if (soap_out_PointerTons1__OutboundInLaminating(soap, "ns1:model", -1, &a->_ns1__OutboundInLaminating::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundInLaminating::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundInLaminating(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundInLaminating * SOAP_FMAC4 soap_in__ns1__OutboundInLaminating(struct soap *soap, const char *tag, _ns1__OutboundInLaminating *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundInLaminating*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundInLaminating, sizeof(_ns1__OutboundInLaminating), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundInLaminating)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundInLaminating *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OutboundInLaminating(soap, "ns1:model", &a->_ns1__OutboundInLaminating::model, "ns1:OutboundInLaminating"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundInLaminating *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundInLaminating, SOAP_TYPE__ns1__OutboundInLaminating, sizeof(_ns1__OutboundInLaminating), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate__ns1__OutboundInLaminating(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundInLaminating(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundInLaminating *p;
	size_t k = sizeof(_ns1__OutboundInLaminating);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundInLaminating, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundInLaminating);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundInLaminating, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundInLaminating location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundInLaminating::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundInLaminating(soap, tag ? tag : "ns1:OutboundInLaminating", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundInLaminating::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundInLaminating(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundInLaminating * SOAP_FMAC4 soap_get__ns1__OutboundInLaminating(struct soap *soap, _ns1__OutboundInLaminating *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutboundResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutboundResponse::OutboundResult = NULL;
}

void _ns1__OutboundResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__OutboundResponse::OutboundResult);
#endif
}

int _ns1__OutboundResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutboundResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutboundResponse(struct soap *soap, const char *tag, int id, const _ns1__OutboundResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutboundResponse), type))
		return soap->error;
	if (a->OutboundResult)
		soap_element_result(soap, "ns1:OutboundResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundResult", -1, &a->_ns1__OutboundResponse::OutboundResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutboundResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OutboundResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutboundResponse * SOAP_FMAC4 soap_in__ns1__OutboundResponse(struct soap *soap, const char *tag, _ns1__OutboundResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutboundResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutboundResponse, sizeof(_ns1__OutboundResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutboundResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutboundResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutboundResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutboundResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:OutboundResult", &a->_ns1__OutboundResponse::OutboundResult, "ns1:ApiResponseForScada"))
				{	soap_flag_OutboundResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutboundResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutboundResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutboundResponse, SOAP_TYPE__ns1__OutboundResponse, sizeof(_ns1__OutboundResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutboundResponse * SOAP_FMAC2 soap_instantiate__ns1__OutboundResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutboundResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutboundResponse *p;
	size_t k = sizeof(_ns1__OutboundResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OutboundResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OutboundResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OutboundResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutboundResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OutboundResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutboundResponse(soap, tag ? tag : "ns1:OutboundResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutboundResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutboundResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutboundResponse * SOAP_FMAC4 soap_get__ns1__OutboundResponse(struct soap *soap, _ns1__OutboundResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutboundResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Outbound::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Outbound::model = NULL;
}

void _ns1__Outbound::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Outbound(soap, &this->_ns1__Outbound::model);
#endif
}

int _ns1__Outbound::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Outbound(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Outbound(struct soap *soap, const char *tag, int id, const _ns1__Outbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Outbound), type))
		return soap->error;
	if (soap_out_PointerTons1__Outbound(soap, "ns1:model", -1, &a->_ns1__Outbound::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Outbound::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Outbound(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Outbound * SOAP_FMAC4 soap_in__ns1__Outbound(struct soap *soap, const char *tag, _ns1__Outbound *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Outbound*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Outbound, sizeof(_ns1__Outbound), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Outbound)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Outbound *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Outbound(soap, "ns1:model", &a->_ns1__Outbound::model, "ns1:Outbound"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Outbound *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Outbound, SOAP_TYPE__ns1__Outbound, sizeof(_ns1__Outbound), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Outbound * SOAP_FMAC2 soap_instantiate__ns1__Outbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Outbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Outbound *p;
	size_t k = sizeof(_ns1__Outbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Outbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Outbound);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Outbound, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Outbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Outbound::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Outbound(soap, tag ? tag : "ns1:Outbound", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Outbound::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Outbound(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Outbound * SOAP_FMAC4 soap_get__ns1__Outbound(struct soap *soap, _ns1__Outbound *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Outbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OperatorLoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OperatorLoginResponse::OperatorLoginResult = NULL;
}

void _ns1__OperatorLoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__OperatorLoginResponse::OperatorLoginResult);
#endif
}

int _ns1__OperatorLoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OperatorLoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperatorLoginResponse(struct soap *soap, const char *tag, int id, const _ns1__OperatorLoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperatorLoginResponse), type))
		return soap->error;
	if (a->OperatorLoginResult)
		soap_element_result(soap, "ns1:OperatorLoginResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:OperatorLoginResult", -1, &a->_ns1__OperatorLoginResponse::OperatorLoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OperatorLoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OperatorLoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OperatorLoginResponse * SOAP_FMAC4 soap_in__ns1__OperatorLoginResponse(struct soap *soap, const char *tag, _ns1__OperatorLoginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OperatorLoginResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperatorLoginResponse, sizeof(_ns1__OperatorLoginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OperatorLoginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OperatorLoginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OperatorLoginResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperatorLoginResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:OperatorLoginResult", &a->_ns1__OperatorLoginResponse::OperatorLoginResult, "ns1:ApiResponseForScada"))
				{	soap_flag_OperatorLoginResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OperatorLoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OperatorLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperatorLoginResponse, SOAP_TYPE__ns1__OperatorLoginResponse, sizeof(_ns1__OperatorLoginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OperatorLoginResponse * SOAP_FMAC2 soap_instantiate__ns1__OperatorLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OperatorLoginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OperatorLoginResponse *p;
	size_t k = sizeof(_ns1__OperatorLoginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OperatorLoginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OperatorLoginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OperatorLoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OperatorLoginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OperatorLoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OperatorLoginResponse(soap, tag ? tag : "ns1:OperatorLoginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OperatorLoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OperatorLoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OperatorLoginResponse * SOAP_FMAC4 soap_get__ns1__OperatorLoginResponse(struct soap *soap, _ns1__OperatorLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperatorLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OperatorLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OperatorLogin::model = NULL;
}

void _ns1__OperatorLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__OperatorLogin(soap, &this->_ns1__OperatorLogin::model);
#endif
}

int _ns1__OperatorLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OperatorLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperatorLogin(struct soap *soap, const char *tag, int id, const _ns1__OperatorLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperatorLogin), type))
		return soap->error;
	if (soap_out_PointerTons1__OperatorLogin(soap, "ns1:model", -1, &a->_ns1__OperatorLogin::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OperatorLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__OperatorLogin(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OperatorLogin * SOAP_FMAC4 soap_in__ns1__OperatorLogin(struct soap *soap, const char *tag, _ns1__OperatorLogin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OperatorLogin*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperatorLogin, sizeof(_ns1__OperatorLogin), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OperatorLogin)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OperatorLogin *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OperatorLogin(soap, "ns1:model", &a->_ns1__OperatorLogin::model, "ns1:OperatorLogin"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OperatorLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperatorLogin, SOAP_TYPE__ns1__OperatorLogin, sizeof(_ns1__OperatorLogin), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate__ns1__OperatorLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OperatorLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OperatorLogin *p;
	size_t k = sizeof(_ns1__OperatorLogin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OperatorLogin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OperatorLogin);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OperatorLogin, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OperatorLogin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OperatorLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OperatorLogin(soap, tag ? tag : "ns1:OperatorLogin", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OperatorLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OperatorLogin(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OperatorLogin * SOAP_FMAC4 soap_get__ns1__OperatorLogin(struct soap *soap, _ns1__OperatorLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperatorLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundMoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundMoreResponse::InboundMoreResult = NULL;
}

void _ns1__InboundMoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, &this->_ns1__InboundMoreResponse::InboundMoreResult);
#endif
}

int _ns1__InboundMoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundMoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundMoreResponse(struct soap *soap, const char *tag, int id, const _ns1__InboundMoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundMoreResponse), type))
		return soap->error;
	if (a->InboundMoreResult)
		soap_element_result(soap, "ns1:InboundMoreResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:InboundMoreResult", -1, &a->_ns1__InboundMoreResponse::InboundMoreResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundMoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundMoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundMoreResponse * SOAP_FMAC4 soap_in__ns1__InboundMoreResponse(struct soap *soap, const char *tag, _ns1__InboundMoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundMoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundMoreResponse, sizeof(_ns1__InboundMoreResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundMoreResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundMoreResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InboundMoreResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InboundMoreResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:InboundMoreResult", &a->_ns1__InboundMoreResponse::InboundMoreResult, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
				{	soap_flag_InboundMoreResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InboundMoreResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundMoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundMoreResponse, SOAP_TYPE__ns1__InboundMoreResponse, sizeof(_ns1__InboundMoreResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundMoreResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundMoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundMoreResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundMoreResponse *p;
	size_t k = sizeof(_ns1__InboundMoreResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundMoreResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundMoreResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundMoreResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundMoreResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundMoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundMoreResponse(soap, tag ? tag : "ns1:InboundMoreResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundMoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundMoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundMoreResponse * SOAP_FMAC4 soap_get__ns1__InboundMoreResponse(struct soap *soap, _ns1__InboundMoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundMoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundMore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundMore::model = NULL;
}

void _ns1__InboundMore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__InboundMore(soap, &this->_ns1__InboundMore::model);
#endif
}

int _ns1__InboundMore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundMore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundMore(struct soap *soap, const char *tag, int id, const _ns1__InboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundMore), type))
		return soap->error;
	if (soap_out_PointerTons1__InboundMore(soap, "ns1:model", -1, &a->_ns1__InboundMore::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundMore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundMore(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundMore * SOAP_FMAC4 soap_in__ns1__InboundMore(struct soap *soap, const char *tag, _ns1__InboundMore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundMore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundMore, sizeof(_ns1__InboundMore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundMore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundMore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InboundMore(soap, "ns1:model", &a->_ns1__InboundMore::model, "ns1:InboundMore"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundMore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundMore, SOAP_TYPE__ns1__InboundMore, sizeof(_ns1__InboundMore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundMore * SOAP_FMAC2 soap_instantiate__ns1__InboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundMore *p;
	size_t k = sizeof(_ns1__InboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundMore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundMore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundMore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundMore(soap, tag ? tag : "ns1:InboundMore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundMore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundMore(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundMore * SOAP_FMAC4 soap_get__ns1__InboundMore(struct soap *soap, _ns1__InboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInTwoInjectionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInTwoInjectionResponse::InboundInTwoInjectionResult = NULL;
}

void _ns1__InboundInTwoInjectionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, &this->_ns1__InboundInTwoInjectionResponse::InboundInTwoInjectionResult);
#endif
}

int _ns1__InboundInTwoInjectionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInTwoInjectionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInTwoInjectionResponse(struct soap *soap, const char *tag, int id, const _ns1__InboundInTwoInjectionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInTwoInjectionResponse), type))
		return soap->error;
	if (a->InboundInTwoInjectionResult)
		soap_element_result(soap, "ns1:InboundInTwoInjectionResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, "ns1:InboundInTwoInjectionResult", -1, &a->_ns1__InboundInTwoInjectionResponse::InboundInTwoInjectionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInTwoInjectionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInTwoInjectionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInTwoInjectionResponse * SOAP_FMAC4 soap_in__ns1__InboundInTwoInjectionResponse(struct soap *soap, const char *tag, _ns1__InboundInTwoInjectionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInTwoInjectionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInTwoInjectionResponse, sizeof(_ns1__InboundInTwoInjectionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInTwoInjectionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInTwoInjectionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InboundInTwoInjectionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InboundInTwoInjectionResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, "ns1:InboundInTwoInjectionResult", &a->_ns1__InboundInTwoInjectionResponse::InboundInTwoInjectionResult, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu"))
				{	soap_flag_InboundInTwoInjectionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InboundInTwoInjectionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInTwoInjectionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInTwoInjectionResponse, SOAP_TYPE__ns1__InboundInTwoInjectionResponse, sizeof(_ns1__InboundInTwoInjectionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInTwoInjectionResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInTwoInjectionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInTwoInjectionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInTwoInjectionResponse *p;
	size_t k = sizeof(_ns1__InboundInTwoInjectionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInTwoInjectionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInTwoInjectionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInTwoInjectionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInTwoInjectionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInTwoInjectionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInTwoInjectionResponse(soap, tag ? tag : "ns1:InboundInTwoInjectionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInTwoInjectionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInTwoInjectionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInTwoInjectionResponse * SOAP_FMAC4 soap_get__ns1__InboundInTwoInjectionResponse(struct soap *soap, _ns1__InboundInTwoInjectionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInTwoInjectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInTwoInjection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInTwoInjection::model = NULL;
}

void _ns1__InboundInTwoInjection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__InboundInTwoInjection(soap, &this->_ns1__InboundInTwoInjection::model);
#endif
}

int _ns1__InboundInTwoInjection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInTwoInjection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInTwoInjection(struct soap *soap, const char *tag, int id, const _ns1__InboundInTwoInjection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInTwoInjection), type))
		return soap->error;
	if (soap_out_PointerTons1__InboundInTwoInjection(soap, "ns1:model", -1, &a->_ns1__InboundInTwoInjection::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInTwoInjection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInTwoInjection(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInTwoInjection * SOAP_FMAC4 soap_in__ns1__InboundInTwoInjection(struct soap *soap, const char *tag, _ns1__InboundInTwoInjection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInTwoInjection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInTwoInjection, sizeof(_ns1__InboundInTwoInjection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInTwoInjection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInTwoInjection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InboundInTwoInjection(soap, "ns1:model", &a->_ns1__InboundInTwoInjection::model, "ns1:InboundInTwoInjection"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInTwoInjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInTwoInjection, SOAP_TYPE__ns1__InboundInTwoInjection, sizeof(_ns1__InboundInTwoInjection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate__ns1__InboundInTwoInjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInTwoInjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInTwoInjection *p;
	size_t k = sizeof(_ns1__InboundInTwoInjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInTwoInjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInTwoInjection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInTwoInjection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInTwoInjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInTwoInjection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInTwoInjection(soap, tag ? tag : "ns1:InboundInTwoInjection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInTwoInjection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInTwoInjection(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInTwoInjection * SOAP_FMAC4 soap_get__ns1__InboundInTwoInjection(struct soap *soap, _ns1__InboundInTwoInjection *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInTwoInjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInSFCContainerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInSFCContainerResponse::InboundInSFCContainerResult = NULL;
}

void _ns1__InboundInSFCContainerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__InboundInSFCContainerResponse::InboundInSFCContainerResult);
#endif
}

int _ns1__InboundInSFCContainerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInSFCContainerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInSFCContainerResponse(struct soap *soap, const char *tag, int id, const _ns1__InboundInSFCContainerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInSFCContainerResponse), type))
		return soap->error;
	if (a->InboundInSFCContainerResult)
		soap_element_result(soap, "ns1:InboundInSFCContainerResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:InboundInSFCContainerResult", -1, &a->_ns1__InboundInSFCContainerResponse::InboundInSFCContainerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInSFCContainerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInSFCContainerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInSFCContainerResponse * SOAP_FMAC4 soap_in__ns1__InboundInSFCContainerResponse(struct soap *soap, const char *tag, _ns1__InboundInSFCContainerResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInSFCContainerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInSFCContainerResponse, sizeof(_ns1__InboundInSFCContainerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInSFCContainerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInSFCContainerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InboundInSFCContainerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InboundInSFCContainerResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:InboundInSFCContainerResult", &a->_ns1__InboundInSFCContainerResponse::InboundInSFCContainerResult, "ns1:ApiResponseForScada"))
				{	soap_flag_InboundInSFCContainerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InboundInSFCContainerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInSFCContainerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInSFCContainerResponse, SOAP_TYPE__ns1__InboundInSFCContainerResponse, sizeof(_ns1__InboundInSFCContainerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInSFCContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInSFCContainerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInSFCContainerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInSFCContainerResponse *p;
	size_t k = sizeof(_ns1__InboundInSFCContainerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInSFCContainerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInSFCContainerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInSFCContainerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInSFCContainerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInSFCContainerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInSFCContainerResponse(soap, tag ? tag : "ns1:InboundInSFCContainerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInSFCContainerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInSFCContainerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInSFCContainerResponse * SOAP_FMAC4 soap_get__ns1__InboundInSFCContainerResponse(struct soap *soap, _ns1__InboundInSFCContainerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInSFCContainerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInSFCContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInSFCContainer::model = NULL;
}

void _ns1__InboundInSFCContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__InboundInSFCContainer(soap, &this->_ns1__InboundInSFCContainer::model);
#endif
}

int _ns1__InboundInSFCContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInSFCContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInSFCContainer(struct soap *soap, const char *tag, int id, const _ns1__InboundInSFCContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInSFCContainer), type))
		return soap->error;
	if (soap_out_PointerTons1__InboundInSFCContainer(soap, "ns1:model", -1, &a->_ns1__InboundInSFCContainer::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInSFCContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInSFCContainer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInSFCContainer * SOAP_FMAC4 soap_in__ns1__InboundInSFCContainer(struct soap *soap, const char *tag, _ns1__InboundInSFCContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInSFCContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInSFCContainer, sizeof(_ns1__InboundInSFCContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInSFCContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInSFCContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InboundInSFCContainer(soap, "ns1:model", &a->_ns1__InboundInSFCContainer::model, "ns1:InboundInSFCContainer"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInSFCContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInSFCContainer, SOAP_TYPE__ns1__InboundInSFCContainer, sizeof(_ns1__InboundInSFCContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate__ns1__InboundInSFCContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInSFCContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInSFCContainer *p;
	size_t k = sizeof(_ns1__InboundInSFCContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInSFCContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInSFCContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInSFCContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInSFCContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInSFCContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInSFCContainer(soap, tag ? tag : "ns1:InboundInSFCContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInSFCContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInSFCContainer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInSFCContainer * SOAP_FMAC4 soap_get__ns1__InboundInSFCContainer(struct soap *soap, _ns1__InboundInSFCContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInSFCContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInContainerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInContainerResponse::InboundInContainerResult = NULL;
}

void _ns1__InboundInContainerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__InboundInContainerResponse::InboundInContainerResult);
#endif
}

int _ns1__InboundInContainerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInContainerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInContainerResponse(struct soap *soap, const char *tag, int id, const _ns1__InboundInContainerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInContainerResponse), type))
		return soap->error;
	if (a->InboundInContainerResult)
		soap_element_result(soap, "ns1:InboundInContainerResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:InboundInContainerResult", -1, &a->_ns1__InboundInContainerResponse::InboundInContainerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInContainerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInContainerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInContainerResponse * SOAP_FMAC4 soap_in__ns1__InboundInContainerResponse(struct soap *soap, const char *tag, _ns1__InboundInContainerResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInContainerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInContainerResponse, sizeof(_ns1__InboundInContainerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInContainerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInContainerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InboundInContainerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InboundInContainerResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:InboundInContainerResult", &a->_ns1__InboundInContainerResponse::InboundInContainerResult, "ns1:ApiResponseForScada"))
				{	soap_flag_InboundInContainerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InboundInContainerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInContainerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInContainerResponse, SOAP_TYPE__ns1__InboundInContainerResponse, sizeof(_ns1__InboundInContainerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundInContainerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInContainerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInContainerResponse *p;
	size_t k = sizeof(_ns1__InboundInContainerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInContainerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInContainerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInContainerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInContainerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInContainerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInContainerResponse(soap, tag ? tag : "ns1:InboundInContainerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInContainerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInContainerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInContainerResponse * SOAP_FMAC4 soap_get__ns1__InboundInContainerResponse(struct soap *soap, _ns1__InboundInContainerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInContainerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundInContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundInContainer::model = NULL;
}

void _ns1__InboundInContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__InboundInContainer(soap, &this->_ns1__InboundInContainer::model);
#endif
}

int _ns1__InboundInContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundInContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundInContainer(struct soap *soap, const char *tag, int id, const _ns1__InboundInContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundInContainer), type))
		return soap->error;
	if (soap_out_PointerTons1__InboundInContainer(soap, "ns1:model", -1, &a->_ns1__InboundInContainer::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundInContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundInContainer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundInContainer * SOAP_FMAC4 soap_in__ns1__InboundInContainer(struct soap *soap, const char *tag, _ns1__InboundInContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundInContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundInContainer, sizeof(_ns1__InboundInContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundInContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundInContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InboundInContainer(soap, "ns1:model", &a->_ns1__InboundInContainer::model, "ns1:InboundInContainer"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundInContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundInContainer, SOAP_TYPE__ns1__InboundInContainer, sizeof(_ns1__InboundInContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate__ns1__InboundInContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundInContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundInContainer *p;
	size_t k = sizeof(_ns1__InboundInContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundInContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundInContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundInContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundInContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundInContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundInContainer(soap, tag ? tag : "ns1:InboundInContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundInContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundInContainer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundInContainer * SOAP_FMAC4 soap_get__ns1__InboundInContainer(struct soap *soap, _ns1__InboundInContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundInContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InboundResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InboundResponse::InboundResult = NULL;
}

void _ns1__InboundResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__InboundResponse::InboundResult);
#endif
}

int _ns1__InboundResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InboundResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InboundResponse(struct soap *soap, const char *tag, int id, const _ns1__InboundResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InboundResponse), type))
		return soap->error;
	if (a->InboundResult)
		soap_element_result(soap, "ns1:InboundResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:InboundResult", -1, &a->_ns1__InboundResponse::InboundResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InboundResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__InboundResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InboundResponse * SOAP_FMAC4 soap_in__ns1__InboundResponse(struct soap *soap, const char *tag, _ns1__InboundResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InboundResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InboundResponse, sizeof(_ns1__InboundResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InboundResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InboundResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InboundResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InboundResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:InboundResult", &a->_ns1__InboundResponse::InboundResult, "ns1:ApiResponseForScada"))
				{	soap_flag_InboundResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InboundResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InboundResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InboundResponse, SOAP_TYPE__ns1__InboundResponse, sizeof(_ns1__InboundResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InboundResponse * SOAP_FMAC2 soap_instantiate__ns1__InboundResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InboundResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InboundResponse *p;
	size_t k = sizeof(_ns1__InboundResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__InboundResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__InboundResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__InboundResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InboundResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__InboundResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InboundResponse(soap, tag ? tag : "ns1:InboundResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InboundResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InboundResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InboundResponse * SOAP_FMAC4 soap_get__ns1__InboundResponse(struct soap *soap, _ns1__InboundResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InboundResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Inbound::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Inbound::model = NULL;
}

void _ns1__Inbound::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Inbound(soap, &this->_ns1__Inbound::model);
#endif
}

int _ns1__Inbound::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Inbound(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Inbound(struct soap *soap, const char *tag, int id, const _ns1__Inbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Inbound), type))
		return soap->error;
	if (soap_out_PointerTons1__Inbound(soap, "ns1:model", -1, &a->_ns1__Inbound::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Inbound::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Inbound(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Inbound * SOAP_FMAC4 soap_in__ns1__Inbound(struct soap *soap, const char *tag, _ns1__Inbound *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Inbound*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Inbound, sizeof(_ns1__Inbound), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Inbound)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Inbound *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Inbound(soap, "ns1:model", &a->_ns1__Inbound::model, "ns1:Inbound"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Inbound *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Inbound, SOAP_TYPE__ns1__Inbound, sizeof(_ns1__Inbound), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Inbound * SOAP_FMAC2 soap_instantiate__ns1__Inbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Inbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Inbound *p;
	size_t k = sizeof(_ns1__Inbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Inbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Inbound);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Inbound, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Inbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Inbound::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Inbound(soap, tag ? tag : "ns1:Inbound", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Inbound::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Inbound(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Inbound * SOAP_FMAC4 soap_get__ns1__Inbound(struct soap *soap, _ns1__Inbound *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Inbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HeartbeatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__HeartbeatResponse::HeartbeatResult = NULL;
}

void _ns1__HeartbeatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__HeartbeatResponse::HeartbeatResult);
#endif
}

int _ns1__HeartbeatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HeartbeatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HeartbeatResponse(struct soap *soap, const char *tag, int id, const _ns1__HeartbeatResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HeartbeatResponse), type))
		return soap->error;
	if (a->HeartbeatResult)
		soap_element_result(soap, "ns1:HeartbeatResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:HeartbeatResult", -1, &a->_ns1__HeartbeatResponse::HeartbeatResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HeartbeatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__HeartbeatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HeartbeatResponse * SOAP_FMAC4 soap_in__ns1__HeartbeatResponse(struct soap *soap, const char *tag, _ns1__HeartbeatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HeartbeatResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HeartbeatResponse, sizeof(_ns1__HeartbeatResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HeartbeatResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HeartbeatResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HeartbeatResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HeartbeatResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:HeartbeatResult", &a->_ns1__HeartbeatResponse::HeartbeatResult, "ns1:ApiResponseForScada"))
				{	soap_flag_HeartbeatResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:HeartbeatResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HeartbeatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HeartbeatResponse, SOAP_TYPE__ns1__HeartbeatResponse, sizeof(_ns1__HeartbeatResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HeartbeatResponse * SOAP_FMAC2 soap_instantiate__ns1__HeartbeatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HeartbeatResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HeartbeatResponse *p;
	size_t k = sizeof(_ns1__HeartbeatResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__HeartbeatResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__HeartbeatResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__HeartbeatResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HeartbeatResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__HeartbeatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HeartbeatResponse(soap, tag ? tag : "ns1:HeartbeatResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HeartbeatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HeartbeatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HeartbeatResponse * SOAP_FMAC4 soap_get__ns1__HeartbeatResponse(struct soap *soap, _ns1__HeartbeatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HeartbeatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Heartbeat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Heartbeat::model = NULL;
}

void _ns1__Heartbeat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Heartbeat(soap, &this->_ns1__Heartbeat::model);
#endif
}

int _ns1__Heartbeat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Heartbeat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Heartbeat(struct soap *soap, const char *tag, int id, const _ns1__Heartbeat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Heartbeat), type))
		return soap->error;
	if (soap_out_PointerTons1__Heartbeat(soap, "ns1:model", -1, &a->_ns1__Heartbeat::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Heartbeat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Heartbeat(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Heartbeat * SOAP_FMAC4 soap_in__ns1__Heartbeat(struct soap *soap, const char *tag, _ns1__Heartbeat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Heartbeat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Heartbeat, sizeof(_ns1__Heartbeat), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Heartbeat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Heartbeat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Heartbeat(soap, "ns1:model", &a->_ns1__Heartbeat::model, "ns1:Heartbeat"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Heartbeat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Heartbeat, SOAP_TYPE__ns1__Heartbeat, sizeof(_ns1__Heartbeat), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Heartbeat * SOAP_FMAC2 soap_instantiate__ns1__Heartbeat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Heartbeat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Heartbeat *p;
	size_t k = sizeof(_ns1__Heartbeat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Heartbeat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Heartbeat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Heartbeat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Heartbeat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Heartbeat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Heartbeat(soap, tag ? tag : "ns1:Heartbeat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Heartbeat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Heartbeat(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Heartbeat * SOAP_FMAC4 soap_get__ns1__Heartbeat(struct soap *soap, _ns1__Heartbeat *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Heartbeat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GenerateCellSFCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GenerateCellSFCResponse::GenerateCellSFCResult = NULL;
}

void _ns1__GenerateCellSFCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfString(soap, &this->_ns1__GenerateCellSFCResponse::GenerateCellSFCResult);
#endif
}

int _ns1__GenerateCellSFCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GenerateCellSFCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GenerateCellSFCResponse(struct soap *soap, const char *tag, int id, const _ns1__GenerateCellSFCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GenerateCellSFCResponse), type))
		return soap->error;
	if (a->GenerateCellSFCResult)
		soap_element_result(soap, "ns1:GenerateCellSFCResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfString(soap, "ns1:GenerateCellSFCResult", -1, &a->_ns1__GenerateCellSFCResponse::GenerateCellSFCResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GenerateCellSFCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GenerateCellSFCResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GenerateCellSFCResponse * SOAP_FMAC4 soap_in__ns1__GenerateCellSFCResponse(struct soap *soap, const char *tag, _ns1__GenerateCellSFCResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GenerateCellSFCResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GenerateCellSFCResponse, sizeof(_ns1__GenerateCellSFCResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GenerateCellSFCResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GenerateCellSFCResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GenerateCellSFCResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GenerateCellSFCResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfString(soap, "ns1:GenerateCellSFCResult", &a->_ns1__GenerateCellSFCResponse::GenerateCellSFCResult, "ns1:ApiResponseDataForScadaOfString"))
				{	soap_flag_GenerateCellSFCResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GenerateCellSFCResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GenerateCellSFCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GenerateCellSFCResponse, SOAP_TYPE__ns1__GenerateCellSFCResponse, sizeof(_ns1__GenerateCellSFCResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GenerateCellSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__GenerateCellSFCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GenerateCellSFCResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GenerateCellSFCResponse *p;
	size_t k = sizeof(_ns1__GenerateCellSFCResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GenerateCellSFCResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GenerateCellSFCResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GenerateCellSFCResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GenerateCellSFCResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GenerateCellSFCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GenerateCellSFCResponse(soap, tag ? tag : "ns1:GenerateCellSFCResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GenerateCellSFCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GenerateCellSFCResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GenerateCellSFCResponse * SOAP_FMAC4 soap_get__ns1__GenerateCellSFCResponse(struct soap *soap, _ns1__GenerateCellSFCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GenerateCellSFCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GenerateCellSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GenerateCellSFC::model = NULL;
}

void _ns1__GenerateCellSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenerateCellSFC(soap, &this->_ns1__GenerateCellSFC::model);
#endif
}

int _ns1__GenerateCellSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GenerateCellSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GenerateCellSFC(struct soap *soap, const char *tag, int id, const _ns1__GenerateCellSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GenerateCellSFC), type))
		return soap->error;
	if (soap_out_PointerTons1__GenerateCellSFC(soap, "ns1:model", -1, &a->_ns1__GenerateCellSFC::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GenerateCellSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GenerateCellSFC(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GenerateCellSFC * SOAP_FMAC4 soap_in__ns1__GenerateCellSFC(struct soap *soap, const char *tag, _ns1__GenerateCellSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GenerateCellSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GenerateCellSFC, sizeof(_ns1__GenerateCellSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GenerateCellSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GenerateCellSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenerateCellSFC(soap, "ns1:model", &a->_ns1__GenerateCellSFC::model, "ns1:GenerateCellSFC"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GenerateCellSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GenerateCellSFC, SOAP_TYPE__ns1__GenerateCellSFC, sizeof(_ns1__GenerateCellSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate__ns1__GenerateCellSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GenerateCellSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GenerateCellSFC *p;
	size_t k = sizeof(_ns1__GenerateCellSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GenerateCellSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GenerateCellSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GenerateCellSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GenerateCellSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GenerateCellSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GenerateCellSFC(soap, tag ? tag : "ns1:GenerateCellSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GenerateCellSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GenerateCellSFC(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GenerateCellSFC * SOAP_FMAC4 soap_get__ns1__GenerateCellSFC(struct soap *soap, _ns1__GenerateCellSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GenerateCellSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FillingDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FillingDataResponse::FillingDataResult = NULL;
}

void _ns1__FillingDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__FillingDataResponse::FillingDataResult);
#endif
}

int _ns1__FillingDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FillingDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FillingDataResponse(struct soap *soap, const char *tag, int id, const _ns1__FillingDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FillingDataResponse), type))
		return soap->error;
	if (a->FillingDataResult)
		soap_element_result(soap, "ns1:FillingDataResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:FillingDataResult", -1, &a->_ns1__FillingDataResponse::FillingDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FillingDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FillingDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FillingDataResponse * SOAP_FMAC4 soap_in__ns1__FillingDataResponse(struct soap *soap, const char *tag, _ns1__FillingDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FillingDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FillingDataResponse, sizeof(_ns1__FillingDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FillingDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FillingDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FillingDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FillingDataResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:FillingDataResult", &a->_ns1__FillingDataResponse::FillingDataResult, "ns1:ApiResponseForScada"))
				{	soap_flag_FillingDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:FillingDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FillingDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FillingDataResponse, SOAP_TYPE__ns1__FillingDataResponse, sizeof(_ns1__FillingDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FillingDataResponse * SOAP_FMAC2 soap_instantiate__ns1__FillingDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FillingDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FillingDataResponse *p;
	size_t k = sizeof(_ns1__FillingDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FillingDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FillingDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FillingDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FillingDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FillingDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FillingDataResponse(soap, tag ? tag : "ns1:FillingDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FillingDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FillingDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FillingDataResponse * SOAP_FMAC4 soap_get__ns1__FillingDataResponse(struct soap *soap, _ns1__FillingDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FillingDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FillingData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FillingData::model = NULL;
}

void _ns1__FillingData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FillingData(soap, &this->_ns1__FillingData::model);
#endif
}

int _ns1__FillingData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FillingData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FillingData(struct soap *soap, const char *tag, int id, const _ns1__FillingData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FillingData), type))
		return soap->error;
	if (soap_out_PointerTons1__FillingData(soap, "ns1:model", -1, &a->_ns1__FillingData::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FillingData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FillingData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FillingData * SOAP_FMAC4 soap_in__ns1__FillingData(struct soap *soap, const char *tag, _ns1__FillingData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FillingData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FillingData, sizeof(_ns1__FillingData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FillingData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FillingData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FillingData(soap, "ns1:model", &a->_ns1__FillingData::model, "ns1:FillingData"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FillingData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FillingData, SOAP_TYPE__ns1__FillingData, sizeof(_ns1__FillingData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FillingData * SOAP_FMAC2 soap_instantiate__ns1__FillingData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FillingData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FillingData *p;
	size_t k = sizeof(_ns1__FillingData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FillingData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FillingData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FillingData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FillingData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FillingData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FillingData(soap, tag ? tag : "ns1:FillingData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FillingData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FillingData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FillingData * SOAP_FMAC4 soap_get__ns1__FillingData(struct soap *soap, _ns1__FillingData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FillingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FeedingDJInLaminatingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FeedingDJInLaminatingResponse::FeedingDJInLaminatingResult = NULL;
}

void _ns1__FeedingDJInLaminatingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__FeedingDJInLaminatingResponse::FeedingDJInLaminatingResult);
#endif
}

int _ns1__FeedingDJInLaminatingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FeedingDJInLaminatingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FeedingDJInLaminatingResponse(struct soap *soap, const char *tag, int id, const _ns1__FeedingDJInLaminatingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FeedingDJInLaminatingResponse), type))
		return soap->error;
	if (a->FeedingDJInLaminatingResult)
		soap_element_result(soap, "ns1:FeedingDJInLaminatingResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:FeedingDJInLaminatingResult", -1, &a->_ns1__FeedingDJInLaminatingResponse::FeedingDJInLaminatingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FeedingDJInLaminatingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FeedingDJInLaminatingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminatingResponse * SOAP_FMAC4 soap_in__ns1__FeedingDJInLaminatingResponse(struct soap *soap, const char *tag, _ns1__FeedingDJInLaminatingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FeedingDJInLaminatingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FeedingDJInLaminatingResponse, sizeof(_ns1__FeedingDJInLaminatingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FeedingDJInLaminatingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FeedingDJInLaminatingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeedingDJInLaminatingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeedingDJInLaminatingResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:FeedingDJInLaminatingResult", &a->_ns1__FeedingDJInLaminatingResponse::FeedingDJInLaminatingResult, "ns1:ApiResponseForScada"))
				{	soap_flag_FeedingDJInLaminatingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:FeedingDJInLaminatingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FeedingDJInLaminatingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FeedingDJInLaminatingResponse, SOAP_TYPE__ns1__FeedingDJInLaminatingResponse, sizeof(_ns1__FeedingDJInLaminatingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FeedingDJInLaminatingResponse * SOAP_FMAC2 soap_instantiate__ns1__FeedingDJInLaminatingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FeedingDJInLaminatingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FeedingDJInLaminatingResponse *p;
	size_t k = sizeof(_ns1__FeedingDJInLaminatingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FeedingDJInLaminatingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FeedingDJInLaminatingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FeedingDJInLaminatingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FeedingDJInLaminatingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FeedingDJInLaminatingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FeedingDJInLaminatingResponse(soap, tag ? tag : "ns1:FeedingDJInLaminatingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FeedingDJInLaminatingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FeedingDJInLaminatingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminatingResponse * SOAP_FMAC4 soap_get__ns1__FeedingDJInLaminatingResponse(struct soap *soap, _ns1__FeedingDJInLaminatingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FeedingDJInLaminatingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FeedingDJInLaminating::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FeedingDJInLaminating::model = NULL;
}

void _ns1__FeedingDJInLaminating::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, &this->_ns1__FeedingDJInLaminating::model);
#endif
}

int _ns1__FeedingDJInLaminating::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FeedingDJInLaminating(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, int id, const _ns1__FeedingDJInLaminating *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FeedingDJInLaminating), type))
		return soap->error;
	if (soap_out_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, "ns1:model", -1, &a->_ns1__FeedingDJInLaminating::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FeedingDJInLaminating::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FeedingDJInLaminating(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminating * SOAP_FMAC4 soap_in__ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, _ns1__FeedingDJInLaminating *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FeedingDJInLaminating*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FeedingDJInLaminating, sizeof(_ns1__FeedingDJInLaminating), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FeedingDJInLaminating)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FeedingDJInLaminating *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, "ns1:model", &a->_ns1__FeedingDJInLaminating::model, "ns1:FeedingDJInLaminatingByScadaDTO"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FeedingDJInLaminating *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FeedingDJInLaminating, SOAP_TYPE__ns1__FeedingDJInLaminating, sizeof(_ns1__FeedingDJInLaminating), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FeedingDJInLaminating * SOAP_FMAC2 soap_instantiate__ns1__FeedingDJInLaminating(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FeedingDJInLaminating(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FeedingDJInLaminating *p;
	size_t k = sizeof(_ns1__FeedingDJInLaminating);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FeedingDJInLaminating, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FeedingDJInLaminating);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FeedingDJInLaminating, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FeedingDJInLaminating location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FeedingDJInLaminating::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FeedingDJInLaminating(soap, tag ? tag : "ns1:FeedingDJInLaminating", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FeedingDJInLaminating::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FeedingDJInLaminating(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminating * SOAP_FMAC4 soap_get__ns1__FeedingDJInLaminating(struct soap *soap, _ns1__FeedingDJInLaminating *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FeedingDJInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FeedingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FeedingResponse::FeedingResult = NULL;
}

void _ns1__FeedingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__FeedingResponse::FeedingResult);
#endif
}

int _ns1__FeedingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FeedingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FeedingResponse(struct soap *soap, const char *tag, int id, const _ns1__FeedingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FeedingResponse), type))
		return soap->error;
	if (a->FeedingResult)
		soap_element_result(soap, "ns1:FeedingResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:FeedingResult", -1, &a->_ns1__FeedingResponse::FeedingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FeedingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FeedingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FeedingResponse * SOAP_FMAC4 soap_in__ns1__FeedingResponse(struct soap *soap, const char *tag, _ns1__FeedingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FeedingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FeedingResponse, sizeof(_ns1__FeedingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FeedingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FeedingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeedingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeedingResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:FeedingResult", &a->_ns1__FeedingResponse::FeedingResult, "ns1:ApiResponseForScada"))
				{	soap_flag_FeedingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:FeedingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FeedingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FeedingResponse, SOAP_TYPE__ns1__FeedingResponse, sizeof(_ns1__FeedingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FeedingResponse * SOAP_FMAC2 soap_instantiate__ns1__FeedingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FeedingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FeedingResponse *p;
	size_t k = sizeof(_ns1__FeedingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FeedingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FeedingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FeedingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FeedingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FeedingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FeedingResponse(soap, tag ? tag : "ns1:FeedingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FeedingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FeedingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FeedingResponse * SOAP_FMAC4 soap_get__ns1__FeedingResponse(struct soap *soap, _ns1__FeedingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FeedingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Feeding::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Feeding::model = NULL;
}

void _ns1__Feeding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FeedingByScadaDTO(soap, &this->_ns1__Feeding::model);
#endif
}

int _ns1__Feeding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Feeding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Feeding(struct soap *soap, const char *tag, int id, const _ns1__Feeding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Feeding), type))
		return soap->error;
	if (soap_out_PointerTons1__FeedingByScadaDTO(soap, "ns1:model", -1, &a->_ns1__Feeding::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Feeding::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Feeding(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Feeding * SOAP_FMAC4 soap_in__ns1__Feeding(struct soap *soap, const char *tag, _ns1__Feeding *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Feeding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Feeding, sizeof(_ns1__Feeding), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Feeding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Feeding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FeedingByScadaDTO(soap, "ns1:model", &a->_ns1__Feeding::model, "ns1:FeedingByScadaDTO"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Feeding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Feeding, SOAP_TYPE__ns1__Feeding, sizeof(_ns1__Feeding), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Feeding * SOAP_FMAC2 soap_instantiate__ns1__Feeding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Feeding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Feeding *p;
	size_t k = sizeof(_ns1__Feeding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Feeding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Feeding);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Feeding, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Feeding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Feeding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Feeding(soap, tag ? tag : "ns1:Feeding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Feeding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Feeding(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Feeding * SOAP_FMAC4 soap_get__ns1__Feeding(struct soap *soap, _ns1__Feeding *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Feeding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExamineExistsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExamineExistsResponse::ExamineExistsResult = NULL;
}

void _ns1__ExamineExistsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__ExamineExistsResponse::ExamineExistsResult);
#endif
}

int _ns1__ExamineExistsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExamineExistsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExamineExistsResponse(struct soap *soap, const char *tag, int id, const _ns1__ExamineExistsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExamineExistsResponse), type))
		return soap->error;
	if (a->ExamineExistsResult)
		soap_element_result(soap, "ns1:ExamineExistsResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:ExamineExistsResult", -1, &a->_ns1__ExamineExistsResponse::ExamineExistsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExamineExistsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ExamineExistsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExamineExistsResponse * SOAP_FMAC4 soap_in__ns1__ExamineExistsResponse(struct soap *soap, const char *tag, _ns1__ExamineExistsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExamineExistsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExamineExistsResponse, sizeof(_ns1__ExamineExistsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExamineExistsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExamineExistsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExamineExistsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExamineExistsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:ExamineExistsResult", &a->_ns1__ExamineExistsResponse::ExamineExistsResult, "ns1:ApiResponseForScada"))
				{	soap_flag_ExamineExistsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ExamineExistsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExamineExistsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExamineExistsResponse, SOAP_TYPE__ns1__ExamineExistsResponse, sizeof(_ns1__ExamineExistsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExamineExistsResponse * SOAP_FMAC2 soap_instantiate__ns1__ExamineExistsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExamineExistsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExamineExistsResponse *p;
	size_t k = sizeof(_ns1__ExamineExistsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExamineExistsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExamineExistsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExamineExistsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExamineExistsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExamineExistsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExamineExistsResponse(soap, tag ? tag : "ns1:ExamineExistsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExamineExistsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExamineExistsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExamineExistsResponse * SOAP_FMAC4 soap_get__ns1__ExamineExistsResponse(struct soap *soap, _ns1__ExamineExistsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExamineExistsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExamineExists::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExamineExists::model = NULL;
}

void _ns1__ExamineExists::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ExamineExistsByScadaDTO(soap, &this->_ns1__ExamineExists::model);
#endif
}

int _ns1__ExamineExists::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExamineExists(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExamineExists(struct soap *soap, const char *tag, int id, const _ns1__ExamineExists *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExamineExists), type))
		return soap->error;
	if (soap_out_PointerTons1__ExamineExistsByScadaDTO(soap, "ns1:model", -1, &a->_ns1__ExamineExists::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExamineExists::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ExamineExists(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExamineExists * SOAP_FMAC4 soap_in__ns1__ExamineExists(struct soap *soap, const char *tag, _ns1__ExamineExists *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExamineExists*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExamineExists, sizeof(_ns1__ExamineExists), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExamineExists)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExamineExists *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ExamineExistsByScadaDTO(soap, "ns1:model", &a->_ns1__ExamineExists::model, "ns1:ExamineExistsByScadaDTO"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExamineExists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExamineExists, SOAP_TYPE__ns1__ExamineExists, sizeof(_ns1__ExamineExists), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExamineExists * SOAP_FMAC2 soap_instantiate__ns1__ExamineExists(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExamineExists(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExamineExists *p;
	size_t k = sizeof(_ns1__ExamineExists);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExamineExists, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExamineExists);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExamineExists, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExamineExists location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExamineExists::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExamineExists(soap, tag ? tag : "ns1:ExamineExists", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExamineExists::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExamineExists(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExamineExists * SOAP_FMAC4 soap_get__ns1__ExamineExists(struct soap *soap, _ns1__ExamineExists *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExamineExists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EquipmentProductProcessParamResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EquipmentProductProcessParamResponse::EquipmentProductProcessParamResult = NULL;
}

void _ns1__EquipmentProductProcessParamResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, &this->_ns1__EquipmentProductProcessParamResponse::EquipmentProductProcessParamResult);
#endif
}

int _ns1__EquipmentProductProcessParamResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EquipmentProductProcessParamResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EquipmentProductProcessParamResponse(struct soap *soap, const char *tag, int id, const _ns1__EquipmentProductProcessParamResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EquipmentProductProcessParamResponse), type))
		return soap->error;
	if (a->EquipmentProductProcessParamResult)
		soap_element_result(soap, "ns1:EquipmentProductProcessParamResult");
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:EquipmentProductProcessParamResult", -1, &a->_ns1__EquipmentProductProcessParamResponse::EquipmentProductProcessParamResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EquipmentProductProcessParamResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EquipmentProductProcessParamResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParamResponse * SOAP_FMAC4 soap_in__ns1__EquipmentProductProcessParamResponse(struct soap *soap, const char *tag, _ns1__EquipmentProductProcessParamResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EquipmentProductProcessParamResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EquipmentProductProcessParamResponse, sizeof(_ns1__EquipmentProductProcessParamResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EquipmentProductProcessParamResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EquipmentProductProcessParamResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EquipmentProductProcessParamResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EquipmentProductProcessParamResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, "ns1:EquipmentProductProcessParamResult", &a->_ns1__EquipmentProductProcessParamResponse::EquipmentProductProcessParamResult, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
				{	soap_flag_EquipmentProductProcessParamResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:EquipmentProductProcessParamResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EquipmentProductProcessParamResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EquipmentProductProcessParamResponse, SOAP_TYPE__ns1__EquipmentProductProcessParamResponse, sizeof(_ns1__EquipmentProductProcessParamResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EquipmentProductProcessParamResponse * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProductProcessParamResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EquipmentProductProcessParamResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EquipmentProductProcessParamResponse *p;
	size_t k = sizeof(_ns1__EquipmentProductProcessParamResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__EquipmentProductProcessParamResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EquipmentProductProcessParamResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EquipmentProductProcessParamResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EquipmentProductProcessParamResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EquipmentProductProcessParamResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EquipmentProductProcessParamResponse(soap, tag ? tag : "ns1:EquipmentProductProcessParamResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EquipmentProductProcessParamResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EquipmentProductProcessParamResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParamResponse * SOAP_FMAC4 soap_get__ns1__EquipmentProductProcessParamResponse(struct soap *soap, _ns1__EquipmentProductProcessParamResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EquipmentProductProcessParamResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EquipmentProductProcessParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EquipmentProductProcessParam::model = NULL;
}

void _ns1__EquipmentProductProcessParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__EquipmentProductProcessParam(soap, &this->_ns1__EquipmentProductProcessParam::model);
#endif
}

int _ns1__EquipmentProductProcessParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EquipmentProductProcessParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, int id, const _ns1__EquipmentProductProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EquipmentProductProcessParam), type))
		return soap->error;
	if (soap_out_PointerTons1__EquipmentProductProcessParam(soap, "ns1:model", -1, &a->_ns1__EquipmentProductProcessParam::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EquipmentProductProcessParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EquipmentProductProcessParam(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_in__ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, _ns1__EquipmentProductProcessParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EquipmentProductProcessParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EquipmentProductProcessParam, sizeof(_ns1__EquipmentProductProcessParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EquipmentProductProcessParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EquipmentProductProcessParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__EquipmentProductProcessParam(soap, "ns1:model", &a->_ns1__EquipmentProductProcessParam::model, "ns1:EquipmentProductProcessParam"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EquipmentProductProcessParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EquipmentProductProcessParam, SOAP_TYPE__ns1__EquipmentProductProcessParam, sizeof(_ns1__EquipmentProductProcessParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProductProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EquipmentProductProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EquipmentProductProcessParam *p;
	size_t k = sizeof(_ns1__EquipmentProductProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__EquipmentProductProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EquipmentProductProcessParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EquipmentProductProcessParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EquipmentProductProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EquipmentProductProcessParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EquipmentProductProcessParam(soap, tag ? tag : "ns1:EquipmentProductProcessParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EquipmentProductProcessParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EquipmentProductProcessParam(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_get__ns1__EquipmentProductProcessParam(struct soap *soap, _ns1__EquipmentProductProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EquipmentProductProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EquipmentProcessParamResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EquipmentProcessParamResponse::EquipmentProcessParamResult = NULL;
}

void _ns1__EquipmentProcessParamResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__EquipmentProcessParamResponse::EquipmentProcessParamResult);
#endif
}

int _ns1__EquipmentProcessParamResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EquipmentProcessParamResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EquipmentProcessParamResponse(struct soap *soap, const char *tag, int id, const _ns1__EquipmentProcessParamResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EquipmentProcessParamResponse), type))
		return soap->error;
	if (a->EquipmentProcessParamResult)
		soap_element_result(soap, "ns1:EquipmentProcessParamResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:EquipmentProcessParamResult", -1, &a->_ns1__EquipmentProcessParamResponse::EquipmentProcessParamResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EquipmentProcessParamResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EquipmentProcessParamResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EquipmentProcessParamResponse * SOAP_FMAC4 soap_in__ns1__EquipmentProcessParamResponse(struct soap *soap, const char *tag, _ns1__EquipmentProcessParamResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EquipmentProcessParamResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EquipmentProcessParamResponse, sizeof(_ns1__EquipmentProcessParamResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EquipmentProcessParamResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EquipmentProcessParamResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EquipmentProcessParamResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EquipmentProcessParamResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:EquipmentProcessParamResult", &a->_ns1__EquipmentProcessParamResponse::EquipmentProcessParamResult, "ns1:ApiResponseForScada"))
				{	soap_flag_EquipmentProcessParamResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:EquipmentProcessParamResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EquipmentProcessParamResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EquipmentProcessParamResponse, SOAP_TYPE__ns1__EquipmentProcessParamResponse, sizeof(_ns1__EquipmentProcessParamResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EquipmentProcessParamResponse * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProcessParamResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EquipmentProcessParamResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EquipmentProcessParamResponse *p;
	size_t k = sizeof(_ns1__EquipmentProcessParamResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__EquipmentProcessParamResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EquipmentProcessParamResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EquipmentProcessParamResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EquipmentProcessParamResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EquipmentProcessParamResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EquipmentProcessParamResponse(soap, tag ? tag : "ns1:EquipmentProcessParamResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EquipmentProcessParamResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EquipmentProcessParamResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EquipmentProcessParamResponse * SOAP_FMAC4 soap_get__ns1__EquipmentProcessParamResponse(struct soap *soap, _ns1__EquipmentProcessParamResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EquipmentProcessParamResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EquipmentProcessParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EquipmentProcessParam::model = NULL;
}

void _ns1__EquipmentProcessParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__EquipmentProcessParam(soap, &this->_ns1__EquipmentProcessParam::model);
#endif
}

int _ns1__EquipmentProcessParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EquipmentProcessParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EquipmentProcessParam(struct soap *soap, const char *tag, int id, const _ns1__EquipmentProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EquipmentProcessParam), type))
		return soap->error;
	if (soap_out_PointerTons1__EquipmentProcessParam(soap, "ns1:model", -1, &a->_ns1__EquipmentProcessParam::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EquipmentProcessParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EquipmentProcessParam(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EquipmentProcessParam * SOAP_FMAC4 soap_in__ns1__EquipmentProcessParam(struct soap *soap, const char *tag, _ns1__EquipmentProcessParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EquipmentProcessParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EquipmentProcessParam, sizeof(_ns1__EquipmentProcessParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EquipmentProcessParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EquipmentProcessParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__EquipmentProcessParam(soap, "ns1:model", &a->_ns1__EquipmentProcessParam::model, "ns1:EquipmentProcessParam"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EquipmentProcessParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EquipmentProcessParam, SOAP_TYPE__ns1__EquipmentProcessParam, sizeof(_ns1__EquipmentProcessParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate__ns1__EquipmentProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EquipmentProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EquipmentProcessParam *p;
	size_t k = sizeof(_ns1__EquipmentProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__EquipmentProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EquipmentProcessParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EquipmentProcessParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EquipmentProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EquipmentProcessParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EquipmentProcessParam(soap, tag ? tag : "ns1:EquipmentProcessParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EquipmentProcessParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EquipmentProcessParam(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EquipmentProcessParam * SOAP_FMAC4 soap_get__ns1__EquipmentProcessParam(struct soap *soap, _ns1__EquipmentProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EquipmentProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownReasonResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DownReasonResponse::DownReasonResult = NULL;
}

void _ns1__DownReasonResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__DownReasonResponse::DownReasonResult);
#endif
}

int _ns1__DownReasonResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownReasonResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownReasonResponse(struct soap *soap, const char *tag, int id, const _ns1__DownReasonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownReasonResponse), type))
		return soap->error;
	if (a->DownReasonResult)
		soap_element_result(soap, "ns1:DownReasonResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:DownReasonResult", -1, &a->_ns1__DownReasonResponse::DownReasonResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownReasonResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__DownReasonResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownReasonResponse * SOAP_FMAC4 soap_in__ns1__DownReasonResponse(struct soap *soap, const char *tag, _ns1__DownReasonResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownReasonResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownReasonResponse, sizeof(_ns1__DownReasonResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownReasonResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownReasonResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownReasonResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownReasonResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:DownReasonResult", &a->_ns1__DownReasonResponse::DownReasonResult, "ns1:ApiResponseForScada"))
				{	soap_flag_DownReasonResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownReasonResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownReasonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownReasonResponse, SOAP_TYPE__ns1__DownReasonResponse, sizeof(_ns1__DownReasonResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownReasonResponse * SOAP_FMAC2 soap_instantiate__ns1__DownReasonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownReasonResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownReasonResponse *p;
	size_t k = sizeof(_ns1__DownReasonResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownReasonResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownReasonResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownReasonResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownReasonResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownReasonResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownReasonResponse(soap, tag ? tag : "ns1:DownReasonResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownReasonResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownReasonResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownReasonResponse * SOAP_FMAC4 soap_get__ns1__DownReasonResponse(struct soap *soap, _ns1__DownReasonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownReasonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DownReason::modelList = NULL;
}

void _ns1__DownReason::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfDownReason(soap, &this->_ns1__DownReason::modelList);
#endif
}

int _ns1__DownReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownReason(struct soap *soap, const char *tag, int id, const _ns1__DownReason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownReason), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDownReason(soap, "ns1:modelList", -1, &a->_ns1__DownReason::modelList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__DownReason(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownReason * SOAP_FMAC4 soap_in__ns1__DownReason(struct soap *soap, const char *tag, _ns1__DownReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownReason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownReason, sizeof(_ns1__DownReason), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownReason)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownReason *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_modelList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfDownReason(soap, "ns1:modelList", &a->_ns1__DownReason::modelList, "ns1:ArrayOfDownReason"))
				{	soap_flag_modelList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownReason, SOAP_TYPE__ns1__DownReason, sizeof(_ns1__DownReason), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownReason * SOAP_FMAC2 soap_instantiate__ns1__DownReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownReason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownReason *p;
	size_t k = sizeof(_ns1__DownReason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownReason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownReason);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownReason, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownReason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownReason(soap, tag ? tag : "ns1:DownReason", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownReason(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownReason * SOAP_FMAC4 soap_get__ns1__DownReason(struct soap *soap, _ns1__DownReason *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CCDFileUploadCompleteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CCDFileUploadCompleteResponse::CCDFileUploadCompleteResult = NULL;
}

void _ns1__CCDFileUploadCompleteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__CCDFileUploadCompleteResponse::CCDFileUploadCompleteResult);
#endif
}

int _ns1__CCDFileUploadCompleteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CCDFileUploadCompleteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CCDFileUploadCompleteResponse(struct soap *soap, const char *tag, int id, const _ns1__CCDFileUploadCompleteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CCDFileUploadCompleteResponse), type))
		return soap->error;
	if (a->CCDFileUploadCompleteResult)
		soap_element_result(soap, "ns1:CCDFileUploadCompleteResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:CCDFileUploadCompleteResult", -1, &a->_ns1__CCDFileUploadCompleteResponse::CCDFileUploadCompleteResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CCDFileUploadCompleteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CCDFileUploadCompleteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CCDFileUploadCompleteResponse * SOAP_FMAC4 soap_in__ns1__CCDFileUploadCompleteResponse(struct soap *soap, const char *tag, _ns1__CCDFileUploadCompleteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CCDFileUploadCompleteResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CCDFileUploadCompleteResponse, sizeof(_ns1__CCDFileUploadCompleteResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CCDFileUploadCompleteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CCDFileUploadCompleteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CCDFileUploadCompleteResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CCDFileUploadCompleteResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:CCDFileUploadCompleteResult", &a->_ns1__CCDFileUploadCompleteResponse::CCDFileUploadCompleteResult, "ns1:ApiResponseForScada"))
				{	soap_flag_CCDFileUploadCompleteResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CCDFileUploadCompleteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CCDFileUploadCompleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CCDFileUploadCompleteResponse, SOAP_TYPE__ns1__CCDFileUploadCompleteResponse, sizeof(_ns1__CCDFileUploadCompleteResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CCDFileUploadCompleteResponse * SOAP_FMAC2 soap_instantiate__ns1__CCDFileUploadCompleteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CCDFileUploadCompleteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CCDFileUploadCompleteResponse *p;
	size_t k = sizeof(_ns1__CCDFileUploadCompleteResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CCDFileUploadCompleteResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CCDFileUploadCompleteResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CCDFileUploadCompleteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CCDFileUploadCompleteResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CCDFileUploadCompleteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CCDFileUploadCompleteResponse(soap, tag ? tag : "ns1:CCDFileUploadCompleteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CCDFileUploadCompleteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CCDFileUploadCompleteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CCDFileUploadCompleteResponse * SOAP_FMAC4 soap_get__ns1__CCDFileUploadCompleteResponse(struct soap *soap, _ns1__CCDFileUploadCompleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CCDFileUploadCompleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CCDFileUploadComplete::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CCDFileUploadComplete::model = NULL;
}

void _ns1__CCDFileUploadComplete::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CCDFileUploadComplete(soap, &this->_ns1__CCDFileUploadComplete::model);
#endif
}

int _ns1__CCDFileUploadComplete::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CCDFileUploadComplete(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, int id, const _ns1__CCDFileUploadComplete *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CCDFileUploadComplete), type))
		return soap->error;
	if (soap_out_PointerTons1__CCDFileUploadComplete(soap, "ns1:model", -1, &a->_ns1__CCDFileUploadComplete::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CCDFileUploadComplete::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CCDFileUploadComplete(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_in__ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, _ns1__CCDFileUploadComplete *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CCDFileUploadComplete*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CCDFileUploadComplete, sizeof(_ns1__CCDFileUploadComplete), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CCDFileUploadComplete)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CCDFileUploadComplete *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CCDFileUploadComplete(soap, "ns1:model", &a->_ns1__CCDFileUploadComplete::model, "ns1:CCDFileUploadComplete"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CCDFileUploadComplete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CCDFileUploadComplete, SOAP_TYPE__ns1__CCDFileUploadComplete, sizeof(_ns1__CCDFileUploadComplete), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate__ns1__CCDFileUploadComplete(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CCDFileUploadComplete(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CCDFileUploadComplete *p;
	size_t k = sizeof(_ns1__CCDFileUploadComplete);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CCDFileUploadComplete, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CCDFileUploadComplete);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CCDFileUploadComplete, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CCDFileUploadComplete location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CCDFileUploadComplete::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CCDFileUploadComplete(soap, tag ? tag : "ns1:CCDFileUploadComplete", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CCDFileUploadComplete::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CCDFileUploadComplete(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_get__ns1__CCDFileUploadComplete(struct soap *soap, _ns1__CCDFileUploadComplete *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CCDFileUploadComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindSFCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindSFCResponse::BindSFCResult = NULL;
}

void _ns1__BindSFCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__BindSFCResponse::BindSFCResult);
#endif
}

int _ns1__BindSFCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindSFCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindSFCResponse(struct soap *soap, const char *tag, int id, const _ns1__BindSFCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindSFCResponse), type))
		return soap->error;
	if (a->BindSFCResult)
		soap_element_result(soap, "ns1:BindSFCResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:BindSFCResult", -1, &a->_ns1__BindSFCResponse::BindSFCResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindSFCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__BindSFCResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindSFCResponse * SOAP_FMAC4 soap_in__ns1__BindSFCResponse(struct soap *soap, const char *tag, _ns1__BindSFCResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindSFCResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindSFCResponse, sizeof(_ns1__BindSFCResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindSFCResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindSFCResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BindSFCResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BindSFCResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:BindSFCResult", &a->_ns1__BindSFCResponse::BindSFCResult, "ns1:ApiResponseForScada"))
				{	soap_flag_BindSFCResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BindSFCResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindSFCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindSFCResponse, SOAP_TYPE__ns1__BindSFCResponse, sizeof(_ns1__BindSFCResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindSFCResponse * SOAP_FMAC2 soap_instantiate__ns1__BindSFCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindSFCResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindSFCResponse *p;
	size_t k = sizeof(_ns1__BindSFCResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindSFCResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindSFCResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindSFCResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindSFCResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindSFCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindSFCResponse(soap, tag ? tag : "ns1:BindSFCResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindSFCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindSFCResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindSFCResponse * SOAP_FMAC4 soap_get__ns1__BindSFCResponse(struct soap *soap, _ns1__BindSFCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindSFCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindSFC::model = NULL;
}

void _ns1__BindSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BindSFCByScadaDTO(soap, &this->_ns1__BindSFC::model);
#endif
}

int _ns1__BindSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindSFC(struct soap *soap, const char *tag, int id, const _ns1__BindSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindSFC), type))
		return soap->error;
	if (soap_out_PointerTons1__BindSFCByScadaDTO(soap, "ns1:model", -1, &a->_ns1__BindSFC::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__BindSFC(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindSFC * SOAP_FMAC4 soap_in__ns1__BindSFC(struct soap *soap, const char *tag, _ns1__BindSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindSFC, sizeof(_ns1__BindSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BindSFCByScadaDTO(soap, "ns1:model", &a->_ns1__BindSFC::model, "ns1:BindSFCByScadaDTO"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindSFC, SOAP_TYPE__ns1__BindSFC, sizeof(_ns1__BindSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindSFC * SOAP_FMAC2 soap_instantiate__ns1__BindSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindSFC *p;
	size_t k = sizeof(_ns1__BindSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindSFC(soap, tag ? tag : "ns1:BindSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindSFC(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindSFC * SOAP_FMAC4 soap_get__ns1__BindSFC(struct soap *soap, _ns1__BindSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindContainerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindContainerResponse::BindContainerResult = NULL;
}

void _ns1__BindContainerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__BindContainerResponse::BindContainerResult);
#endif
}

int _ns1__BindContainerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindContainerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindContainerResponse(struct soap *soap, const char *tag, int id, const _ns1__BindContainerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindContainerResponse), type))
		return soap->error;
	if (a->BindContainerResult)
		soap_element_result(soap, "ns1:BindContainerResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:BindContainerResult", -1, &a->_ns1__BindContainerResponse::BindContainerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindContainerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__BindContainerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindContainerResponse * SOAP_FMAC4 soap_in__ns1__BindContainerResponse(struct soap *soap, const char *tag, _ns1__BindContainerResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindContainerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindContainerResponse, sizeof(_ns1__BindContainerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindContainerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindContainerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BindContainerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BindContainerResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:BindContainerResult", &a->_ns1__BindContainerResponse::BindContainerResult, "ns1:ApiResponseForScada"))
				{	soap_flag_BindContainerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BindContainerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindContainerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindContainerResponse, SOAP_TYPE__ns1__BindContainerResponse, sizeof(_ns1__BindContainerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindContainerResponse * SOAP_FMAC2 soap_instantiate__ns1__BindContainerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindContainerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindContainerResponse *p;
	size_t k = sizeof(_ns1__BindContainerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindContainerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindContainerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindContainerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindContainerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindContainerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindContainerResponse(soap, tag ? tag : "ns1:BindContainerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindContainerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindContainerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindContainerResponse * SOAP_FMAC4 soap_get__ns1__BindContainerResponse(struct soap *soap, _ns1__BindContainerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindContainerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindContainer::model = NULL;
}

void _ns1__BindContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BindContainer(soap, &this->_ns1__BindContainer::model);
#endif
}

int _ns1__BindContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindContainer(struct soap *soap, const char *tag, int id, const _ns1__BindContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindContainer), type))
		return soap->error;
	if (soap_out_PointerTons1__BindContainer(soap, "ns1:model", -1, &a->_ns1__BindContainer::model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__BindContainer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindContainer * SOAP_FMAC4 soap_in__ns1__BindContainer(struct soap *soap, const char *tag, _ns1__BindContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindContainer, sizeof(_ns1__BindContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_model1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BindContainer(soap, "ns1:model", &a->_ns1__BindContainer::model, "ns1:BindContainer"))
				{	soap_flag_model1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindContainer, SOAP_TYPE__ns1__BindContainer, sizeof(_ns1__BindContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindContainer * SOAP_FMAC2 soap_instantiate__ns1__BindContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindContainer *p;
	size_t k = sizeof(_ns1__BindContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindContainer(soap, tag ? tag : "ns1:BindContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindContainer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindContainer * SOAP_FMAC4 soap_get__ns1__BindContainer(struct soap *soap, _ns1__BindContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AlarmResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AlarmResponse::AlarmResult = NULL;
}

void _ns1__AlarmResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApiResponseForScada(soap, &this->_ns1__AlarmResponse::AlarmResult);
#endif
}

int _ns1__AlarmResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlarmResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlarmResponse(struct soap *soap, const char *tag, int id, const _ns1__AlarmResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlarmResponse), type))
		return soap->error;
	if (a->AlarmResult)
		soap_element_result(soap, "ns1:AlarmResult");
	if (soap_out_PointerTons1__ApiResponseForScada(soap, "ns1:AlarmResult", -1, &a->_ns1__AlarmResponse::AlarmResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlarmResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AlarmResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlarmResponse * SOAP_FMAC4 soap_in__ns1__AlarmResponse(struct soap *soap, const char *tag, _ns1__AlarmResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlarmResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlarmResponse, sizeof(_ns1__AlarmResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AlarmResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AlarmResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AlarmResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlarmResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApiResponseForScada(soap, "ns1:AlarmResult", &a->_ns1__AlarmResponse::AlarmResult, "ns1:ApiResponseForScada"))
				{	soap_flag_AlarmResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AlarmResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlarmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlarmResponse, SOAP_TYPE__ns1__AlarmResponse, sizeof(_ns1__AlarmResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AlarmResponse * SOAP_FMAC2 soap_instantiate__ns1__AlarmResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlarmResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AlarmResponse *p;
	size_t k = sizeof(_ns1__AlarmResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__AlarmResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AlarmResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AlarmResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AlarmResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AlarmResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AlarmResponse(soap, tag ? tag : "ns1:AlarmResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlarmResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlarmResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlarmResponse * SOAP_FMAC4 soap_get__ns1__AlarmResponse(struct soap *soap, _ns1__AlarmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlarmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Alarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Alarm::modelList = NULL;
}

void _ns1__Alarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAlarm(soap, &this->_ns1__Alarm::modelList);
#endif
}

int _ns1__Alarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Alarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Alarm(struct soap *soap, const char *tag, int id, const _ns1__Alarm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Alarm), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAlarm(soap, "ns1:modelList", -1, &a->_ns1__Alarm::modelList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Alarm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Alarm(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Alarm * SOAP_FMAC4 soap_in__ns1__Alarm(struct soap *soap, const char *tag, _ns1__Alarm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Alarm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Alarm, sizeof(_ns1__Alarm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Alarm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Alarm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_modelList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAlarm(soap, "ns1:modelList", &a->_ns1__Alarm::modelList, "ns1:ArrayOfAlarm"))
				{	soap_flag_modelList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Alarm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Alarm, SOAP_TYPE__ns1__Alarm, sizeof(_ns1__Alarm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Alarm * SOAP_FMAC2 soap_instantiate__ns1__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Alarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Alarm *p;
	size_t k = sizeof(_ns1__Alarm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Alarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Alarm);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Alarm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Alarm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Alarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Alarm(soap, tag ? tag : "ns1:Alarm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Alarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Alarm(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Alarm * SOAP_FMAC4 soap_get__ns1__Alarm(struct soap *soap, _ns1__Alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__UnBindSFCByScadaDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__UnBindSFCByScadaDTO::SFC = NULL;
	this->ns1__UnBindSFCByScadaDTO::BindSFCs = NULL;
}

void ns1__UnBindSFCByScadaDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__UnBindSFCByScadaDTO::SFC);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__UnBindSFCByScadaDTO::BindSFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__UnBindSFCByScadaDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UnBindSFCByScadaDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UnBindSFCByScadaDTO(struct soap *soap, const char *tag, int id, const ns1__UnBindSFCByScadaDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UnBindSFCByScadaDTO), type ? type : "ns1:UnBindSFCByScadaDTO"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__UnBindSFCByScadaDTO::SFC, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindSFCs", -1, &a->ns1__UnBindSFCByScadaDTO::BindSFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__UnBindSFCByScadaDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__UnBindSFCByScadaDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UnBindSFCByScadaDTO * SOAP_FMAC4 soap_in_ns1__UnBindSFCByScadaDTO(struct soap *soap, const char *tag, ns1__UnBindSFCByScadaDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UnBindSFCByScadaDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, sizeof(ns1__UnBindSFCByScadaDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__UnBindSFCByScadaDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__UnBindSFCByScadaDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_BindSFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__UnBindSFCByScadaDTO::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_BindSFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindSFCs", &a->ns1__UnBindSFCByScadaDTO::BindSFCs, "ns1:ArrayOfString"))
				{	soap_flag_BindSFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__UnBindSFCByScadaDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, sizeof(ns1__UnBindSFCByScadaDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__UnBindSFCByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__UnBindSFCByScadaDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UnBindSFCByScadaDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__UnBindSFCByScadaDTO *p;
	size_t k = sizeof(ns1__UnBindSFCByScadaDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__UnBindSFCByScadaDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__UnBindSFCByScadaDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__UnBindSFCByScadaDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__UnBindSFCByScadaDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__UnBindSFCByScadaDTO(soap, tag ? tag : "ns1:UnBindSFCByScadaDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UnBindSFCByScadaDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UnBindSFCByScadaDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UnBindSFCByScadaDTO * SOAP_FMAC4 soap_get_ns1__UnBindSFCByScadaDTO(struct soap *soap, ns1__UnBindSFCByScadaDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UnBindSFCByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ToolLife::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__ToolLife::ToolCode = NULL;
	soap_default_double(soap, &this->ns1__ToolLife::UsedLife);
}

void ns1__ToolLife::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ToolLife::ToolCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__ToolLife::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ToolLife(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ToolLife(struct soap *soap, const char *tag, int id, const ns1__ToolLife *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ToolLife), type ? type : "ns1:ToolLife"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ToolCode", -1, (wchar_t*const*)&a->ns1__ToolLife::ToolCode, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:UsedLife", -1, &a->ns1__ToolLife::UsedLife, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ToolLife::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ToolLife(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ToolLife * SOAP_FMAC4 soap_in_ns1__ToolLife(struct soap *soap, const char *tag, ns1__ToolLife *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ToolLife*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ToolLife, sizeof(ns1__ToolLife), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ToolLife)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ToolLife *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ToolCode1 = 1;
	size_t soap_flag_UsedLife1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ToolCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ToolCode", (wchar_t**)&a->ns1__ToolLife::ToolCode, "xsd:string"))
				{	soap_flag_ToolCode1--;
					continue;
				}
			}
			if (soap_flag_UsedLife1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:UsedLife", &a->ns1__ToolLife::UsedLife, "xsd:double"))
				{	soap_flag_UsedLife1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_UsedLife1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ToolLife *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ToolLife, SOAP_TYPE_ns1__ToolLife, sizeof(ns1__ToolLife), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ToolLife * SOAP_FMAC2 soap_instantiate_ns1__ToolLife(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ToolLife(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ToolLife *p;
	size_t k = sizeof(ns1__ToolLife);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ToolLife, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ToolLife);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ToolLife, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ToolLife location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ToolLife::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ToolLife(soap, tag ? tag : "ns1:ToolLife", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ToolLife::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ToolLife(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ToolLife * SOAP_FMAC4 soap_get_ns1__ToolLife(struct soap *soap, ns1__ToolLife *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ToolLife(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ToolBind::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__ToolBind::ToolCode = NULL;
}

void ns1__ToolBind::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ToolBind::ToolCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__ToolBind::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ToolBind(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ToolBind(struct soap *soap, const char *tag, int id, const ns1__ToolBind *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ToolBind), type ? type : "ns1:ToolBind"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ToolCode", -1, (wchar_t*const*)&a->ns1__ToolBind::ToolCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ToolBind::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ToolBind(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ToolBind * SOAP_FMAC4 soap_in_ns1__ToolBind(struct soap *soap, const char *tag, ns1__ToolBind *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ToolBind*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ToolBind, sizeof(ns1__ToolBind), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ToolBind)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ToolBind *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ToolCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ToolCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ToolCode", (wchar_t**)&a->ns1__ToolBind::ToolCode, "xsd:string"))
				{	soap_flag_ToolCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ToolBind *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ToolBind, SOAP_TYPE_ns1__ToolBind, sizeof(ns1__ToolBind), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ToolBind * SOAP_FMAC2 soap_instantiate_ns1__ToolBind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ToolBind(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ToolBind *p;
	size_t k = sizeof(ns1__ToolBind);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ToolBind, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ToolBind);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ToolBind, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ToolBind location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ToolBind::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ToolBind(soap, tag ? tag : "ns1:ToolBind", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ToolBind::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ToolBind(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ToolBind * SOAP_FMAC4 soap_get_ns1__ToolBind(struct soap *soap, ns1__ToolBind *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ToolBind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__State::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__State::StateCode = NULL;
}

void ns1__State::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__State::StateCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__State::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__State(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__State(struct soap *soap, const char *tag, int id, const ns1__State *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__State), type ? type : "ns1:State"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:StateCode", -1, (wchar_t*const*)&a->ns1__State::StateCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__State::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__State(soap, tag, this, type);
}

SOAP_FMAC3 ns1__State * SOAP_FMAC4 soap_in_ns1__State(struct soap *soap, const char *tag, ns1__State *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__State*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__State, sizeof(ns1__State), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__State)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__State *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_StateCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_StateCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:StateCode", (wchar_t**)&a->ns1__State::StateCode, "xsd:string"))
				{	soap_flag_StateCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__State *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__State, SOAP_TYPE_ns1__State, sizeof(ns1__State), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__State * SOAP_FMAC2 soap_instantiate_ns1__State(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__State(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__State *p;
	size_t k = sizeof(ns1__State);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__State, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__State);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__State, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__State location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__State::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__State(soap, tag ? tag : "ns1:State", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__State::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__State(soap, this, tag, type);
}

SOAP_FMAC3 ns1__State * SOAP_FMAC4 soap_get_ns1__State(struct soap *soap, ns1__State *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeVersionExamine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__RecipeVersionExamine::RecipeCode = NULL;
	this->ns1__RecipeVersionExamine::Version = NULL;
}

void ns1__RecipeVersionExamine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeVersionExamine::RecipeCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeVersionExamine::Version);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__RecipeVersionExamine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeVersionExamine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeVersionExamine(struct soap *soap, const char *tag, int id, const ns1__RecipeVersionExamine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeVersionExamine), type ? type : "ns1:RecipeVersionExamine"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:RecipeCode", -1, (wchar_t*const*)&a->ns1__RecipeVersionExamine::RecipeCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Version", -1, (wchar_t*const*)&a->ns1__RecipeVersionExamine::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeVersionExamine::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeVersionExamine(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeVersionExamine * SOAP_FMAC4 soap_in_ns1__RecipeVersionExamine(struct soap *soap, const char *tag, ns1__RecipeVersionExamine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeVersionExamine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeVersionExamine, sizeof(ns1__RecipeVersionExamine), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeVersionExamine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeVersionExamine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_RecipeCode1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_RecipeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:RecipeCode", (wchar_t**)&a->ns1__RecipeVersionExamine::RecipeCode, "xsd:string"))
				{	soap_flag_RecipeCode1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Version", (wchar_t**)&a->ns1__RecipeVersionExamine::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeVersionExamine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeVersionExamine, SOAP_TYPE_ns1__RecipeVersionExamine, sizeof(ns1__RecipeVersionExamine), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate_ns1__RecipeVersionExamine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeVersionExamine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeVersionExamine *p;
	size_t k = sizeof(ns1__RecipeVersionExamine);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeVersionExamine, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeVersionExamine);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeVersionExamine, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeVersionExamine location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeVersionExamine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeVersionExamine(soap, tag ? tag : "ns1:RecipeVersionExamine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeVersionExamine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeVersionExamine(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeVersionExamine * SOAP_FMAC4 soap_get_ns1__RecipeVersionExamine(struct soap *soap, ns1__RecipeVersionExamine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeVersionExamine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeListGetForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RecipeListGetForEqu::RecipeCode = NULL;
	this->ns1__RecipeListGetForEqu::Version = NULL;
	this->ns1__RecipeListGetForEqu::ProductCode = NULL;
	soap_default_dateTime(soap, &this->ns1__RecipeListGetForEqu::LastUpdateOnTime);
}

void ns1__RecipeListGetForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeListGetForEqu::RecipeCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeListGetForEqu::Version);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeListGetForEqu::ProductCode);
#endif
}

int ns1__RecipeListGetForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeListGetForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeListGetForEqu(struct soap *soap, const char *tag, int id, const ns1__RecipeListGetForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeListGetForEqu), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:RecipeCode", -1, (wchar_t*const*)&a->ns1__RecipeListGetForEqu::RecipeCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Version", -1, (wchar_t*const*)&a->ns1__RecipeListGetForEqu::Version, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ProductCode", -1, (wchar_t*const*)&a->ns1__RecipeListGetForEqu::ProductCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LastUpdateOnTime", -1, &a->ns1__RecipeListGetForEqu::LastUpdateOnTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeListGetForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeListGetForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeListGetForEqu * SOAP_FMAC4 soap_in_ns1__RecipeListGetForEqu(struct soap *soap, const char *tag, ns1__RecipeListGetForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeListGetForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeListGetForEqu, sizeof(ns1__RecipeListGetForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeListGetForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeListGetForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecipeCode1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_ProductCode1 = 1;
	size_t soap_flag_LastUpdateOnTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecipeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:RecipeCode", (wchar_t**)&a->ns1__RecipeListGetForEqu::RecipeCode, "xsd:string"))
				{	soap_flag_RecipeCode1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Version", (wchar_t**)&a->ns1__RecipeListGetForEqu::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_ProductCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ProductCode", (wchar_t**)&a->ns1__RecipeListGetForEqu::ProductCode, "xsd:string"))
				{	soap_flag_ProductCode1--;
					continue;
				}
			}
			if (soap_flag_LastUpdateOnTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LastUpdateOnTime", &a->ns1__RecipeListGetForEqu::LastUpdateOnTime, "xsd:dateTime"))
				{	soap_flag_LastUpdateOnTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LastUpdateOnTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeListGetForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeListGetForEqu, SOAP_TYPE_ns1__RecipeListGetForEqu, sizeof(ns1__RecipeListGetForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeListGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeListGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeListGetForEqu *p;
	size_t k = sizeof(ns1__RecipeListGetForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeListGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeListGetForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeListGetForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeListGetForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeListGetForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeListGetForEqu(soap, tag ? tag : "ns1:RecipeListGetForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeListGetForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeListGetForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeListGetForEqu * SOAP_FMAC4 soap_get_ns1__RecipeListGetForEqu(struct soap *soap, ns1__RecipeListGetForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfRecipeListGetForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap, &this->ns1__ArrayOfRecipeListGetForEqu::RecipeListGetForEqu);
}

void ns1__ArrayOfRecipeListGetForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap, &this->ns1__ArrayOfRecipeListGetForEqu::RecipeListGetForEqu);
#endif
}

int ns1__ArrayOfRecipeListGetForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfRecipeListGetForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfRecipeListGetForEqu(struct soap *soap, const char *tag, int id, const ns1__ArrayOfRecipeListGetForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap, "ns1:RecipeListGetForEqu", -1, &a->ns1__ArrayOfRecipeListGetForEqu::RecipeListGetForEqu, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfRecipeListGetForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfRecipeListGetForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeListGetForEqu * SOAP_FMAC4 soap_in_ns1__ArrayOfRecipeListGetForEqu(struct soap *soap, const char *tag, ns1__ArrayOfRecipeListGetForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfRecipeListGetForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, sizeof(ns1__ArrayOfRecipeListGetForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfRecipeListGetForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap, "ns1:RecipeListGetForEqu", &a->ns1__ArrayOfRecipeListGetForEqu::RecipeListGetForEqu, "ns1:RecipeListGetForEqu"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfRecipeListGetForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, sizeof(ns1__ArrayOfRecipeListGetForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfRecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeListGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfRecipeListGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfRecipeListGetForEqu *p;
	size_t k = sizeof(ns1__ArrayOfRecipeListGetForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfRecipeListGetForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfRecipeListGetForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfRecipeListGetForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfRecipeListGetForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfRecipeListGetForEqu(soap, tag ? tag : "ns1:ArrayOfRecipeListGetForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfRecipeListGetForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfRecipeListGetForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeListGetForEqu * SOAP_FMAC4 soap_get_ns1__ArrayOfRecipeListGetForEqu(struct soap *soap, ns1__ArrayOfRecipeListGetForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfRecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::Data = NULL;
}

void ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfRecipeListGetForEqu(soap, &this->ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::Data);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, const char *tag, int id, const ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu), type ? type : "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfRecipeListGetForEqu(soap, "ns1:Data", -1, &a->ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu * SOAP_FMAC4 soap_in_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfRecipeListGetForEqu(soap, "ns1:Data", &a->ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::Data, "ns1:ArrayOfRecipeListGetForEqu"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *p;
	size_t k = sizeof(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu * SOAP_FMAC4 soap_get_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeListGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__RecipeListGet::ProductCode = NULL;
}

void ns1__RecipeListGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeListGet::ProductCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__RecipeListGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeListGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeListGet(struct soap *soap, const char *tag, int id, const ns1__RecipeListGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeListGet), type ? type : "ns1:RecipeListGet"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ProductCode", -1, (wchar_t*const*)&a->ns1__RecipeListGet::ProductCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeListGet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeListGet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeListGet * SOAP_FMAC4 soap_in_ns1__RecipeListGet(struct soap *soap, const char *tag, ns1__RecipeListGet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeListGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeListGet, sizeof(ns1__RecipeListGet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeListGet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeListGet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ProductCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ProductCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ProductCode", (wchar_t**)&a->ns1__RecipeListGet::ProductCode, "xsd:string"))
				{	soap_flag_ProductCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeListGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeListGet, SOAP_TYPE_ns1__RecipeListGet, sizeof(ns1__RecipeListGet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeListGet * SOAP_FMAC2 soap_instantiate_ns1__RecipeListGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeListGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeListGet *p;
	size_t k = sizeof(ns1__RecipeListGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeListGet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeListGet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeListGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeListGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeListGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeListGet(soap, tag ? tag : "ns1:RecipeListGet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeListGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeListGet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeListGet * SOAP_FMAC4 soap_get_ns1__RecipeListGet(struct soap *soap, ns1__RecipeListGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeListGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeGetParamForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RecipeGetParamForEqu::ParamCode = NULL;
	this->ns1__RecipeGetParamForEqu::ParamUpper = NULL;
	this->ns1__RecipeGetParamForEqu::ParamLower = NULL;
	this->ns1__RecipeGetParamForEqu::ParamValue = NULL;
}

void ns1__RecipeGetParamForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGetParamForEqu::ParamCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGetParamForEqu::ParamUpper);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGetParamForEqu::ParamLower);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGetParamForEqu::ParamValue);
#endif
}

int ns1__RecipeGetParamForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeGetParamForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeGetParamForEqu(struct soap *soap, const char *tag, int id, const ns1__RecipeGetParamForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeGetParamForEqu), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamCode", -1, (wchar_t*const*)&a->ns1__RecipeGetParamForEqu::ParamCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamUpper", -1, (wchar_t*const*)&a->ns1__RecipeGetParamForEqu::ParamUpper, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamLower", -1, (wchar_t*const*)&a->ns1__RecipeGetParamForEqu::ParamLower, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamValue", -1, (wchar_t*const*)&a->ns1__RecipeGetParamForEqu::ParamValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeGetParamForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeGetParamForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeGetParamForEqu * SOAP_FMAC4 soap_in_ns1__RecipeGetParamForEqu(struct soap *soap, const char *tag, ns1__RecipeGetParamForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeGetParamForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeGetParamForEqu, sizeof(ns1__RecipeGetParamForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeGetParamForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeGetParamForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ParamCode1 = 1;
	size_t soap_flag_ParamUpper1 = 1;
	size_t soap_flag_ParamLower1 = 1;
	size_t soap_flag_ParamValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParamCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamCode", (wchar_t**)&a->ns1__RecipeGetParamForEqu::ParamCode, "xsd:string"))
				{	soap_flag_ParamCode1--;
					continue;
				}
			}
			if (soap_flag_ParamUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamUpper", (wchar_t**)&a->ns1__RecipeGetParamForEqu::ParamUpper, "xsd:string"))
				{	soap_flag_ParamUpper1--;
					continue;
				}
			}
			if (soap_flag_ParamLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamLower", (wchar_t**)&a->ns1__RecipeGetParamForEqu::ParamLower, "xsd:string"))
				{	soap_flag_ParamLower1--;
					continue;
				}
			}
			if (soap_flag_ParamValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamValue", (wchar_t**)&a->ns1__RecipeGetParamForEqu::ParamValue, "xsd:string"))
				{	soap_flag_ParamValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RecipeGetParamForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeGetParamForEqu, SOAP_TYPE_ns1__RecipeGetParamForEqu, sizeof(ns1__RecipeGetParamForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeGetParamForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeGetParamForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeGetParamForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeGetParamForEqu *p;
	size_t k = sizeof(ns1__RecipeGetParamForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeGetParamForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeGetParamForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeGetParamForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeGetParamForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeGetParamForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeGetParamForEqu(soap, tag ? tag : "ns1:RecipeGetParamForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeGetParamForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeGetParamForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeGetParamForEqu * SOAP_FMAC4 soap_get_ns1__RecipeGetParamForEqu(struct soap *soap, ns1__RecipeGetParamForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeGetParamForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfRecipeGetParamForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap, &this->ns1__ArrayOfRecipeGetParamForEqu::RecipeGetParamForEqu);
}

void ns1__ArrayOfRecipeGetParamForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap, &this->ns1__ArrayOfRecipeGetParamForEqu::RecipeGetParamForEqu);
#endif
}

int ns1__ArrayOfRecipeGetParamForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfRecipeGetParamForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfRecipeGetParamForEqu(struct soap *soap, const char *tag, int id, const ns1__ArrayOfRecipeGetParamForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap, "ns1:RecipeGetParamForEqu", -1, &a->ns1__ArrayOfRecipeGetParamForEqu::RecipeGetParamForEqu, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfRecipeGetParamForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfRecipeGetParamForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeGetParamForEqu * SOAP_FMAC4 soap_in_ns1__ArrayOfRecipeGetParamForEqu(struct soap *soap, const char *tag, ns1__ArrayOfRecipeGetParamForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfRecipeGetParamForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, sizeof(ns1__ArrayOfRecipeGetParamForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfRecipeGetParamForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap, "ns1:RecipeGetParamForEqu", &a->ns1__ArrayOfRecipeGetParamForEqu::RecipeGetParamForEqu, "ns1:RecipeGetParamForEqu"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfRecipeGetParamForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, sizeof(ns1__ArrayOfRecipeGetParamForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfRecipeGetParamForEqu * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeGetParamForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfRecipeGetParamForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfRecipeGetParamForEqu *p;
	size_t k = sizeof(ns1__ArrayOfRecipeGetParamForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfRecipeGetParamForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfRecipeGetParamForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfRecipeGetParamForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfRecipeGetParamForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfRecipeGetParamForEqu(soap, tag ? tag : "ns1:ArrayOfRecipeGetParamForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfRecipeGetParamForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfRecipeGetParamForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeGetParamForEqu * SOAP_FMAC4 soap_get_ns1__ArrayOfRecipeGetParamForEqu(struct soap *soap, ns1__ArrayOfRecipeGetParamForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfRecipeGetParamForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeGetForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RecipeGetForEqu::Version = NULL;
	soap_default_dateTime(soap, &this->ns1__RecipeGetForEqu::LastUpdateOnTime);
	this->ns1__RecipeGetForEqu::ParamList = NULL;
}

void ns1__RecipeGetForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGetForEqu::Version);
	soap_serialize_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, &this->ns1__RecipeGetForEqu::ParamList);
#endif
}

int ns1__RecipeGetForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeGetForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeGetForEqu(struct soap *soap, const char *tag, int id, const ns1__RecipeGetForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeGetForEqu), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Version", -1, (wchar_t*const*)&a->ns1__RecipeGetForEqu::Version, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LastUpdateOnTime", -1, &a->ns1__RecipeGetForEqu::LastUpdateOnTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, "ns1:ParamList", -1, &a->ns1__RecipeGetForEqu::ParamList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeGetForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeGetForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeGetForEqu * SOAP_FMAC4 soap_in_ns1__RecipeGetForEqu(struct soap *soap, const char *tag, ns1__RecipeGetForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeGetForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeGetForEqu, sizeof(ns1__RecipeGetForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeGetForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeGetForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_LastUpdateOnTime1 = 1;
	size_t soap_flag_ParamList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Version", (wchar_t**)&a->ns1__RecipeGetForEqu::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_LastUpdateOnTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LastUpdateOnTime", &a->ns1__RecipeGetForEqu::LastUpdateOnTime, "xsd:dateTime"))
				{	soap_flag_LastUpdateOnTime1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, "ns1:ParamList", &a->ns1__RecipeGetForEqu::ParamList, "ns1:ArrayOfRecipeGetParamForEqu"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LastUpdateOnTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeGetForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeGetForEqu, SOAP_TYPE_ns1__RecipeGetForEqu, sizeof(ns1__RecipeGetForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__RecipeGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeGetForEqu *p;
	size_t k = sizeof(ns1__RecipeGetForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeGetForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeGetForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeGetForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeGetForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeGetForEqu(soap, tag ? tag : "ns1:RecipeGetForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeGetForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeGetForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeGetForEqu * SOAP_FMAC4 soap_get_ns1__RecipeGetForEqu(struct soap *soap, ns1__RecipeGetForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseDataForScadaOfRecipeGetForEqu::Data = NULL;
}

void ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RecipeGetForEqu(soap, &this->ns1__ApiResponseDataForScadaOfRecipeGetForEqu::Data);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, const char *tag, int id, const ns1__ApiResponseDataForScadaOfRecipeGetForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu), type ? type : "ns1:ApiResponseDataForScadaOfRecipeGetForEqu"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_PointerTons1__RecipeGetForEqu(soap, "ns1:Data", -1, &a->ns1__ApiResponseDataForScadaOfRecipeGetForEqu::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfRecipeGetForEqu * SOAP_FMAC4 soap_in_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfRecipeGetForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseDataForScadaOfRecipeGetForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfRecipeGetForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseDataForScadaOfRecipeGetForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RecipeGetForEqu(soap, "ns1:Data", &a->ns1__ApiResponseDataForScadaOfRecipeGetForEqu::Data, "ns1:RecipeGetForEqu"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfRecipeGetForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfRecipeGetForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseDataForScadaOfRecipeGetForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseDataForScadaOfRecipeGetForEqu *p;
	size_t k = sizeof(ns1__ApiResponseDataForScadaOfRecipeGetForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseDataForScadaOfRecipeGetForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfRecipeGetForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseDataForScadaOfRecipeGetForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfRecipeGetForEqu * SOAP_FMAC4 soap_get_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__RecipeGet::RecipeCode = NULL;
}

void ns1__RecipeGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeGet::RecipeCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__RecipeGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeGet(struct soap *soap, const char *tag, int id, const ns1__RecipeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeGet), type ? type : "ns1:RecipeGet"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:RecipeCode", -1, (wchar_t*const*)&a->ns1__RecipeGet::RecipeCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeGet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeGet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeGet * SOAP_FMAC4 soap_in_ns1__RecipeGet(struct soap *soap, const char *tag, ns1__RecipeGet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeGet, sizeof(ns1__RecipeGet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeGet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeGet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_RecipeCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_RecipeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:RecipeCode", (wchar_t**)&a->ns1__RecipeGet::RecipeCode, "xsd:string"))
				{	soap_flag_RecipeCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeGet, SOAP_TYPE_ns1__RecipeGet, sizeof(ns1__RecipeGet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeGet * SOAP_FMAC2 soap_instantiate_ns1__RecipeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeGet *p;
	size_t k = sizeof(ns1__RecipeGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeGet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeGet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeGet(soap, tag ? tag : "ns1:RecipeGet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeGet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeGet * SOAP_FMAC4 soap_get_ns1__RecipeGet(struct soap *soap, ns1__RecipeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RecipeParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RecipeParam::ParamCode = NULL;
	this->ns1__RecipeParam::ParamUpper = NULL;
	this->ns1__RecipeParam::ParamLower = NULL;
	this->ns1__RecipeParam::ParamValue = NULL;
	soap_default_dateTime(soap, &this->ns1__RecipeParam::Timestamp);
}

void ns1__RecipeParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeParam::ParamCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeParam::ParamUpper);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeParam::ParamLower);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__RecipeParam::ParamValue);
#endif
}

int ns1__RecipeParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipeParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipeParam(struct soap *soap, const char *tag, int id, const ns1__RecipeParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipeParam), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamCode", -1, (wchar_t*const*)&a->ns1__RecipeParam::ParamCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamUpper", -1, (wchar_t*const*)&a->ns1__RecipeParam::ParamUpper, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamLower", -1, (wchar_t*const*)&a->ns1__RecipeParam::ParamLower, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamValue", -1, (wchar_t*const*)&a->ns1__RecipeParam::ParamValue, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:Timestamp", -1, &a->ns1__RecipeParam::Timestamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RecipeParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RecipeParam(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipeParam * SOAP_FMAC4 soap_in_ns1__RecipeParam(struct soap *soap, const char *tag, ns1__RecipeParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RecipeParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipeParam, sizeof(ns1__RecipeParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RecipeParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RecipeParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ParamCode1 = 1;
	size_t soap_flag_ParamUpper1 = 1;
	size_t soap_flag_ParamLower1 = 1;
	size_t soap_flag_ParamValue1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParamCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamCode", (wchar_t**)&a->ns1__RecipeParam::ParamCode, "xsd:string"))
				{	soap_flag_ParamCode1--;
					continue;
				}
			}
			if (soap_flag_ParamUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamUpper", (wchar_t**)&a->ns1__RecipeParam::ParamUpper, "xsd:string"))
				{	soap_flag_ParamUpper1--;
					continue;
				}
			}
			if (soap_flag_ParamLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamLower", (wchar_t**)&a->ns1__RecipeParam::ParamLower, "xsd:string"))
				{	soap_flag_ParamLower1--;
					continue;
				}
			}
			if (soap_flag_ParamValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamValue", (wchar_t**)&a->ns1__RecipeParam::ParamValue, "xsd:string"))
				{	soap_flag_ParamValue1--;
					continue;
				}
			}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:Timestamp", &a->ns1__RecipeParam::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RecipeParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecipeParam, SOAP_TYPE_ns1__RecipeParam, sizeof(ns1__RecipeParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RecipeParam * SOAP_FMAC2 soap_instantiate_ns1__RecipeParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipeParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RecipeParam *p;
	size_t k = sizeof(ns1__RecipeParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RecipeParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RecipeParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RecipeParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RecipeParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RecipeParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RecipeParam(soap, tag ? tag : "ns1:RecipeParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RecipeParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipeParam(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipeParam * SOAP_FMAC4 soap_get_ns1__RecipeParam(struct soap *soap, ns1__RecipeParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipeParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfRecipeParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__RecipeParam(soap, &this->ns1__ArrayOfRecipeParam::RecipeParam);
}

void ns1__ArrayOfRecipeParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__RecipeParam(soap, &this->ns1__ArrayOfRecipeParam::RecipeParam);
#endif
}

int ns1__ArrayOfRecipeParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfRecipeParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfRecipeParam(struct soap *soap, const char *tag, int id, const ns1__ArrayOfRecipeParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfRecipeParam), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__RecipeParam(soap, "ns1:RecipeParam", -1, &a->ns1__ArrayOfRecipeParam::RecipeParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfRecipeParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfRecipeParam(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeParam * SOAP_FMAC4 soap_in_ns1__ArrayOfRecipeParam(struct soap *soap, const char *tag, ns1__ArrayOfRecipeParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfRecipeParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfRecipeParam, sizeof(ns1__ArrayOfRecipeParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfRecipeParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfRecipeParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__RecipeParam(soap, "ns1:RecipeParam", &a->ns1__ArrayOfRecipeParam::RecipeParam, "ns1:RecipeParam"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfRecipeParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfRecipeParam, SOAP_TYPE_ns1__ArrayOfRecipeParam, sizeof(ns1__ArrayOfRecipeParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfRecipeParam * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfRecipeParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfRecipeParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfRecipeParam *p;
	size_t k = sizeof(ns1__ArrayOfRecipeParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfRecipeParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfRecipeParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfRecipeParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfRecipeParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfRecipeParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfRecipeParam(soap, tag ? tag : "ns1:ArrayOfRecipeParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfRecipeParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfRecipeParam(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfRecipeParam * SOAP_FMAC4 soap_get_ns1__ArrayOfRecipeParam(struct soap *soap, ns1__ArrayOfRecipeParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfRecipeParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Recipe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__Recipe::RecipeCode = NULL;
	this->ns1__Recipe::Version = NULL;
	this->ns1__Recipe::ProductCode = NULL;
	this->ns1__Recipe::ParamList = NULL;
}

void ns1__Recipe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Recipe::RecipeCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Recipe::Version);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Recipe::ProductCode);
	soap_serialize_PointerTons1__ArrayOfRecipeParam(soap, &this->ns1__Recipe::ParamList);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__Recipe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Recipe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Recipe(struct soap *soap, const char *tag, int id, const ns1__Recipe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Recipe), type ? type : "ns1:Recipe"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:RecipeCode", -1, (wchar_t*const*)&a->ns1__Recipe::RecipeCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Version", -1, (wchar_t*const*)&a->ns1__Recipe::Version, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ProductCode", -1, (wchar_t*const*)&a->ns1__Recipe::ProductCode, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfRecipeParam(soap, "ns1:ParamList", -1, &a->ns1__Recipe::ParamList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Recipe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Recipe(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Recipe * SOAP_FMAC4 soap_in_ns1__Recipe(struct soap *soap, const char *tag, ns1__Recipe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Recipe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Recipe, sizeof(ns1__Recipe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Recipe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Recipe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_RecipeCode1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_ProductCode1 = 1;
	size_t soap_flag_ParamList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_RecipeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:RecipeCode", (wchar_t**)&a->ns1__Recipe::RecipeCode, "xsd:string"))
				{	soap_flag_RecipeCode1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Version", (wchar_t**)&a->ns1__Recipe::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_ProductCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ProductCode", (wchar_t**)&a->ns1__Recipe::ProductCode, "xsd:string"))
				{	soap_flag_ProductCode1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfRecipeParam(soap, "ns1:ParamList", &a->ns1__Recipe::ParamList, "ns1:ArrayOfRecipeParam"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Recipe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Recipe, SOAP_TYPE_ns1__Recipe, sizeof(ns1__Recipe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Recipe * SOAP_FMAC2 soap_instantiate_ns1__Recipe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Recipe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Recipe *p;
	size_t k = sizeof(ns1__Recipe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Recipe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Recipe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Recipe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Recipe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Recipe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Recipe(soap, tag ? tag : "ns1:Recipe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Recipe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Recipe(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Recipe * SOAP_FMAC4 soap_get_ns1__Recipe(struct soap *soap, ns1__Recipe *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Recipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OutboundSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__OutboundSFC::SFC = NULL;
	this->ns1__OutboundSFC::Passed = NULL;
	this->ns1__OutboundSFC::ParamList = NULL;
	this->ns1__OutboundSFC::BindFeedingCodes = NULL;
}

void ns1__OutboundSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__OutboundSFC::SFC);
	soap_serialize_PointerToint(soap, &this->ns1__OutboundSFC::Passed);
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__OutboundSFC::ParamList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OutboundSFC::BindFeedingCodes);
#endif
}

int ns1__OutboundSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OutboundSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OutboundSFC(struct soap *soap, const char *tag, int id, const ns1__OutboundSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OutboundSFC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__OutboundSFC::SFC, ""))
		return soap->error;
	if (!a->ns1__OutboundSFC::Passed)
	{	if (soap_element_nil(soap, "ns1:Passed"))
			return soap->error;
	}
	else if (soap_out_PointerToint(soap, "ns1:Passed", -1, &a->ns1__OutboundSFC::Passed, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__OutboundSFC::ParamList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", -1, &a->ns1__OutboundSFC::BindFeedingCodes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OutboundSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OutboundSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OutboundSFC * SOAP_FMAC4 soap_in_ns1__OutboundSFC(struct soap *soap, const char *tag, ns1__OutboundSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OutboundSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OutboundSFC, sizeof(ns1__OutboundSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OutboundSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OutboundSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Passed1 = 1;
	size_t soap_flag_ParamList1 = 1;
	size_t soap_flag_BindFeedingCodes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__OutboundSFC::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Passed", &a->ns1__OutboundSFC::Passed, "xsd:int"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__OutboundSFC::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap_flag_BindFeedingCodes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", &a->ns1__OutboundSFC::BindFeedingCodes, "ns1:ArrayOfString"))
				{	soap_flag_BindFeedingCodes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Passed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OutboundSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OutboundSFC, SOAP_TYPE_ns1__OutboundSFC, sizeof(ns1__OutboundSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OutboundSFC * SOAP_FMAC2 soap_instantiate_ns1__OutboundSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OutboundSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OutboundSFC *p;
	size_t k = sizeof(ns1__OutboundSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OutboundSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OutboundSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OutboundSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OutboundSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OutboundSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OutboundSFC(soap, tag ? tag : "ns1:OutboundSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OutboundSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OutboundSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OutboundSFC * SOAP_FMAC4 soap_get_ns1__OutboundSFC(struct soap *soap, ns1__OutboundSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OutboundSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfOutboundSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__OutboundSFC(soap, &this->ns1__ArrayOfOutboundSFC::OutboundSFC);
}

void ns1__ArrayOfOutboundSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__OutboundSFC(soap, &this->ns1__ArrayOfOutboundSFC::OutboundSFC);
#endif
}

int ns1__ArrayOfOutboundSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfOutboundSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfOutboundSFC(struct soap *soap, const char *tag, int id, const ns1__ArrayOfOutboundSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfOutboundSFC), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__OutboundSFC(soap, "ns1:OutboundSFC", -1, &a->ns1__ArrayOfOutboundSFC::OutboundSFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfOutboundSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfOutboundSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfOutboundSFC * SOAP_FMAC4 soap_in_ns1__ArrayOfOutboundSFC(struct soap *soap, const char *tag, ns1__ArrayOfOutboundSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfOutboundSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfOutboundSFC, sizeof(ns1__ArrayOfOutboundSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfOutboundSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfOutboundSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__OutboundSFC(soap, "ns1:OutboundSFC", &a->ns1__ArrayOfOutboundSFC::OutboundSFC, "ns1:OutboundSFC"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfOutboundSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfOutboundSFC, SOAP_TYPE_ns1__ArrayOfOutboundSFC, sizeof(ns1__ArrayOfOutboundSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfOutboundSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfOutboundSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfOutboundSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfOutboundSFC *p;
	size_t k = sizeof(ns1__ArrayOfOutboundSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfOutboundSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfOutboundSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfOutboundSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfOutboundSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfOutboundSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfOutboundSFC(soap, tag ? tag : "ns1:ArrayOfOutboundSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfOutboundSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfOutboundSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfOutboundSFC * SOAP_FMAC4 soap_get_ns1__ArrayOfOutboundSFC(struct soap *soap, ns1__ArrayOfOutboundSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfOutboundSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OutboundMore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__OutboundMore::SFCs = NULL;
}

void ns1__OutboundMore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfOutboundSFC(soap, &this->ns1__OutboundMore::SFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__OutboundMore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OutboundMore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OutboundMore(struct soap *soap, const char *tag, int id, const ns1__OutboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OutboundMore), type ? type : "ns1:OutboundMore"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfOutboundSFC(soap, "ns1:SFCs", -1, &a->ns1__OutboundMore::SFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OutboundMore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OutboundMore(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OutboundMore * SOAP_FMAC4 soap_in_ns1__OutboundMore(struct soap *soap, const char *tag, ns1__OutboundMore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OutboundMore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OutboundMore, sizeof(ns1__OutboundMore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OutboundMore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OutboundMore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfOutboundSFC(soap, "ns1:SFCs", &a->ns1__OutboundMore::SFCs, "ns1:ArrayOfOutboundSFC"))
				{	soap_flag_SFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OutboundMore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OutboundMore, SOAP_TYPE_ns1__OutboundMore, sizeof(ns1__OutboundMore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OutboundMore * SOAP_FMAC2 soap_instantiate_ns1__OutboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OutboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OutboundMore *p;
	size_t k = sizeof(ns1__OutboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OutboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OutboundMore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OutboundMore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OutboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OutboundMore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OutboundMore(soap, tag ? tag : "ns1:OutboundMore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OutboundMore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OutboundMore(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OutboundMore * SOAP_FMAC4 soap_get_ns1__OutboundMore(struct soap *soap, ns1__OutboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OutboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OutboundInSFCOutputQty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__OutboundInSFCOutputQty::SFC = NULL;
	soap_default_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::TotalQty);
	soap_default_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::OKQty);
	soap_default_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::NGQty);
	this->ns1__OutboundInSFCOutputQty::ParamList = NULL;
}

void ns1__OutboundInSFCOutputQty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__OutboundInSFCOutputQty::SFC);
	soap_embedded(soap, &this->ns1__OutboundInSFCOutputQty::TotalQty, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::TotalQty);
	soap_embedded(soap, &this->ns1__OutboundInSFCOutputQty::OKQty, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::OKQty);
	soap_embedded(soap, &this->ns1__OutboundInSFCOutputQty::NGQty, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__OutboundInSFCOutputQty::NGQty);
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__OutboundInSFCOutputQty::ParamList);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__OutboundInSFCOutputQty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OutboundInSFCOutputQty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, int id, const ns1__OutboundInSFCOutputQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OutboundInSFCOutputQty), type ? type : "ns1:OutboundInSFCOutputQty"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__OutboundInSFCOutputQty::SFC, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:TotalQty", -1, &a->ns1__OutboundInSFCOutputQty::TotalQty, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:OKQty", -1, &a->ns1__OutboundInSFCOutputQty::OKQty, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:NGQty", -1, &a->ns1__OutboundInSFCOutputQty::NGQty, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__OutboundInSFCOutputQty::ParamList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OutboundInSFCOutputQty::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OutboundInSFCOutputQty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_in_ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, ns1__OutboundInSFCOutputQty *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OutboundInSFCOutputQty*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OutboundInSFCOutputQty, sizeof(ns1__OutboundInSFCOutputQty), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OutboundInSFCOutputQty)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OutboundInSFCOutputQty *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_TotalQty1 = 1;
	size_t soap_flag_OKQty1 = 1;
	size_t soap_flag_NGQty1 = 1;
	size_t soap_flag_ParamList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__OutboundInSFCOutputQty::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_TotalQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:TotalQty", &a->ns1__OutboundInSFCOutputQty::TotalQty, "xsd:decimal"))
				{	soap_flag_TotalQty1--;
					continue;
				}
			}
			if (soap_flag_OKQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:OKQty", &a->ns1__OutboundInSFCOutputQty::OKQty, "xsd:decimal"))
				{	soap_flag_OKQty1--;
					continue;
				}
			}
			if (soap_flag_NGQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:NGQty", &a->ns1__OutboundInSFCOutputQty::NGQty, "xsd:decimal"))
				{	soap_flag_NGQty1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__OutboundInSFCOutputQty::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_TotalQty1 > 0 || soap_flag_OKQty1 > 0 || soap_flag_NGQty1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OutboundInSFCOutputQty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OutboundInSFCOutputQty, SOAP_TYPE_ns1__OutboundInSFCOutputQty, sizeof(ns1__OutboundInSFCOutputQty), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate_ns1__OutboundInSFCOutputQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OutboundInSFCOutputQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OutboundInSFCOutputQty *p;
	size_t k = sizeof(ns1__OutboundInSFCOutputQty);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OutboundInSFCOutputQty, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OutboundInSFCOutputQty);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OutboundInSFCOutputQty, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OutboundInSFCOutputQty location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OutboundInSFCOutputQty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OutboundInSFCOutputQty(soap, tag ? tag : "ns1:OutboundInSFCOutputQty", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OutboundInSFCOutputQty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OutboundInSFCOutputQty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_get_ns1__OutboundInSFCOutputQty(struct soap *soap, ns1__OutboundInSFCOutputQty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OutboundInSFCOutputQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OutboundInLaminating::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__OutboundInLaminating::SFC = NULL;
	this->ns1__OutboundInLaminating::Passed = NULL;
	this->ns1__OutboundInLaminating::ParamList = NULL;
	this->ns1__OutboundInLaminating::BindFeedingCodes = NULL;
	this->ns1__OutboundInLaminating::BindDJCodes = NULL;
}

void ns1__OutboundInLaminating::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__OutboundInLaminating::SFC);
	soap_serialize_PointerToint(soap, &this->ns1__OutboundInLaminating::Passed);
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__OutboundInLaminating::ParamList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OutboundInLaminating::BindFeedingCodes);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OutboundInLaminating::BindDJCodes);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__OutboundInLaminating::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OutboundInLaminating(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OutboundInLaminating(struct soap *soap, const char *tag, int id, const ns1__OutboundInLaminating *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OutboundInLaminating), type ? type : "ns1:OutboundInLaminating"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__OutboundInLaminating::SFC, ""))
		return soap->error;
	if (!a->ns1__OutboundInLaminating::Passed)
	{	if (soap_element_nil(soap, "ns1:Passed"))
			return soap->error;
	}
	else if (soap_out_PointerToint(soap, "ns1:Passed", -1, &a->ns1__OutboundInLaminating::Passed, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__OutboundInLaminating::ParamList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", -1, &a->ns1__OutboundInLaminating::BindFeedingCodes, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindDJCodes", -1, &a->ns1__OutboundInLaminating::BindDJCodes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OutboundInLaminating::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OutboundInLaminating(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OutboundInLaminating * SOAP_FMAC4 soap_in_ns1__OutboundInLaminating(struct soap *soap, const char *tag, ns1__OutboundInLaminating *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OutboundInLaminating*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OutboundInLaminating, sizeof(ns1__OutboundInLaminating), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OutboundInLaminating)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OutboundInLaminating *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Passed1 = 1;
	size_t soap_flag_ParamList1 = 1;
	size_t soap_flag_BindFeedingCodes1 = 1;
	size_t soap_flag_BindDJCodes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__OutboundInLaminating::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Passed", &a->ns1__OutboundInLaminating::Passed, "xsd:int"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__OutboundInLaminating::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap_flag_BindFeedingCodes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", &a->ns1__OutboundInLaminating::BindFeedingCodes, "ns1:ArrayOfString"))
				{	soap_flag_BindFeedingCodes1--;
					continue;
				}
			}
			if (soap_flag_BindDJCodes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindDJCodes", &a->ns1__OutboundInLaminating::BindDJCodes, "ns1:ArrayOfString"))
				{	soap_flag_BindDJCodes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_Passed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OutboundInLaminating *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OutboundInLaminating, SOAP_TYPE_ns1__OutboundInLaminating, sizeof(ns1__OutboundInLaminating), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate_ns1__OutboundInLaminating(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OutboundInLaminating(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OutboundInLaminating *p;
	size_t k = sizeof(ns1__OutboundInLaminating);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OutboundInLaminating, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OutboundInLaminating);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OutboundInLaminating, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OutboundInLaminating location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OutboundInLaminating::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OutboundInLaminating(soap, tag ? tag : "ns1:OutboundInLaminating", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OutboundInLaminating::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OutboundInLaminating(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OutboundInLaminating * SOAP_FMAC4 soap_get_ns1__OutboundInLaminating(struct soap *soap, ns1__OutboundInLaminating *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OutboundInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Outbound::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__Outbound::SFC = NULL;
	this->ns1__Outbound::Passed = NULL;
	this->ns1__Outbound::ParamList = NULL;
	this->ns1__Outbound::BindFeedingCodes = NULL;
}

void ns1__Outbound::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Outbound::SFC);
	soap_serialize_PointerToint(soap, &this->ns1__Outbound::Passed);
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__Outbound::ParamList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__Outbound::BindFeedingCodes);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__Outbound::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Outbound(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Outbound(struct soap *soap, const char *tag, int id, const ns1__Outbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Outbound), type ? type : "ns1:Outbound"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__Outbound::SFC, ""))
		return soap->error;
	if (!a->ns1__Outbound::Passed)
	{	if (soap_element_nil(soap, "ns1:Passed"))
			return soap->error;
	}
	else if (soap_out_PointerToint(soap, "ns1:Passed", -1, &a->ns1__Outbound::Passed, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__Outbound::ParamList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", -1, &a->ns1__Outbound::BindFeedingCodes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Outbound::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Outbound(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Outbound * SOAP_FMAC4 soap_in_ns1__Outbound(struct soap *soap, const char *tag, ns1__Outbound *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Outbound*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Outbound, sizeof(ns1__Outbound), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Outbound)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Outbound *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Passed1 = 1;
	size_t soap_flag_ParamList1 = 1;
	size_t soap_flag_BindFeedingCodes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__Outbound::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Passed", &a->ns1__Outbound::Passed, "xsd:int"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__Outbound::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap_flag_BindFeedingCodes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindFeedingCodes", &a->ns1__Outbound::BindFeedingCodes, "ns1:ArrayOfString"))
				{	soap_flag_BindFeedingCodes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_Passed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Outbound *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Outbound, SOAP_TYPE_ns1__Outbound, sizeof(ns1__Outbound), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Outbound * SOAP_FMAC2 soap_instantiate_ns1__Outbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Outbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Outbound *p;
	size_t k = sizeof(ns1__Outbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Outbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Outbound);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Outbound, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Outbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Outbound::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Outbound(soap, tag ? tag : "ns1:Outbound", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Outbound::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Outbound(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Outbound * SOAP_FMAC4 soap_get_ns1__Outbound(struct soap *soap, ns1__Outbound *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Outbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OperatorLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__OperatorLogin::OperatorUserID = NULL;
	this->ns1__OperatorLogin::OperatorPassword = NULL;
}

void ns1__OperatorLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__OperatorLogin::OperatorUserID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__OperatorLogin::OperatorPassword);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__OperatorLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OperatorLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OperatorLogin(struct soap *soap, const char *tag, int id, const ns1__OperatorLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OperatorLogin), type ? type : "ns1:OperatorLogin"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:OperatorUserID", -1, (wchar_t*const*)&a->ns1__OperatorLogin::OperatorUserID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:OperatorPassword", -1, (wchar_t*const*)&a->ns1__OperatorLogin::OperatorPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OperatorLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OperatorLogin(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OperatorLogin * SOAP_FMAC4 soap_in_ns1__OperatorLogin(struct soap *soap, const char *tag, ns1__OperatorLogin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OperatorLogin*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OperatorLogin, sizeof(ns1__OperatorLogin), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OperatorLogin)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OperatorLogin *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_OperatorUserID1 = 1;
	size_t soap_flag_OperatorPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_OperatorUserID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:OperatorUserID", (wchar_t**)&a->ns1__OperatorLogin::OperatorUserID, "xsd:string"))
				{	soap_flag_OperatorUserID1--;
					continue;
				}
			}
			if (soap_flag_OperatorPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:OperatorPassword", (wchar_t**)&a->ns1__OperatorLogin::OperatorPassword, "xsd:string"))
				{	soap_flag_OperatorPassword1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OperatorLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OperatorLogin, SOAP_TYPE_ns1__OperatorLogin, sizeof(ns1__OperatorLogin), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate_ns1__OperatorLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OperatorLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OperatorLogin *p;
	size_t k = sizeof(ns1__OperatorLogin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OperatorLogin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OperatorLogin);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OperatorLogin, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OperatorLogin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OperatorLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OperatorLogin(soap, tag ? tag : "ns1:OperatorLogin", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OperatorLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OperatorLogin(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OperatorLogin * SOAP_FMAC4 soap_get_ns1__OperatorLogin(struct soap *soap, ns1__OperatorLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OperatorLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InboundMore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__InboundMore::SFCs = NULL;
}

void ns1__InboundMore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__InboundMore::SFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__InboundMore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InboundMore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InboundMore(struct soap *soap, const char *tag, int id, const ns1__InboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InboundMore), type ? type : "ns1:InboundMore"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:SFCs", -1, &a->ns1__InboundMore::SFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InboundMore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InboundMore(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InboundMore * SOAP_FMAC4 soap_in_ns1__InboundMore(struct soap *soap, const char *tag, ns1__InboundMore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InboundMore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InboundMore, sizeof(ns1__InboundMore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InboundMore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InboundMore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:SFCs", &a->ns1__InboundMore::SFCs, "ns1:ArrayOfString"))
				{	soap_flag_SFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InboundMore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InboundMore, SOAP_TYPE_ns1__InboundMore, sizeof(ns1__InboundMore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InboundMore * SOAP_FMAC2 soap_instantiate_ns1__InboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InboundMore *p;
	size_t k = sizeof(ns1__InboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InboundMore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InboundMore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InboundMore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InboundMore(soap, tag ? tag : "ns1:InboundMore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InboundMore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InboundMore(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InboundMore * SOAP_FMAC4 soap_get_ns1__InboundMore(struct soap *soap, ns1__InboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InboundInTwoInjectionForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns1__InboundInTwoInjectionForEqu::BeforeWeight);
}

void ns1__InboundInTwoInjectionForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__InboundInTwoInjectionForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InboundInTwoInjectionForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InboundInTwoInjectionForEqu(struct soap *soap, const char *tag, int id, const ns1__InboundInTwoInjectionForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu), type))
		return soap->error;
	if (soap_out_double(soap, "ns1:BeforeWeight", -1, &a->ns1__InboundInTwoInjectionForEqu::BeforeWeight, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InboundInTwoInjectionForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InboundInTwoInjectionForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InboundInTwoInjectionForEqu * SOAP_FMAC4 soap_in_ns1__InboundInTwoInjectionForEqu(struct soap *soap, const char *tag, ns1__InboundInTwoInjectionForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InboundInTwoInjectionForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, sizeof(ns1__InboundInTwoInjectionForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InboundInTwoInjectionForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InboundInTwoInjectionForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BeforeWeight1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeforeWeight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:BeforeWeight", &a->ns1__InboundInTwoInjectionForEqu::BeforeWeight, "xsd:double"))
				{	soap_flag_BeforeWeight1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BeforeWeight1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InboundInTwoInjectionForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, sizeof(ns1__InboundInTwoInjectionForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InboundInTwoInjectionForEqu * SOAP_FMAC2 soap_instantiate_ns1__InboundInTwoInjectionForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InboundInTwoInjectionForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InboundInTwoInjectionForEqu *p;
	size_t k = sizeof(ns1__InboundInTwoInjectionForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InboundInTwoInjectionForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InboundInTwoInjectionForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InboundInTwoInjectionForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InboundInTwoInjectionForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InboundInTwoInjectionForEqu(soap, tag ? tag : "ns1:InboundInTwoInjectionForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InboundInTwoInjectionForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InboundInTwoInjectionForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InboundInTwoInjectionForEqu * SOAP_FMAC4 soap_get_ns1__InboundInTwoInjectionForEqu(struct soap *soap, ns1__InboundInTwoInjectionForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InboundInTwoInjectionForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::Data = NULL;
}

void ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__InboundInTwoInjectionForEqu(soap, &this->ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::Data);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, const char *tag, int id, const ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu), type ? type : "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_PointerTons1__InboundInTwoInjectionForEqu(soap, "ns1:Data", -1, &a->ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu * SOAP_FMAC4 soap_in_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, sizeof(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InboundInTwoInjectionForEqu(soap, "ns1:Data", &a->ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::Data, "ns1:InboundInTwoInjectionForEqu"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, sizeof(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *p;
	size_t k = sizeof(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu * SOAP_FMAC4 soap_get_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InboundInTwoInjection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__InboundInTwoInjection::SFC = NULL;
}

void ns1__InboundInTwoInjection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__InboundInTwoInjection::SFC);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__InboundInTwoInjection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InboundInTwoInjection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InboundInTwoInjection(struct soap *soap, const char *tag, int id, const ns1__InboundInTwoInjection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InboundInTwoInjection), type ? type : "ns1:InboundInTwoInjection"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__InboundInTwoInjection::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InboundInTwoInjection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InboundInTwoInjection(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InboundInTwoInjection * SOAP_FMAC4 soap_in_ns1__InboundInTwoInjection(struct soap *soap, const char *tag, ns1__InboundInTwoInjection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InboundInTwoInjection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InboundInTwoInjection, sizeof(ns1__InboundInTwoInjection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InboundInTwoInjection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InboundInTwoInjection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__InboundInTwoInjection::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InboundInTwoInjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InboundInTwoInjection, SOAP_TYPE_ns1__InboundInTwoInjection, sizeof(ns1__InboundInTwoInjection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate_ns1__InboundInTwoInjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InboundInTwoInjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InboundInTwoInjection *p;
	size_t k = sizeof(ns1__InboundInTwoInjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InboundInTwoInjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InboundInTwoInjection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InboundInTwoInjection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InboundInTwoInjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InboundInTwoInjection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InboundInTwoInjection(soap, tag ? tag : "ns1:InboundInTwoInjection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InboundInTwoInjection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InboundInTwoInjection(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InboundInTwoInjection * SOAP_FMAC4 soap_get_ns1__InboundInTwoInjection(struct soap *soap, ns1__InboundInTwoInjection *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InboundInTwoInjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InboundInSFCContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__InboundInSFCContainer::CheckContainerCode = NULL;
	this->ns1__InboundInSFCContainer::SFC = NULL;
}

void ns1__InboundInSFCContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__InboundInSFCContainer::CheckContainerCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__InboundInSFCContainer::SFC);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__InboundInSFCContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InboundInSFCContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InboundInSFCContainer(struct soap *soap, const char *tag, int id, const ns1__InboundInSFCContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InboundInSFCContainer), type ? type : "ns1:InboundInSFCContainer"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:CheckContainerCode", -1, (wchar_t*const*)&a->ns1__InboundInSFCContainer::CheckContainerCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__InboundInSFCContainer::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InboundInSFCContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InboundInSFCContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InboundInSFCContainer * SOAP_FMAC4 soap_in_ns1__InboundInSFCContainer(struct soap *soap, const char *tag, ns1__InboundInSFCContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InboundInSFCContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InboundInSFCContainer, sizeof(ns1__InboundInSFCContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InboundInSFCContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InboundInSFCContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_CheckContainerCode1 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_CheckContainerCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:CheckContainerCode", (wchar_t**)&a->ns1__InboundInSFCContainer::CheckContainerCode, "xsd:string"))
				{	soap_flag_CheckContainerCode1--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__InboundInSFCContainer::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InboundInSFCContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InboundInSFCContainer, SOAP_TYPE_ns1__InboundInSFCContainer, sizeof(ns1__InboundInSFCContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate_ns1__InboundInSFCContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InboundInSFCContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InboundInSFCContainer *p;
	size_t k = sizeof(ns1__InboundInSFCContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InboundInSFCContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InboundInSFCContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InboundInSFCContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InboundInSFCContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InboundInSFCContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InboundInSFCContainer(soap, tag ? tag : "ns1:InboundInSFCContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InboundInSFCContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InboundInSFCContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InboundInSFCContainer * SOAP_FMAC4 soap_get_ns1__InboundInSFCContainer(struct soap *soap, ns1__InboundInSFCContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InboundInSFCContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InboundInContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__InboundInContainer::ContainerCode = NULL;
}

void ns1__InboundInContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__InboundInContainer::ContainerCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__InboundInContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InboundInContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InboundInContainer(struct soap *soap, const char *tag, int id, const ns1__InboundInContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InboundInContainer), type ? type : "ns1:InboundInContainer"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ContainerCode", -1, (wchar_t*const*)&a->ns1__InboundInContainer::ContainerCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InboundInContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InboundInContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InboundInContainer * SOAP_FMAC4 soap_in_ns1__InboundInContainer(struct soap *soap, const char *tag, ns1__InboundInContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InboundInContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InboundInContainer, sizeof(ns1__InboundInContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InboundInContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InboundInContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ContainerCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ContainerCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ContainerCode", (wchar_t**)&a->ns1__InboundInContainer::ContainerCode, "xsd:string"))
				{	soap_flag_ContainerCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InboundInContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InboundInContainer, SOAP_TYPE_ns1__InboundInContainer, sizeof(ns1__InboundInContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate_ns1__InboundInContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InboundInContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InboundInContainer *p;
	size_t k = sizeof(ns1__InboundInContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InboundInContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InboundInContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InboundInContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InboundInContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InboundInContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InboundInContainer(soap, tag ? tag : "ns1:InboundInContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InboundInContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InboundInContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InboundInContainer * SOAP_FMAC4 soap_get_ns1__InboundInContainer(struct soap *soap, ns1__InboundInContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InboundInContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Inbound::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__Inbound::SFC = NULL;
}

void ns1__Inbound::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Inbound::SFC);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__Inbound::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Inbound(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Inbound(struct soap *soap, const char *tag, int id, const ns1__Inbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Inbound), type ? type : "ns1:Inbound"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__Inbound::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Inbound::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Inbound(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Inbound * SOAP_FMAC4 soap_in_ns1__Inbound(struct soap *soap, const char *tag, ns1__Inbound *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Inbound*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Inbound, sizeof(ns1__Inbound), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Inbound)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Inbound *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__Inbound::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Inbound *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Inbound, SOAP_TYPE_ns1__Inbound, sizeof(ns1__Inbound), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Inbound * SOAP_FMAC2 soap_instantiate_ns1__Inbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Inbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Inbound *p;
	size_t k = sizeof(ns1__Inbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Inbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Inbound);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Inbound, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Inbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Inbound::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Inbound(soap, tag ? tag : "ns1:Inbound", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Inbound::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Inbound(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Inbound * SOAP_FMAC4 soap_get_ns1__Inbound(struct soap *soap, ns1__Inbound *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Inbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Heartbeat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	soap_default_bool(soap, &this->ns1__Heartbeat::IsOnline);
}

void ns1__Heartbeat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Heartbeat::IsOnline, SOAP_TYPE_bool);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__Heartbeat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Heartbeat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Heartbeat(struct soap *soap, const char *tag, int id, const ns1__Heartbeat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Heartbeat), type ? type : "ns1:Heartbeat"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsOnline", -1, &a->ns1__Heartbeat::IsOnline, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Heartbeat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Heartbeat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Heartbeat * SOAP_FMAC4 soap_in_ns1__Heartbeat(struct soap *soap, const char *tag, ns1__Heartbeat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Heartbeat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Heartbeat, sizeof(ns1__Heartbeat), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Heartbeat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Heartbeat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_IsOnline1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_IsOnline1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:IsOnline", &a->ns1__Heartbeat::IsOnline, "xsd:boolean"))
				{	soap_flag_IsOnline1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_IsOnline1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Heartbeat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Heartbeat, SOAP_TYPE_ns1__Heartbeat, sizeof(ns1__Heartbeat), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Heartbeat * SOAP_FMAC2 soap_instantiate_ns1__Heartbeat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Heartbeat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Heartbeat *p;
	size_t k = sizeof(ns1__Heartbeat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Heartbeat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Heartbeat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Heartbeat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Heartbeat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Heartbeat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Heartbeat(soap, tag ? tag : "ns1:Heartbeat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Heartbeat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Heartbeat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Heartbeat * SOAP_FMAC4 soap_get_ns1__Heartbeat(struct soap *soap, ns1__Heartbeat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Heartbeat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseDataForScadaOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseDataForScadaOfString::Data = NULL;
}

void ns1__ApiResponseDataForScadaOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ApiResponseDataForScadaOfString::Data);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseDataForScadaOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseDataForScadaOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseDataForScadaOfString(struct soap *soap, const char *tag, int id, const ns1__ApiResponseDataForScadaOfString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString), type ? type : "ns1:ApiResponseDataForScadaOfString"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Data", -1, (wchar_t*const*)&a->ns1__ApiResponseDataForScadaOfString::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseDataForScadaOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseDataForScadaOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfString * SOAP_FMAC4 soap_in_ns1__ApiResponseDataForScadaOfString(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfString *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseDataForScadaOfString*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, sizeof(ns1__ApiResponseDataForScadaOfString), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseDataForScadaOfString)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseDataForScadaOfString *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_Data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Data", (wchar_t**)&a->ns1__ApiResponseDataForScadaOfString::Data, "xsd:string"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, sizeof(ns1__ApiResponseDataForScadaOfString), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseDataForScadaOfString * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseDataForScadaOfString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseDataForScadaOfString *p;
	size_t k = sizeof(ns1__ApiResponseDataForScadaOfString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseDataForScadaOfString);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseDataForScadaOfString, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseDataForScadaOfString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseDataForScadaOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseDataForScadaOfString(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfString", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseDataForScadaOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseDataForScadaOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfString * SOAP_FMAC4 soap_get_ns1__ApiResponseDataForScadaOfString(struct soap *soap, ns1__ApiResponseDataForScadaOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseDataForScadaOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenerateCellSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__GenerateCellSFC::ProductCode = NULL;
}

void ns1__GenerateCellSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__GenerateCellSFC::ProductCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__GenerateCellSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenerateCellSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenerateCellSFC(struct soap *soap, const char *tag, int id, const ns1__GenerateCellSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenerateCellSFC), type ? type : "ns1:GenerateCellSFC"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ProductCode", -1, (wchar_t*const*)&a->ns1__GenerateCellSFC::ProductCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenerateCellSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenerateCellSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenerateCellSFC * SOAP_FMAC4 soap_in_ns1__GenerateCellSFC(struct soap *soap, const char *tag, ns1__GenerateCellSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenerateCellSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenerateCellSFC, sizeof(ns1__GenerateCellSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenerateCellSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenerateCellSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ProductCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ProductCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ProductCode", (wchar_t**)&a->ns1__GenerateCellSFC::ProductCode, "xsd:string"))
				{	soap_flag_ProductCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenerateCellSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenerateCellSFC, SOAP_TYPE_ns1__GenerateCellSFC, sizeof(ns1__GenerateCellSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate_ns1__GenerateCellSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenerateCellSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenerateCellSFC *p;
	size_t k = sizeof(ns1__GenerateCellSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenerateCellSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenerateCellSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenerateCellSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenerateCellSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenerateCellSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenerateCellSFC(soap, tag ? tag : "ns1:GenerateCellSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenerateCellSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenerateCellSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenerateCellSFC * SOAP_FMAC4 soap_get_ns1__GenerateCellSFC(struct soap *soap, ns1__GenerateCellSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenerateCellSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FillingData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	soap_default_dateTime(soap, &this->ns1__FillingData::InTime);
	soap_default_dateTime(soap, &this->ns1__FillingData::OutTime);
	soap_default_double(soap, &this->ns1__FillingData::BeforeWeight);
	soap_default_double(soap, &this->ns1__FillingData::AfterWeight);
	soap_default_double(soap, &this->ns1__FillingData::ELWeight);
	soap_default_double(soap, &this->ns1__FillingData::AddEL);
	soap_default_double(soap, &this->ns1__FillingData::TotalEL);
	soap_default_double(soap, &this->ns1__FillingData::ManualEL);
	soap_default_double(soap, &this->ns1__FillingData::FinalEL);
	soap_default_bool(soap, &this->ns1__FillingData::IsOK);
	this->ns1__FillingData::SFC = NULL;
}

void ns1__FillingData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__FillingData::IsOK, SOAP_TYPE_bool);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__FillingData::SFC);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__FillingData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FillingData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FillingData(struct soap *soap, const char *tag, int id, const ns1__FillingData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FillingData), type ? type : "ns1:FillingData"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:InTime", -1, &a->ns1__FillingData::InTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:OutTime", -1, &a->ns1__FillingData::OutTime, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:BeforeWeight", -1, &a->ns1__FillingData::BeforeWeight, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:AfterWeight", -1, &a->ns1__FillingData::AfterWeight, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:ELWeight", -1, &a->ns1__FillingData::ELWeight, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:AddEL", -1, &a->ns1__FillingData::AddEL, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:TotalEL", -1, &a->ns1__FillingData::TotalEL, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:ManualEL", -1, &a->ns1__FillingData::ManualEL, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:FinalEL", -1, &a->ns1__FillingData::FinalEL, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsOK", -1, &a->ns1__FillingData::IsOK, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__FillingData::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FillingData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FillingData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FillingData * SOAP_FMAC4 soap_in_ns1__FillingData(struct soap *soap, const char *tag, ns1__FillingData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FillingData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FillingData, sizeof(ns1__FillingData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FillingData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FillingData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_InTime1 = 1;
	size_t soap_flag_OutTime1 = 1;
	size_t soap_flag_BeforeWeight1 = 1;
	size_t soap_flag_AfterWeight1 = 1;
	size_t soap_flag_ELWeight1 = 1;
	size_t soap_flag_AddEL1 = 1;
	size_t soap_flag_TotalEL1 = 1;
	size_t soap_flag_ManualEL1 = 1;
	size_t soap_flag_FinalEL1 = 1;
	size_t soap_flag_IsOK1 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_InTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:InTime", &a->ns1__FillingData::InTime, "xsd:dateTime"))
				{	soap_flag_InTime1--;
					continue;
				}
			}
			if (soap_flag_OutTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:OutTime", &a->ns1__FillingData::OutTime, "xsd:dateTime"))
				{	soap_flag_OutTime1--;
					continue;
				}
			}
			if (soap_flag_BeforeWeight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:BeforeWeight", &a->ns1__FillingData::BeforeWeight, "xsd:double"))
				{	soap_flag_BeforeWeight1--;
					continue;
				}
			}
			if (soap_flag_AfterWeight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:AfterWeight", &a->ns1__FillingData::AfterWeight, "xsd:double"))
				{	soap_flag_AfterWeight1--;
					continue;
				}
			}
			if (soap_flag_ELWeight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:ELWeight", &a->ns1__FillingData::ELWeight, "xsd:double"))
				{	soap_flag_ELWeight1--;
					continue;
				}
			}
			if (soap_flag_AddEL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:AddEL", &a->ns1__FillingData::AddEL, "xsd:double"))
				{	soap_flag_AddEL1--;
					continue;
				}
			}
			if (soap_flag_TotalEL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:TotalEL", &a->ns1__FillingData::TotalEL, "xsd:double"))
				{	soap_flag_TotalEL1--;
					continue;
				}
			}
			if (soap_flag_ManualEL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:ManualEL", &a->ns1__FillingData::ManualEL, "xsd:double"))
				{	soap_flag_ManualEL1--;
					continue;
				}
			}
			if (soap_flag_FinalEL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns1:FinalEL", &a->ns1__FillingData::FinalEL, "xsd:double"))
				{	soap_flag_FinalEL1--;
					continue;
				}
			}
			if (soap_flag_IsOK1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:IsOK", &a->ns1__FillingData::IsOK, "xsd:boolean"))
				{	soap_flag_IsOK1--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__FillingData::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_InTime1 > 0 || soap_flag_OutTime1 > 0 || soap_flag_BeforeWeight1 > 0 || soap_flag_AfterWeight1 > 0 || soap_flag_ELWeight1 > 0 || soap_flag_AddEL1 > 0 || soap_flag_TotalEL1 > 0 || soap_flag_ManualEL1 > 0 || soap_flag_FinalEL1 > 0 || soap_flag_IsOK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FillingData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FillingData, SOAP_TYPE_ns1__FillingData, sizeof(ns1__FillingData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FillingData * SOAP_FMAC2 soap_instantiate_ns1__FillingData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FillingData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FillingData *p;
	size_t k = sizeof(ns1__FillingData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FillingData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FillingData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FillingData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FillingData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FillingData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FillingData(soap, tag ? tag : "ns1:FillingData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FillingData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FillingData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FillingData * SOAP_FMAC4 soap_get_ns1__FillingData(struct soap *soap, ns1__FillingData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FillingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FeedingDJInLaminatingByScadaDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__FeedingDJInLaminatingByScadaDTO::DJCode = NULL;
}

void ns1__FeedingDJInLaminatingByScadaDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__FeedingDJInLaminatingByScadaDTO::DJCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__FeedingDJInLaminatingByScadaDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, const char *tag, int id, const ns1__FeedingDJInLaminatingByScadaDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO), type ? type : "ns1:FeedingDJInLaminatingByScadaDTO"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:DJCode", -1, (wchar_t*const*)&a->ns1__FeedingDJInLaminatingByScadaDTO::DJCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FeedingDJInLaminatingByScadaDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FeedingDJInLaminatingByScadaDTO * SOAP_FMAC4 soap_in_ns1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, const char *tag, ns1__FeedingDJInLaminatingByScadaDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FeedingDJInLaminatingByScadaDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, sizeof(ns1__FeedingDJInLaminatingByScadaDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FeedingDJInLaminatingByScadaDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_DJCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_DJCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:DJCode", (wchar_t**)&a->ns1__FeedingDJInLaminatingByScadaDTO::DJCode, "xsd:string"))
				{	soap_flag_DJCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FeedingDJInLaminatingByScadaDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, sizeof(ns1__FeedingDJInLaminatingByScadaDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FeedingDJInLaminatingByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FeedingDJInLaminatingByScadaDTO *p;
	size_t k = sizeof(ns1__FeedingDJInLaminatingByScadaDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FeedingDJInLaminatingByScadaDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FeedingDJInLaminatingByScadaDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FeedingDJInLaminatingByScadaDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FeedingDJInLaminatingByScadaDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag ? tag : "ns1:FeedingDJInLaminatingByScadaDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FeedingDJInLaminatingByScadaDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FeedingDJInLaminatingByScadaDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FeedingDJInLaminatingByScadaDTO * SOAP_FMAC4 soap_get_ns1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, ns1__FeedingDJInLaminatingByScadaDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FeedingDJInLaminatingByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FeedingByScadaDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__FeedingByScadaDTO::SFC = NULL;
	this->ns1__FeedingByScadaDTO::Qty = NULL;
	this->ns1__FeedingByScadaDTO::IsFeedingPoint = NULL;
}

void ns1__FeedingByScadaDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__FeedingByScadaDTO::SFC);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns1__FeedingByScadaDTO::Qty);
	soap_serialize_PointerTobool(soap, &this->ns1__FeedingByScadaDTO::IsFeedingPoint);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__FeedingByScadaDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FeedingByScadaDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FeedingByScadaDTO(struct soap *soap, const char *tag, int id, const ns1__FeedingByScadaDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FeedingByScadaDTO), type ? type : "ns1:FeedingByScadaDTO"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__FeedingByScadaDTO::SFC, ""))
		return soap->error;
	if (!a->ns1__FeedingByScadaDTO::Qty)
	{	if (soap_element_nil(soap, "ns1:Qty"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__decimal(soap, "ns1:Qty", -1, &a->ns1__FeedingByScadaDTO::Qty, ""))
		return soap->error;
	if (!a->ns1__FeedingByScadaDTO::IsFeedingPoint)
	{	if (soap_element_nil(soap, "ns1:IsFeedingPoint"))
			return soap->error;
	}
	else if (soap_out_PointerTobool(soap, "ns1:IsFeedingPoint", -1, &a->ns1__FeedingByScadaDTO::IsFeedingPoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FeedingByScadaDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FeedingByScadaDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FeedingByScadaDTO * SOAP_FMAC4 soap_in_ns1__FeedingByScadaDTO(struct soap *soap, const char *tag, ns1__FeedingByScadaDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FeedingByScadaDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FeedingByScadaDTO, sizeof(ns1__FeedingByScadaDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FeedingByScadaDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FeedingByScadaDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Qty1 = 1;
	size_t soap_flag_IsFeedingPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__FeedingByScadaDTO::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Qty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns1:Qty", &a->ns1__FeedingByScadaDTO::Qty, "xsd:decimal"))
				{	soap_flag_Qty1--;
					continue;
				}
			}
			if (soap_flag_IsFeedingPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:IsFeedingPoint", &a->ns1__FeedingByScadaDTO::IsFeedingPoint, "xsd:boolean"))
				{	soap_flag_IsFeedingPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_Qty1 > 0 || soap_flag_IsFeedingPoint1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FeedingByScadaDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FeedingByScadaDTO, SOAP_TYPE_ns1__FeedingByScadaDTO, sizeof(ns1__FeedingByScadaDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FeedingByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__FeedingByScadaDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FeedingByScadaDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FeedingByScadaDTO *p;
	size_t k = sizeof(ns1__FeedingByScadaDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FeedingByScadaDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FeedingByScadaDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FeedingByScadaDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FeedingByScadaDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FeedingByScadaDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FeedingByScadaDTO(soap, tag ? tag : "ns1:FeedingByScadaDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FeedingByScadaDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FeedingByScadaDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FeedingByScadaDTO * SOAP_FMAC4 soap_get_ns1__FeedingByScadaDTO(struct soap *soap, ns1__FeedingByScadaDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FeedingByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ExamineExistsByScadaDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__ExamineExistsByScadaDTO::SFC = NULL;
}

void ns1__ExamineExistsByScadaDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ExamineExistsByScadaDTO::SFC);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__ExamineExistsByScadaDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ExamineExistsByScadaDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExamineExistsByScadaDTO(struct soap *soap, const char *tag, int id, const ns1__ExamineExistsByScadaDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExamineExistsByScadaDTO), type ? type : "ns1:ExamineExistsByScadaDTO"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__ExamineExistsByScadaDTO::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ExamineExistsByScadaDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ExamineExistsByScadaDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ExamineExistsByScadaDTO * SOAP_FMAC4 soap_in_ns1__ExamineExistsByScadaDTO(struct soap *soap, const char *tag, ns1__ExamineExistsByScadaDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ExamineExistsByScadaDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, sizeof(ns1__ExamineExistsByScadaDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ExamineExistsByScadaDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ExamineExistsByScadaDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__ExamineExistsByScadaDTO::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ExamineExistsByScadaDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, sizeof(ns1__ExamineExistsByScadaDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ExamineExistsByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__ExamineExistsByScadaDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExamineExistsByScadaDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ExamineExistsByScadaDTO *p;
	size_t k = sizeof(ns1__ExamineExistsByScadaDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ExamineExistsByScadaDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ExamineExistsByScadaDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ExamineExistsByScadaDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ExamineExistsByScadaDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ExamineExistsByScadaDTO(soap, tag ? tag : "ns1:ExamineExistsByScadaDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ExamineExistsByScadaDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ExamineExistsByScadaDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ExamineExistsByScadaDTO * SOAP_FMAC4 soap_get_ns1__ExamineExistsByScadaDTO(struct soap *soap, ns1__ExamineExistsByScadaDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExamineExistsByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfApiResponseSFCForScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap, &this->ns1__ArrayOfApiResponseSFCForScada::ApiResponseSFCForScada);
}

void ns1__ArrayOfApiResponseSFCForScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap, &this->ns1__ArrayOfApiResponseSFCForScada::ApiResponseSFCForScada);
#endif
}

int ns1__ArrayOfApiResponseSFCForScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfApiResponseSFCForScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfApiResponseSFCForScada(struct soap *soap, const char *tag, int id, const ns1__ArrayOfApiResponseSFCForScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap, "ns1:ApiResponseSFCForScada", -1, &a->ns1__ArrayOfApiResponseSFCForScada::ApiResponseSFCForScada, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfApiResponseSFCForScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfApiResponseSFCForScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfApiResponseSFCForScada * SOAP_FMAC4 soap_in_ns1__ArrayOfApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ArrayOfApiResponseSFCForScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfApiResponseSFCForScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, sizeof(ns1__ArrayOfApiResponseSFCForScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfApiResponseSFCForScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap, "ns1:ApiResponseSFCForScada", &a->ns1__ArrayOfApiResponseSFCForScada::ApiResponseSFCForScada, "ns1:ApiResponseSFCForScada"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfApiResponseSFCForScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, sizeof(ns1__ArrayOfApiResponseSFCForScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfApiResponseSFCForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfApiResponseSFCForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfApiResponseSFCForScada *p;
	size_t k = sizeof(ns1__ArrayOfApiResponseSFCForScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfApiResponseSFCForScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfApiResponseSFCForScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfApiResponseSFCForScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfApiResponseSFCForScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfApiResponseSFCForScada(soap, tag ? tag : "ns1:ArrayOfApiResponseSFCForScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfApiResponseSFCForScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfApiResponseSFCForScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfApiResponseSFCForScada * SOAP_FMAC4 soap_get_ns1__ArrayOfApiResponseSFCForScada(struct soap *soap, ns1__ArrayOfApiResponseSFCForScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseSFCForScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseSFCForScada::SFC = NULL;
}

void ns1__ApiResponseSFCForScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ApiResponseSFCForScada::SFC);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseSFCForScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseSFCForScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseSFCForScada(struct soap *soap, const char *tag, int id, const ns1__ApiResponseSFCForScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseSFCForScada), type ? type : "ns1:ApiResponseSFCForScada"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__ApiResponseSFCForScada::SFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseSFCForScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseSFCForScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseSFCForScada * SOAP_FMAC4 soap_in_ns1__ApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ApiResponseSFCForScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseSFCForScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseSFCForScada, sizeof(ns1__ApiResponseSFCForScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseSFCForScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseSFCForScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_SFC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__ApiResponseSFCForScada::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseSFCForScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseSFCForScada, SOAP_TYPE_ns1__ApiResponseSFCForScada, sizeof(ns1__ApiResponseSFCForScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseSFCForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseSFCForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseSFCForScada *p;
	size_t k = sizeof(ns1__ApiResponseSFCForScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseSFCForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseSFCForScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseSFCForScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseSFCForScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseSFCForScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseSFCForScada(soap, tag ? tag : "ns1:ApiResponseSFCForScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseSFCForScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseSFCForScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseSFCForScada * SOAP_FMAC4 soap_get_ns1__ApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseSFCForScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
	this->ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::Data = NULL;
}

void ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfApiResponseSFCForScada(soap, &this->ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::Data);
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, const char *tag, int id, const ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada), type ? type : "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfApiResponseSFCForScada(soap, "ns1:Data", -1, &a->ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada * SOAP_FMAC4 soap_in_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, sizeof(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfApiResponseSFCForScada(soap, "ns1:Data", &a->ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::Data, "ns1:ArrayOfApiResponseSFCForScada"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, sizeof(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *p;
	size_t k = sizeof(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada * SOAP_FMAC4 soap_get_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__EquipmentProductProcessParamSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__EquipmentProductProcessParamSFC::SFC = NULL;
	this->ns1__EquipmentProductProcessParamSFC::ParamList = NULL;
}

void ns1__EquipmentProductProcessParamSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__EquipmentProductProcessParamSFC::SFC);
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__EquipmentProductProcessParamSFC::ParamList);
#endif
}

int ns1__EquipmentProductProcessParamSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EquipmentProductProcessParamSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, int id, const ns1__EquipmentProductProcessParamSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__EquipmentProductProcessParamSFC::SFC, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__EquipmentProductProcessParamSFC::ParamList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EquipmentProductProcessParamSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__EquipmentProductProcessParamSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParamSFC * SOAP_FMAC4 soap_in_ns1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, ns1__EquipmentProductProcessParamSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EquipmentProductProcessParamSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, sizeof(ns1__EquipmentProductProcessParamSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__EquipmentProductProcessParamSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__EquipmentProductProcessParamSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_ParamList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__EquipmentProductProcessParamSFC::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__EquipmentProductProcessParamSFC::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EquipmentProductProcessParamSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, sizeof(ns1__EquipmentProductProcessParamSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__EquipmentProductProcessParamSFC * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProductProcessParamSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EquipmentProductProcessParamSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__EquipmentProductProcessParamSFC *p;
	size_t k = sizeof(ns1__EquipmentProductProcessParamSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__EquipmentProductProcessParamSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__EquipmentProductProcessParamSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__EquipmentProductProcessParamSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__EquipmentProductProcessParamSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__EquipmentProductProcessParamSFC(soap, tag ? tag : "ns1:EquipmentProductProcessParamSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EquipmentProductProcessParamSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EquipmentProductProcessParamSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParamSFC * SOAP_FMAC4 soap_get_ns1__EquipmentProductProcessParamSFC(struct soap *soap, ns1__EquipmentProductProcessParamSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EquipmentProductProcessParamSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfEquipmentProductProcessParamSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap, &this->ns1__ArrayOfEquipmentProductProcessParamSFC::EquipmentProductProcessParamSFC);
}

void ns1__ArrayOfEquipmentProductProcessParamSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap, &this->ns1__ArrayOfEquipmentProductProcessParamSFC::EquipmentProductProcessParamSFC);
#endif
}

int ns1__ArrayOfEquipmentProductProcessParamSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, const char *tag, int id, const ns1__ArrayOfEquipmentProductProcessParamSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap, "ns1:EquipmentProductProcessParamSFC", -1, &a->ns1__ArrayOfEquipmentProductProcessParamSFC::EquipmentProductProcessParamSFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfEquipmentProductProcessParamSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfEquipmentProductProcessParamSFC * SOAP_FMAC4 soap_in_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, const char *tag, ns1__ArrayOfEquipmentProductProcessParamSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfEquipmentProductProcessParamSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, sizeof(ns1__ArrayOfEquipmentProductProcessParamSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfEquipmentProductProcessParamSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap, "ns1:EquipmentProductProcessParamSFC", &a->ns1__ArrayOfEquipmentProductProcessParamSFC::EquipmentProductProcessParamSFC, "ns1:EquipmentProductProcessParamSFC"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfEquipmentProductProcessParamSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, sizeof(ns1__ArrayOfEquipmentProductProcessParamSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfEquipmentProductProcessParamSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfEquipmentProductProcessParamSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfEquipmentProductProcessParamSFC *p;
	size_t k = sizeof(ns1__ArrayOfEquipmentProductProcessParamSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfEquipmentProductProcessParamSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfEquipmentProductProcessParamSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfEquipmentProductProcessParamSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfEquipmentProductProcessParamSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag ? tag : "ns1:ArrayOfEquipmentProductProcessParamSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfEquipmentProductProcessParamSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfEquipmentProductProcessParamSFC * SOAP_FMAC4 soap_get_ns1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, ns1__ArrayOfEquipmentProductProcessParamSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__EquipmentProductProcessParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__EquipmentProductProcessParam::SFCParams = NULL;
}

void ns1__EquipmentProductProcessParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, &this->ns1__EquipmentProductProcessParam::SFCParams);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__EquipmentProductProcessParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EquipmentProductProcessParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, int id, const ns1__EquipmentProductProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EquipmentProductProcessParam), type ? type : "ns1:EquipmentProductProcessParam"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, "ns1:SFCParams", -1, &a->ns1__EquipmentProductProcessParam::SFCParams, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EquipmentProductProcessParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__EquipmentProductProcessParam(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_in_ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, ns1__EquipmentProductProcessParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EquipmentProductProcessParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EquipmentProductProcessParam, sizeof(ns1__EquipmentProductProcessParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__EquipmentProductProcessParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__EquipmentProductProcessParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFCParams1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFCParams1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, "ns1:SFCParams", &a->ns1__EquipmentProductProcessParam::SFCParams, "ns1:ArrayOfEquipmentProductProcessParamSFC"))
				{	soap_flag_SFCParams1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__EquipmentProductProcessParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EquipmentProductProcessParam, SOAP_TYPE_ns1__EquipmentProductProcessParam, sizeof(ns1__EquipmentProductProcessParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProductProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EquipmentProductProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__EquipmentProductProcessParam *p;
	size_t k = sizeof(ns1__EquipmentProductProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__EquipmentProductProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__EquipmentProductProcessParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__EquipmentProductProcessParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__EquipmentProductProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__EquipmentProductProcessParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__EquipmentProductProcessParam(soap, tag ? tag : "ns1:EquipmentProductProcessParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EquipmentProductProcessParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EquipmentProductProcessParam(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_get_ns1__EquipmentProductProcessParam(struct soap *soap, ns1__EquipmentProductProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EquipmentProductProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ParamDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ParamDTO::ParamCode = NULL;
	this->ns1__ParamDTO::ParamValue = NULL;
	soap_default_dateTime(soap, &this->ns1__ParamDTO::Timestamp);
}

void ns1__ParamDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ParamDTO::ParamCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__ParamDTO::ParamValue);
#endif
}

int ns1__ParamDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ParamDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ParamDTO(struct soap *soap, const char *tag, int id, const ns1__ParamDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ParamDTO), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamCode", -1, (wchar_t*const*)&a->ns1__ParamDTO::ParamCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ParamValue", -1, (wchar_t*const*)&a->ns1__ParamDTO::ParamValue, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:Timestamp", -1, &a->ns1__ParamDTO::Timestamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ParamDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ParamDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ParamDTO * SOAP_FMAC4 soap_in_ns1__ParamDTO(struct soap *soap, const char *tag, ns1__ParamDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ParamDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ParamDTO, sizeof(ns1__ParamDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ParamDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ParamDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ParamCode1 = 1;
	size_t soap_flag_ParamValue1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParamCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamCode", (wchar_t**)&a->ns1__ParamDTO::ParamCode, "xsd:string"))
				{	soap_flag_ParamCode1--;
					continue;
				}
			}
			if (soap_flag_ParamValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ParamValue", (wchar_t**)&a->ns1__ParamDTO::ParamValue, "xsd:string"))
				{	soap_flag_ParamValue1--;
					continue;
				}
			}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:Timestamp", &a->ns1__ParamDTO::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ParamDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ParamDTO, SOAP_TYPE_ns1__ParamDTO, sizeof(ns1__ParamDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ParamDTO * SOAP_FMAC2 soap_instantiate_ns1__ParamDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ParamDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ParamDTO *p;
	size_t k = sizeof(ns1__ParamDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ParamDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ParamDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ParamDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ParamDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ParamDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ParamDTO(soap, tag ? tag : "ns1:ParamDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ParamDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ParamDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ParamDTO * SOAP_FMAC4 soap_get_ns1__ParamDTO(struct soap *soap, ns1__ParamDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ParamDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfParamDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ParamDTO(soap, &this->ns1__ArrayOfParamDTO::ParamDTO);
}

void ns1__ArrayOfParamDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ParamDTO(soap, &this->ns1__ArrayOfParamDTO::ParamDTO);
#endif
}

int ns1__ArrayOfParamDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfParamDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfParamDTO(struct soap *soap, const char *tag, int id, const ns1__ArrayOfParamDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfParamDTO), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ParamDTO(soap, "ns1:ParamDTO", -1, &a->ns1__ArrayOfParamDTO::ParamDTO, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfParamDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfParamDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfParamDTO * SOAP_FMAC4 soap_in_ns1__ArrayOfParamDTO(struct soap *soap, const char *tag, ns1__ArrayOfParamDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfParamDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfParamDTO, sizeof(ns1__ArrayOfParamDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfParamDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfParamDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ParamDTO(soap, "ns1:ParamDTO", &a->ns1__ArrayOfParamDTO::ParamDTO, "ns1:ParamDTO"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfParamDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfParamDTO, SOAP_TYPE_ns1__ArrayOfParamDTO, sizeof(ns1__ArrayOfParamDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfParamDTO * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfParamDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfParamDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfParamDTO *p;
	size_t k = sizeof(ns1__ArrayOfParamDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfParamDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfParamDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfParamDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfParamDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfParamDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfParamDTO(soap, tag ? tag : "ns1:ArrayOfParamDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfParamDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfParamDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfParamDTO * SOAP_FMAC4 soap_get_ns1__ArrayOfParamDTO(struct soap *soap, ns1__ArrayOfParamDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfParamDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__EquipmentProcessParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__EquipmentProcessParam::ParamList = NULL;
}

void ns1__EquipmentProcessParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfParamDTO(soap, &this->ns1__EquipmentProcessParam::ParamList);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__EquipmentProcessParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EquipmentProcessParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EquipmentProcessParam(struct soap *soap, const char *tag, int id, const ns1__EquipmentProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EquipmentProcessParam), type ? type : "ns1:EquipmentProcessParam"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", -1, &a->ns1__EquipmentProcessParam::ParamList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EquipmentProcessParam::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__EquipmentProcessParam(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EquipmentProcessParam * SOAP_FMAC4 soap_in_ns1__EquipmentProcessParam(struct soap *soap, const char *tag, ns1__EquipmentProcessParam *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EquipmentProcessParam*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EquipmentProcessParam, sizeof(ns1__EquipmentProcessParam), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__EquipmentProcessParam)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__EquipmentProcessParam *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ParamList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ParamList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfParamDTO(soap, "ns1:ParamList", &a->ns1__EquipmentProcessParam::ParamList, "ns1:ArrayOfParamDTO"))
				{	soap_flag_ParamList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__EquipmentProcessParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EquipmentProcessParam, SOAP_TYPE_ns1__EquipmentProcessParam, sizeof(ns1__EquipmentProcessParam), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate_ns1__EquipmentProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EquipmentProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__EquipmentProcessParam *p;
	size_t k = sizeof(ns1__EquipmentProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__EquipmentProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__EquipmentProcessParam);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__EquipmentProcessParam, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__EquipmentProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__EquipmentProcessParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__EquipmentProcessParam(soap, tag ? tag : "ns1:EquipmentProcessParam", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EquipmentProcessParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EquipmentProcessParam(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EquipmentProcessParam * SOAP_FMAC4 soap_get_ns1__EquipmentProcessParam(struct soap *soap, ns1__EquipmentProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EquipmentProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DownReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__DownReason::DownReasonCode = NULL;
	soap_default_dateTime(soap, &this->ns1__DownReason::BeginTime);
	soap_default_dateTime(soap, &this->ns1__DownReason::EndTime);
}

void ns1__DownReason::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__DownReason::DownReasonCode);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__DownReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DownReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DownReason(struct soap *soap, const char *tag, int id, const ns1__DownReason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DownReason), type ? type : "ns1:DownReason"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:DownReasonCode", -1, (wchar_t*const*)&a->ns1__DownReason::DownReasonCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:BeginTime", -1, &a->ns1__DownReason::BeginTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:EndTime", -1, &a->ns1__DownReason::EndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DownReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DownReason(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DownReason * SOAP_FMAC4 soap_in_ns1__DownReason(struct soap *soap, const char *tag, ns1__DownReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DownReason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DownReason, sizeof(ns1__DownReason), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DownReason)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DownReason *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_DownReasonCode1 = 1;
	size_t soap_flag_BeginTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_DownReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:DownReasonCode", (wchar_t**)&a->ns1__DownReason::DownReasonCode, "xsd:string"))
				{	soap_flag_DownReasonCode1--;
					continue;
				}
			}
			if (soap_flag_BeginTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:BeginTime", &a->ns1__DownReason::BeginTime, "xsd:dateTime"))
				{	soap_flag_BeginTime1--;
					continue;
				}
			}
			if (soap_flag_EndTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:EndTime", &a->ns1__DownReason::EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_BeginTime1 > 0 || soap_flag_EndTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DownReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DownReason, SOAP_TYPE_ns1__DownReason, sizeof(ns1__DownReason), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DownReason * SOAP_FMAC2 soap_instantiate_ns1__DownReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DownReason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DownReason *p;
	size_t k = sizeof(ns1__DownReason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DownReason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DownReason);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DownReason, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DownReason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DownReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DownReason(soap, tag ? tag : "ns1:DownReason", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DownReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DownReason(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DownReason * SOAP_FMAC4 soap_get_ns1__DownReason(struct soap *soap, ns1__DownReason *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfDownReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DownReason(soap, &this->ns1__ArrayOfDownReason::DownReason);
}

void ns1__ArrayOfDownReason::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DownReason(soap, &this->ns1__ArrayOfDownReason::DownReason);
#endif
}

int ns1__ArrayOfDownReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDownReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDownReason(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDownReason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDownReason), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DownReason(soap, "ns1:DownReason", -1, &a->ns1__ArrayOfDownReason::DownReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDownReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfDownReason(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDownReason * SOAP_FMAC4 soap_in_ns1__ArrayOfDownReason(struct soap *soap, const char *tag, ns1__ArrayOfDownReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDownReason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDownReason, sizeof(ns1__ArrayOfDownReason), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfDownReason)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfDownReason *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DownReason(soap, "ns1:DownReason", &a->ns1__ArrayOfDownReason::DownReason, "ns1:DownReason"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDownReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDownReason, SOAP_TYPE_ns1__ArrayOfDownReason, sizeof(ns1__ArrayOfDownReason), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfDownReason * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDownReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDownReason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfDownReason *p;
	size_t k = sizeof(ns1__ArrayOfDownReason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfDownReason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfDownReason);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfDownReason, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfDownReason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfDownReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfDownReason(soap, tag ? tag : "ns1:ArrayOfDownReason", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDownReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDownReason(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDownReason * SOAP_FMAC4 soap_get_ns1__ArrayOfDownReason(struct soap *soap, ns1__ArrayOfDownReason *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCDFileUploadCompleteSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CCDFileUploadCompleteSFC::SFC = NULL;
	this->ns1__CCDFileUploadCompleteSFC::Passed = NULL;
	this->ns1__CCDFileUploadCompleteSFC::URI = NULL;
	soap_default_dateTime(soap, &this->ns1__CCDFileUploadCompleteSFC::Timestamp);
}

void ns1__CCDFileUploadCompleteSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__CCDFileUploadCompleteSFC::SFC);
	soap_serialize_PointerToint(soap, &this->ns1__CCDFileUploadCompleteSFC::Passed);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__CCDFileUploadCompleteSFC::URI);
#endif
}

int ns1__CCDFileUploadCompleteSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCDFileUploadCompleteSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, int id, const ns1__CCDFileUploadCompleteSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__CCDFileUploadCompleteSFC::SFC, ""))
		return soap->error;
	if (!a->ns1__CCDFileUploadCompleteSFC::Passed)
	{	if (soap_element_nil(soap, "ns1:Passed"))
			return soap->error;
	}
	else if (soap_out_PointerToint(soap, "ns1:Passed", -1, &a->ns1__CCDFileUploadCompleteSFC::Passed, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:URI", -1, (wchar_t*const*)&a->ns1__CCDFileUploadCompleteSFC::URI, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:Timestamp", -1, &a->ns1__CCDFileUploadCompleteSFC::Timestamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CCDFileUploadCompleteSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCDFileUploadCompleteSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCDFileUploadCompleteSFC * SOAP_FMAC4 soap_in_ns1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, ns1__CCDFileUploadCompleteSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCDFileUploadCompleteSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, sizeof(ns1__CCDFileUploadCompleteSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CCDFileUploadCompleteSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCDFileUploadCompleteSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Passed1 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__CCDFileUploadCompleteSFC::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Passed", &a->ns1__CCDFileUploadCompleteSFC::Passed, "xsd:int"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:URI", (wchar_t**)&a->ns1__CCDFileUploadCompleteSFC::URI, "xsd:string"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:Timestamp", &a->ns1__CCDFileUploadCompleteSFC::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Passed1 > 0 || soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCDFileUploadCompleteSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, sizeof(ns1__CCDFileUploadCompleteSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCDFileUploadCompleteSFC * SOAP_FMAC2 soap_instantiate_ns1__CCDFileUploadCompleteSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCDFileUploadCompleteSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCDFileUploadCompleteSFC *p;
	size_t k = sizeof(ns1__CCDFileUploadCompleteSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCDFileUploadCompleteSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCDFileUploadCompleteSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCDFileUploadCompleteSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCDFileUploadCompleteSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCDFileUploadCompleteSFC(soap, tag ? tag : "ns1:CCDFileUploadCompleteSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCDFileUploadCompleteSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCDFileUploadCompleteSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCDFileUploadCompleteSFC * SOAP_FMAC4 soap_get_ns1__CCDFileUploadCompleteSFC(struct soap *soap, ns1__CCDFileUploadCompleteSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCDFileUploadCompleteSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfCCDFileUploadCompleteSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap, &this->ns1__ArrayOfCCDFileUploadCompleteSFC::CCDFileUploadCompleteSFC);
}

void ns1__ArrayOfCCDFileUploadCompleteSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap, &this->ns1__ArrayOfCCDFileUploadCompleteSFC::CCDFileUploadCompleteSFC);
#endif
}

int ns1__ArrayOfCCDFileUploadCompleteSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCCDFileUploadCompleteSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap, "ns1:CCDFileUploadCompleteSFC", -1, &a->ns1__ArrayOfCCDFileUploadCompleteSFC::CCDFileUploadCompleteSFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCCDFileUploadCompleteSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCCDFileUploadCompleteSFC * SOAP_FMAC4 soap_in_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, const char *tag, ns1__ArrayOfCCDFileUploadCompleteSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCCDFileUploadCompleteSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, sizeof(ns1__ArrayOfCCDFileUploadCompleteSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfCCDFileUploadCompleteSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap, "ns1:CCDFileUploadCompleteSFC", &a->ns1__ArrayOfCCDFileUploadCompleteSFC::CCDFileUploadCompleteSFC, "ns1:CCDFileUploadCompleteSFC"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCCDFileUploadCompleteSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, sizeof(ns1__ArrayOfCCDFileUploadCompleteSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfCCDFileUploadCompleteSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCCDFileUploadCompleteSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfCCDFileUploadCompleteSFC *p;
	size_t k = sizeof(ns1__ArrayOfCCDFileUploadCompleteSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfCCDFileUploadCompleteSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfCCDFileUploadCompleteSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfCCDFileUploadCompleteSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfCCDFileUploadCompleteSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag ? tag : "ns1:ArrayOfCCDFileUploadCompleteSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfCCDFileUploadCompleteSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCCDFileUploadCompleteSFC * SOAP_FMAC4 soap_get_ns1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, ns1__ArrayOfCCDFileUploadCompleteSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCDFileUploadComplete::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__CCDFileUploadComplete::SFCs = NULL;
}

void ns1__CCDFileUploadComplete::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, &this->ns1__CCDFileUploadComplete::SFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__CCDFileUploadComplete::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCDFileUploadComplete(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, int id, const ns1__CCDFileUploadComplete *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CCDFileUploadComplete), type ? type : "ns1:CCDFileUploadComplete"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, "ns1:SFCs", -1, &a->ns1__CCDFileUploadComplete::SFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CCDFileUploadComplete::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCDFileUploadComplete(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_in_ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, ns1__CCDFileUploadComplete *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCDFileUploadComplete*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CCDFileUploadComplete, sizeof(ns1__CCDFileUploadComplete), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CCDFileUploadComplete)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCDFileUploadComplete *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, "ns1:SFCs", &a->ns1__CCDFileUploadComplete::SFCs, "ns1:ArrayOfCCDFileUploadCompleteSFC"))
				{	soap_flag_SFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCDFileUploadComplete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CCDFileUploadComplete, SOAP_TYPE_ns1__CCDFileUploadComplete, sizeof(ns1__CCDFileUploadComplete), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate_ns1__CCDFileUploadComplete(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCDFileUploadComplete(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCDFileUploadComplete *p;
	size_t k = sizeof(ns1__CCDFileUploadComplete);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CCDFileUploadComplete, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCDFileUploadComplete);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCDFileUploadComplete, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCDFileUploadComplete location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCDFileUploadComplete::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCDFileUploadComplete(soap, tag ? tag : "ns1:CCDFileUploadComplete", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCDFileUploadComplete::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCDFileUploadComplete(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_get_ns1__CCDFileUploadComplete(struct soap *soap, ns1__CCDFileUploadComplete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCDFileUploadComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->ns1__ArrayOfString::string);
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->ns1__ArrayOfString::string);
#endif
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "ns1:string", -1, &a->ns1__ArrayOfString::string, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfString)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__wstring(soap, "ns1:string", &a->ns1__ArrayOfString::string, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfString *p;
	size_t k = sizeof(ns1__ArrayOfString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfString);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfString, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfString(soap, tag ? tag : "ns1:ArrayOfString", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BindSFCByScadaDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__BindSFCByScadaDTO::SFC = NULL;
	this->ns1__BindSFCByScadaDTO::BindSFCs = NULL;
}

void ns1__BindSFCByScadaDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BindSFCByScadaDTO::SFC);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__BindSFCByScadaDTO::BindSFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__BindSFCByScadaDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BindSFCByScadaDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BindSFCByScadaDTO(struct soap *soap, const char *tag, int id, const ns1__BindSFCByScadaDTO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BindSFCByScadaDTO), type ? type : "ns1:BindSFCByScadaDTO"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__BindSFCByScadaDTO::SFC, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:BindSFCs", -1, &a->ns1__BindSFCByScadaDTO::BindSFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BindSFCByScadaDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BindSFCByScadaDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BindSFCByScadaDTO * SOAP_FMAC4 soap_in_ns1__BindSFCByScadaDTO(struct soap *soap, const char *tag, ns1__BindSFCByScadaDTO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BindSFCByScadaDTO*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BindSFCByScadaDTO, sizeof(ns1__BindSFCByScadaDTO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BindSFCByScadaDTO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BindSFCByScadaDTO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_BindSFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__BindSFCByScadaDTO::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_BindSFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:BindSFCs", &a->ns1__BindSFCByScadaDTO::BindSFCs, "ns1:ArrayOfString"))
				{	soap_flag_BindSFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BindSFCByScadaDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BindSFCByScadaDTO, SOAP_TYPE_ns1__BindSFCByScadaDTO, sizeof(ns1__BindSFCByScadaDTO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BindSFCByScadaDTO * SOAP_FMAC2 soap_instantiate_ns1__BindSFCByScadaDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BindSFCByScadaDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BindSFCByScadaDTO *p;
	size_t k = sizeof(ns1__BindSFCByScadaDTO);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BindSFCByScadaDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BindSFCByScadaDTO);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BindSFCByScadaDTO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BindSFCByScadaDTO location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BindSFCByScadaDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BindSFCByScadaDTO(soap, tag ? tag : "ns1:BindSFCByScadaDTO", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BindSFCByScadaDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BindSFCByScadaDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BindSFCByScadaDTO * SOAP_FMAC4 soap_get_ns1__BindSFCByScadaDTO(struct soap *soap, ns1__BindSFCByScadaDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BindSFCByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BindContainerSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BindContainerSFC::SFC = NULL;
	this->ns1__BindContainerSFC::Location = NULL;
}

void ns1__BindContainerSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BindContainerSFC::SFC);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BindContainerSFC::Location);
#endif
}

int ns1__BindContainerSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BindContainerSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BindContainerSFC(struct soap *soap, const char *tag, int id, const ns1__BindContainerSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BindContainerSFC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:SFC", -1, (wchar_t*const*)&a->ns1__BindContainerSFC::SFC, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Location", -1, (wchar_t*const*)&a->ns1__BindContainerSFC::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BindContainerSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BindContainerSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BindContainerSFC * SOAP_FMAC4 soap_in_ns1__BindContainerSFC(struct soap *soap, const char *tag, ns1__BindContainerSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BindContainerSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BindContainerSFC, sizeof(ns1__BindContainerSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BindContainerSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BindContainerSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SFC1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SFC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:SFC", (wchar_t**)&a->ns1__BindContainerSFC::SFC, "xsd:string"))
				{	soap_flag_SFC1--;
					continue;
				}
			}
			if (soap_flag_Location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Location", (wchar_t**)&a->ns1__BindContainerSFC::Location, "xsd:string"))
				{	soap_flag_Location1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BindContainerSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BindContainerSFC, SOAP_TYPE_ns1__BindContainerSFC, sizeof(ns1__BindContainerSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BindContainerSFC * SOAP_FMAC2 soap_instantiate_ns1__BindContainerSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BindContainerSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BindContainerSFC *p;
	size_t k = sizeof(ns1__BindContainerSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BindContainerSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BindContainerSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BindContainerSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BindContainerSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BindContainerSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BindContainerSFC(soap, tag ? tag : "ns1:BindContainerSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BindContainerSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BindContainerSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BindContainerSFC * SOAP_FMAC4 soap_get_ns1__BindContainerSFC(struct soap *soap, ns1__BindContainerSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BindContainerSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfBindContainerSFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap, &this->ns1__ArrayOfBindContainerSFC::BindContainerSFC);
}

void ns1__ArrayOfBindContainerSFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap, &this->ns1__ArrayOfBindContainerSFC::BindContainerSFC);
#endif
}

int ns1__ArrayOfBindContainerSFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfBindContainerSFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfBindContainerSFC(struct soap *soap, const char *tag, int id, const ns1__ArrayOfBindContainerSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfBindContainerSFC), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap, "ns1:BindContainerSFC", -1, &a->ns1__ArrayOfBindContainerSFC::BindContainerSFC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfBindContainerSFC::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfBindContainerSFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfBindContainerSFC * SOAP_FMAC4 soap_in_ns1__ArrayOfBindContainerSFC(struct soap *soap, const char *tag, ns1__ArrayOfBindContainerSFC *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfBindContainerSFC*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, sizeof(ns1__ArrayOfBindContainerSFC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfBindContainerSFC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfBindContainerSFC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap, "ns1:BindContainerSFC", &a->ns1__ArrayOfBindContainerSFC::BindContainerSFC, "ns1:BindContainerSFC"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfBindContainerSFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, sizeof(ns1__ArrayOfBindContainerSFC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfBindContainerSFC * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfBindContainerSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfBindContainerSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfBindContainerSFC *p;
	size_t k = sizeof(ns1__ArrayOfBindContainerSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfBindContainerSFC);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfBindContainerSFC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfBindContainerSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfBindContainerSFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfBindContainerSFC(soap, tag ? tag : "ns1:ArrayOfBindContainerSFC", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfBindContainerSFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfBindContainerSFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfBindContainerSFC * SOAP_FMAC4 soap_get_ns1__ArrayOfBindContainerSFC(struct soap *soap, ns1__ArrayOfBindContainerSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfBindContainerSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BindContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__BindContainer::ContainerCode = NULL;
	this->ns1__BindContainer::ContainerSFCs = NULL;
}

void ns1__BindContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BindContainer::ContainerCode);
	soap_serialize_PointerTons1__ArrayOfBindContainerSFC(soap, &this->ns1__BindContainer::ContainerSFCs);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__BindContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BindContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BindContainer(struct soap *soap, const char *tag, int id, const ns1__BindContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BindContainer), type ? type : "ns1:BindContainer"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ContainerCode", -1, (wchar_t*const*)&a->ns1__BindContainer::ContainerCode, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfBindContainerSFC(soap, "ns1:ContainerSFCs", -1, &a->ns1__BindContainer::ContainerSFCs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BindContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BindContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BindContainer * SOAP_FMAC4 soap_in_ns1__BindContainer(struct soap *soap, const char *tag, ns1__BindContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BindContainer*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BindContainer, sizeof(ns1__BindContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BindContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BindContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_ContainerCode1 = 1;
	size_t soap_flag_ContainerSFCs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_ContainerCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ContainerCode", (wchar_t**)&a->ns1__BindContainer::ContainerCode, "xsd:string"))
				{	soap_flag_ContainerCode1--;
					continue;
				}
			}
			if (soap_flag_ContainerSFCs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfBindContainerSFC(soap, "ns1:ContainerSFCs", &a->ns1__BindContainer::ContainerSFCs, "ns1:ArrayOfBindContainerSFC"))
				{	soap_flag_ContainerSFCs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BindContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BindContainer, SOAP_TYPE_ns1__BindContainer, sizeof(ns1__BindContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BindContainer * SOAP_FMAC2 soap_instantiate_ns1__BindContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BindContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BindContainer *p;
	size_t k = sizeof(ns1__BindContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BindContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BindContainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BindContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BindContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BindContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BindContainer(soap, tag ? tag : "ns1:BindContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BindContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BindContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BindContainer * SOAP_FMAC4 soap_get_ns1__BindContainer(struct soap *soap, ns1__BindContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BindContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LoginSoapHeader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LoginSoapHeader::EquUserID = NULL;
	this->ns1__LoginSoapHeader::EquPassword = NULL;
	this->ns1__LoginSoapHeader::OperatorUserID = NULL;
	this->ns1__LoginSoapHeader::OperatorPassword = NULL;
	this->ns1__LoginSoapHeader::__anyAttribute = NULL;
}

void ns1__LoginSoapHeader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__LoginSoapHeader::EquUserID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__LoginSoapHeader::EquPassword);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__LoginSoapHeader::OperatorUserID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__LoginSoapHeader::OperatorPassword);
#endif
}

int ns1__LoginSoapHeader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LoginSoapHeader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoginSoapHeader(struct soap *soap, const char *tag, int id, const ns1__LoginSoapHeader *a, const char *type)
{
	if (((ns1__LoginSoapHeader*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns1__LoginSoapHeader*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoginSoapHeader), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquUserID", -1, (wchar_t*const*)&a->ns1__LoginSoapHeader::EquUserID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquPassword", -1, (wchar_t*const*)&a->ns1__LoginSoapHeader::EquPassword, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:OperatorUserID", -1, (wchar_t*const*)&a->ns1__LoginSoapHeader::OperatorUserID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:OperatorPassword", -1, (wchar_t*const*)&a->ns1__LoginSoapHeader::OperatorPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LoginSoapHeader::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__LoginSoapHeader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LoginSoapHeader * SOAP_FMAC4 soap_in_ns1__LoginSoapHeader(struct soap *soap, const char *tag, ns1__LoginSoapHeader *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LoginSoapHeader*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoginSoapHeader, sizeof(ns1__LoginSoapHeader), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LoginSoapHeader)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LoginSoapHeader *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((ns1__LoginSoapHeader*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_EquUserID1 = 1;
	size_t soap_flag_EquPassword1 = 1;
	size_t soap_flag_OperatorUserID1 = 1;
	size_t soap_flag_OperatorPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EquUserID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquUserID", (wchar_t**)&a->ns1__LoginSoapHeader::EquUserID, "xsd:string"))
				{	soap_flag_EquUserID1--;
					continue;
				}
			}
			if (soap_flag_EquPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquPassword", (wchar_t**)&a->ns1__LoginSoapHeader::EquPassword, "xsd:string"))
				{	soap_flag_EquPassword1--;
					continue;
				}
			}
			if (soap_flag_OperatorUserID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:OperatorUserID", (wchar_t**)&a->ns1__LoginSoapHeader::OperatorUserID, "xsd:string"))
				{	soap_flag_OperatorUserID1--;
					continue;
				}
			}
			if (soap_flag_OperatorPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:OperatorPassword", (wchar_t**)&a->ns1__LoginSoapHeader::OperatorPassword, "xsd:string"))
				{	soap_flag_OperatorPassword1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LoginSoapHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoginSoapHeader, SOAP_TYPE_ns1__LoginSoapHeader, sizeof(ns1__LoginSoapHeader), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LoginSoapHeader * SOAP_FMAC2 soap_instantiate_ns1__LoginSoapHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoginSoapHeader(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LoginSoapHeader *p;
	size_t k = sizeof(ns1__LoginSoapHeader);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__LoginSoapHeader, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__LoginSoapHeader);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__LoginSoapHeader, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LoginSoapHeader location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__LoginSoapHeader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LoginSoapHeader(soap, tag ? tag : "ns1:LoginSoapHeader", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LoginSoapHeader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LoginSoapHeader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LoginSoapHeader * SOAP_FMAC4 soap_get_ns1__LoginSoapHeader(struct soap *soap, ns1__LoginSoapHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoginSoapHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BaseApiResponseForScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__BaseApiResponseForScada::Code);
	this->ns1__BaseApiResponseForScada::Msg = NULL;
}

void ns1__BaseApiResponseForScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__BaseApiResponseForScada::Code, SOAP_TYPE_int);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BaseApiResponseForScada::Msg);
#endif
}

int ns1__BaseApiResponseForScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BaseApiResponseForScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BaseApiResponseForScada(struct soap *soap, const char *tag, int id, const ns1__BaseApiResponseForScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BaseApiResponseForScada), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BaseApiResponseForScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BaseApiResponseForScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BaseApiResponseForScada * SOAP_FMAC4 soap_in_ns1__BaseApiResponseForScada(struct soap *soap, const char *tag, ns1__BaseApiResponseForScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BaseApiResponseForScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BaseApiResponseForScada, sizeof(ns1__BaseApiResponseForScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BaseApiResponseForScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BaseApiResponseForScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BaseApiResponseForScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BaseApiResponseForScada, SOAP_TYPE_ns1__BaseApiResponseForScada, sizeof(ns1__BaseApiResponseForScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BaseApiResponseForScada * SOAP_FMAC2 soap_instantiate_ns1__BaseApiResponseForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BaseApiResponseForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseForScada"))
		return soap_instantiate_ns1__ApiResponseForScada(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada"))
		return soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseSFCForScada"))
		return soap_instantiate_ns1__ApiResponseSFCForScada(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseDataForScadaOfString"))
		return soap_instantiate_ns1__ApiResponseDataForScadaOfString(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu"))
		return soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseDataForScadaOfRecipeGetForEqu"))
		return soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu"))
		return soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, n, NULL, NULL, size);
	ns1__BaseApiResponseForScada *p;
	size_t k = sizeof(ns1__BaseApiResponseForScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BaseApiResponseForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BaseApiResponseForScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BaseApiResponseForScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BaseApiResponseForScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BaseApiResponseForScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BaseApiResponseForScada(soap, tag ? tag : "ns1:BaseApiResponseForScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BaseApiResponseForScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BaseApiResponseForScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BaseApiResponseForScada * SOAP_FMAC4 soap_get_ns1__BaseApiResponseForScada(struct soap *soap, ns1__BaseApiResponseForScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BaseApiResponseForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApiResponseForScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiResponseForScada::soap_default(soap);
}

void ns1__ApiResponseForScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns1__BaseApiResponseForScada::soap_serialize(soap);
#endif
}

int ns1__ApiResponseForScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApiResponseForScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApiResponseForScada(struct soap *soap, const char *tag, int id, const ns1__ApiResponseForScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApiResponseForScada), type ? type : "ns1:ApiResponseForScada"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &a->ns1__BaseApiResponseForScada::Code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:Msg", -1, (wchar_t*const*)&a->ns1__BaseApiResponseForScada::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApiResponseForScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ApiResponseForScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApiResponseForScada * SOAP_FMAC4 soap_in_ns1__ApiResponseForScada(struct soap *soap, const char *tag, ns1__ApiResponseForScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApiResponseForScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApiResponseForScada, sizeof(ns1__ApiResponseForScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApiResponseForScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApiResponseForScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code2 = 1;
	size_t soap_flag_Msg2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Code", &a->ns1__BaseApiResponseForScada::Code, "xsd:int"))
				{	soap_flag_Code2--;
					continue;
				}
			}
			if (soap_flag_Msg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:Msg", (wchar_t**)&a->ns1__BaseApiResponseForScada::Msg, "xsd:string"))
				{	soap_flag_Msg2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApiResponseForScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApiResponseForScada, SOAP_TYPE_ns1__ApiResponseForScada, sizeof(ns1__ApiResponseForScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApiResponseForScada * SOAP_FMAC2 soap_instantiate_ns1__ApiResponseForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApiResponseForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApiResponseForScada *p;
	size_t k = sizeof(ns1__ApiResponseForScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ApiResponseForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ApiResponseForScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ApiResponseForScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApiResponseForScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ApiResponseForScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApiResponseForScada(soap, tag ? tag : "ns1:ApiResponseForScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApiResponseForScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApiResponseForScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApiResponseForScada * SOAP_FMAC4 soap_get_ns1__ApiResponseForScada(struct soap *soap, ns1__ApiResponseForScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApiResponseForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BaseApiRequestByScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::ResourceCode = NULL;
	this->ns1__BaseApiRequestByScada::EquipmentCode = NULL;
	soap_default_dateTime(soap, &this->ns1__BaseApiRequestByScada::LocalTime);
}

void ns1__BaseApiRequestByScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BaseApiRequestByScada::ResourceCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__BaseApiRequestByScada::EquipmentCode);
#endif
}

int ns1__BaseApiRequestByScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BaseApiRequestByScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BaseApiRequestByScada(struct soap *soap, const char *tag, int id, const ns1__BaseApiRequestByScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BaseApiRequestByScada), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BaseApiRequestByScada::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BaseApiRequestByScada(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BaseApiRequestByScada * SOAP_FMAC4 soap_in_ns1__BaseApiRequestByScada(struct soap *soap, const char *tag, ns1__BaseApiRequestByScada *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BaseApiRequestByScada*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BaseApiRequestByScada, sizeof(ns1__BaseApiRequestByScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BaseApiRequestByScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BaseApiRequestByScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode1 = 1;
	size_t soap_flag_EquipmentCode1 = 1;
	size_t soap_flag_LocalTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode1--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode1--;
					continue;
				}
			}
			if (soap_flag_LocalTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BaseApiRequestByScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BaseApiRequestByScada, SOAP_TYPE_ns1__BaseApiRequestByScada, sizeof(ns1__BaseApiRequestByScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BaseApiRequestByScada * SOAP_FMAC2 soap_instantiate_ns1__BaseApiRequestByScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BaseApiRequestByScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns1:Alarm"))
		return soap_instantiate_ns1__Alarm(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:BindContainer"))
		return soap_instantiate_ns1__BindContainer(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:BindSFCByScadaDTO"))
		return soap_instantiate_ns1__BindSFCByScadaDTO(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:CCDFileUploadComplete"))
		return soap_instantiate_ns1__CCDFileUploadComplete(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:DownReason"))
		return soap_instantiate_ns1__DownReason(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:EquipmentProcessParam"))
		return soap_instantiate_ns1__EquipmentProcessParam(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:EquipmentProductProcessParam"))
		return soap_instantiate_ns1__EquipmentProductProcessParam(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ExamineExistsByScadaDTO"))
		return soap_instantiate_ns1__ExamineExistsByScadaDTO(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:FeedingByScadaDTO"))
		return soap_instantiate_ns1__FeedingByScadaDTO(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:FeedingDJInLaminatingByScadaDTO"))
		return soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:FillingData"))
		return soap_instantiate_ns1__FillingData(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:GenerateCellSFC"))
		return soap_instantiate_ns1__GenerateCellSFC(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:Heartbeat"))
		return soap_instantiate_ns1__Heartbeat(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:Inbound"))
		return soap_instantiate_ns1__Inbound(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:InboundInContainer"))
		return soap_instantiate_ns1__InboundInContainer(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:InboundInSFCContainer"))
		return soap_instantiate_ns1__InboundInSFCContainer(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:InboundInTwoInjection"))
		return soap_instantiate_ns1__InboundInTwoInjection(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:InboundMore"))
		return soap_instantiate_ns1__InboundMore(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:OperatorLogin"))
		return soap_instantiate_ns1__OperatorLogin(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:Outbound"))
		return soap_instantiate_ns1__Outbound(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:OutboundInLaminating"))
		return soap_instantiate_ns1__OutboundInLaminating(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:OutboundInSFCOutputQty"))
		return soap_instantiate_ns1__OutboundInSFCOutputQty(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:OutboundMore"))
		return soap_instantiate_ns1__OutboundMore(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:Recipe"))
		return soap_instantiate_ns1__Recipe(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RecipeGet"))
		return soap_instantiate_ns1__RecipeGet(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RecipeListGet"))
		return soap_instantiate_ns1__RecipeListGet(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RecipeVersionExamine"))
		return soap_instantiate_ns1__RecipeVersionExamine(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:State"))
		return soap_instantiate_ns1__State(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ToolBind"))
		return soap_instantiate_ns1__ToolBind(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:ToolLife"))
		return soap_instantiate_ns1__ToolLife(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:UnBindSFCByScadaDTO"))
		return soap_instantiate_ns1__UnBindSFCByScadaDTO(soap, n, NULL, NULL, size);
	ns1__BaseApiRequestByScada *p;
	size_t k = sizeof(ns1__BaseApiRequestByScada);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BaseApiRequestByScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BaseApiRequestByScada);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BaseApiRequestByScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BaseApiRequestByScada location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BaseApiRequestByScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BaseApiRequestByScada(soap, tag ? tag : "ns1:BaseApiRequestByScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BaseApiRequestByScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BaseApiRequestByScada(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BaseApiRequestByScada * SOAP_FMAC4 soap_get_ns1__BaseApiRequestByScada(struct soap *soap, ns1__BaseApiRequestByScada *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BaseApiRequestByScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Alarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BaseApiRequestByScada::soap_default(soap);
	this->ns1__Alarm::AlarmCode = NULL;
	soap_default_int(soap, &this->ns1__Alarm::Status);
	this->ns1__Alarm::AlarmMsg = NULL;
}

void ns1__Alarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Alarm::AlarmCode);
	soap_embedded(soap, &this->ns1__Alarm::Status, SOAP_TYPE_int);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns1__Alarm::AlarmMsg);
	this->ns1__BaseApiRequestByScada::soap_serialize(soap);
#endif
}

int ns1__Alarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Alarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Alarm(struct soap *soap, const char *tag, int id, const ns1__Alarm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Alarm), type ? type : "ns1:Alarm"))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:ResourceCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::ResourceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:EquipmentCode", -1, (wchar_t*const*)&a->ns1__BaseApiRequestByScada::EquipmentCode, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:LocalTime", -1, &a->ns1__BaseApiRequestByScada::LocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:AlarmCode", -1, (wchar_t*const*)&a->ns1__Alarm::AlarmCode, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Status", -1, &a->ns1__Alarm::Status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns1:AlarmMsg", -1, (wchar_t*const*)&a->ns1__Alarm::AlarmMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Alarm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Alarm(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Alarm * SOAP_FMAC4 soap_in_ns1__Alarm(struct soap *soap, const char *tag, ns1__Alarm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Alarm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Alarm, sizeof(ns1__Alarm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Alarm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Alarm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResourceCode2 = 1;
	size_t soap_flag_EquipmentCode2 = 1;
	size_t soap_flag_LocalTime2 = 1;
	size_t soap_flag_AlarmCode1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_AlarmMsg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:ResourceCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::ResourceCode, "xsd:string"))
				{	soap_flag_ResourceCode2--;
					continue;
				}
			}
			if (soap_flag_EquipmentCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:EquipmentCode", (wchar_t**)&a->ns1__BaseApiRequestByScada::EquipmentCode, "xsd:string"))
				{	soap_flag_EquipmentCode2--;
					continue;
				}
			}
			if (soap_flag_LocalTime2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:LocalTime", &a->ns1__BaseApiRequestByScada::LocalTime, "xsd:dateTime"))
				{	soap_flag_LocalTime2--;
					continue;
				}
			}
			if (soap_flag_AlarmCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:AlarmCode", (wchar_t**)&a->ns1__Alarm::AlarmCode, "xsd:string"))
				{	soap_flag_AlarmCode1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Status", &a->ns1__Alarm::Status, "xsd:int"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_AlarmMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wstring(soap, "ns1:AlarmMsg", (wchar_t**)&a->ns1__Alarm::AlarmMsg, "xsd:string"))
				{	soap_flag_AlarmMsg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalTime2 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Alarm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Alarm, SOAP_TYPE_ns1__Alarm, sizeof(ns1__Alarm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Alarm * SOAP_FMAC2 soap_instantiate_ns1__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Alarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Alarm *p;
	size_t k = sizeof(ns1__Alarm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Alarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Alarm);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Alarm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Alarm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Alarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Alarm(soap, tag ? tag : "ns1:Alarm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Alarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Alarm(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Alarm * SOAP_FMAC4 soap_get_ns1__Alarm(struct soap *soap, ns1__Alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfAlarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Alarm(soap, &this->ns1__ArrayOfAlarm::Alarm);
}

void ns1__ArrayOfAlarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Alarm(soap, &this->ns1__ArrayOfAlarm::Alarm);
#endif
}

int ns1__ArrayOfAlarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAlarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAlarm(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAlarm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAlarm), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Alarm(soap, "ns1:Alarm", -1, &a->ns1__ArrayOfAlarm::Alarm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAlarm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfAlarm(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAlarm * SOAP_FMAC4 soap_in_ns1__ArrayOfAlarm(struct soap *soap, const char *tag, ns1__ArrayOfAlarm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAlarm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAlarm, sizeof(ns1__ArrayOfAlarm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfAlarm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfAlarm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Alarm(soap, "ns1:Alarm", &a->ns1__ArrayOfAlarm::Alarm, "ns1:Alarm"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAlarm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAlarm, SOAP_TYPE_ns1__ArrayOfAlarm, sizeof(ns1__ArrayOfAlarm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfAlarm * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAlarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAlarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfAlarm *p;
	size_t k = sizeof(ns1__ArrayOfAlarm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfAlarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfAlarm);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfAlarm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfAlarm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfAlarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfAlarm(soap, tag ? tag : "ns1:ArrayOfAlarm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAlarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAlarm(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAlarm * SOAP_FMAC4 soap_get_ns1__ArrayOfAlarm(struct soap *soap, ns1__ArrayOfAlarm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAlarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__wstring, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::wstring *p;
	size_t k = sizeof(std::wstring);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::wstring);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::wstring, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::wstring location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_std__wstring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UnBindSFC_(struct soap *soap, struct __ns1__UnBindSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnBindSFC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UnBindSFC_(struct soap *soap, const struct __ns1__UnBindSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UnBindSFC(soap, &a->ns1__UnBindSFC);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UnBindSFC_(struct soap *soap, const char *tag, int id, const struct __ns1__UnBindSFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UnBindSFC(soap, "ns1:UnBindSFC", -1, &a->ns1__UnBindSFC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnBindSFC_ * SOAP_FMAC4 soap_in___ns1__UnBindSFC_(struct soap *soap, const char *tag, struct __ns1__UnBindSFC_ *a, const char *type)
{
	size_t soap_flag_ns1__UnBindSFC = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UnBindSFC_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UnBindSFC_, sizeof(struct __ns1__UnBindSFC_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UnBindSFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnBindSFC && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UnBindSFC(soap, "ns1:UnBindSFC", &a->ns1__UnBindSFC, ""))
				{	soap_flag_ns1__UnBindSFC--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UnBindSFC_ * SOAP_FMAC2 soap_instantiate___ns1__UnBindSFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UnBindSFC_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UnBindSFC_ *p;
	size_t k = sizeof(struct __ns1__UnBindSFC_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UnBindSFC_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UnBindSFC_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UnBindSFC_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UnBindSFC_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UnBindSFC_(struct soap *soap, const struct __ns1__UnBindSFC_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UnBindSFC_(soap, tag ? tag : "-ns1:UnBindSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnBindSFC_ * SOAP_FMAC4 soap_get___ns1__UnBindSFC_(struct soap *soap, struct __ns1__UnBindSFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UnBindSFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UnBindSFC(struct soap *soap, struct __ns1__UnBindSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnBindSFC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UnBindSFC(struct soap *soap, const struct __ns1__UnBindSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UnBindSFC(soap, &a->ns1__UnBindSFC);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UnBindSFC(struct soap *soap, const char *tag, int id, const struct __ns1__UnBindSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UnBindSFC(soap, "ns1:UnBindSFC", -1, &a->ns1__UnBindSFC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnBindSFC * SOAP_FMAC4 soap_in___ns1__UnBindSFC(struct soap *soap, const char *tag, struct __ns1__UnBindSFC *a, const char *type)
{
	size_t soap_flag_ns1__UnBindSFC = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UnBindSFC*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UnBindSFC, sizeof(struct __ns1__UnBindSFC), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UnBindSFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnBindSFC && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UnBindSFC(soap, "ns1:UnBindSFC", &a->ns1__UnBindSFC, ""))
				{	soap_flag_ns1__UnBindSFC--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UnBindSFC * SOAP_FMAC2 soap_instantiate___ns1__UnBindSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UnBindSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UnBindSFC *p;
	size_t k = sizeof(struct __ns1__UnBindSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UnBindSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UnBindSFC);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UnBindSFC, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UnBindSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UnBindSFC(struct soap *soap, const struct __ns1__UnBindSFC *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UnBindSFC(soap, tag ? tag : "-ns1:UnBindSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnBindSFC * SOAP_FMAC4 soap_get___ns1__UnBindSFC(struct soap *soap, struct __ns1__UnBindSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UnBindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToolLife_(struct soap *soap, struct __ns1__ToolLife_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToolLife_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToolLife_(struct soap *soap, const struct __ns1__ToolLife_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ToolLife(soap, &a->ns1__ToolLife_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToolLife_(struct soap *soap, const char *tag, int id, const struct __ns1__ToolLife_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ToolLife(soap, "ns1:ToolLife", -1, &a->ns1__ToolLife_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolLife_ * SOAP_FMAC4 soap_in___ns1__ToolLife_(struct soap *soap, const char *tag, struct __ns1__ToolLife_ *a, const char *type)
{
	size_t soap_flag_ns1__ToolLife_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ToolLife_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToolLife_, sizeof(struct __ns1__ToolLife_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToolLife_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToolLife_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ToolLife(soap, "ns1:ToolLife", &a->ns1__ToolLife_, ""))
				{	soap_flag_ns1__ToolLife_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ToolLife_ * SOAP_FMAC2 soap_instantiate___ns1__ToolLife_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ToolLife_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ToolLife_ *p;
	size_t k = sizeof(struct __ns1__ToolLife_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ToolLife_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ToolLife_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ToolLife_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ToolLife_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToolLife_(struct soap *soap, const struct __ns1__ToolLife_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ToolLife_(soap, tag ? tag : "-ns1:ToolLife", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolLife_ * SOAP_FMAC4 soap_get___ns1__ToolLife_(struct soap *soap, struct __ns1__ToolLife_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToolLife_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToolLife(struct soap *soap, struct __ns1__ToolLife *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToolLife_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToolLife(struct soap *soap, const struct __ns1__ToolLife *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ToolLife(soap, &a->ns1__ToolLife_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToolLife(struct soap *soap, const char *tag, int id, const struct __ns1__ToolLife *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ToolLife(soap, "ns1:ToolLife", -1, &a->ns1__ToolLife_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolLife * SOAP_FMAC4 soap_in___ns1__ToolLife(struct soap *soap, const char *tag, struct __ns1__ToolLife *a, const char *type)
{
	size_t soap_flag_ns1__ToolLife_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ToolLife*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToolLife, sizeof(struct __ns1__ToolLife), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToolLife(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToolLife_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ToolLife(soap, "ns1:ToolLife", &a->ns1__ToolLife_, ""))
				{	soap_flag_ns1__ToolLife_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ToolLife * SOAP_FMAC2 soap_instantiate___ns1__ToolLife(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ToolLife(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ToolLife *p;
	size_t k = sizeof(struct __ns1__ToolLife);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ToolLife, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ToolLife);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ToolLife, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ToolLife location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToolLife(struct soap *soap, const struct __ns1__ToolLife *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ToolLife(soap, tag ? tag : "-ns1:ToolLife", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolLife * SOAP_FMAC4 soap_get___ns1__ToolLife(struct soap *soap, struct __ns1__ToolLife *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToolLife(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToolBind_(struct soap *soap, struct __ns1__ToolBind_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToolBind_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToolBind_(struct soap *soap, const struct __ns1__ToolBind_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ToolBind(soap, &a->ns1__ToolBind_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToolBind_(struct soap *soap, const char *tag, int id, const struct __ns1__ToolBind_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ToolBind(soap, "ns1:ToolBind", -1, &a->ns1__ToolBind_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolBind_ * SOAP_FMAC4 soap_in___ns1__ToolBind_(struct soap *soap, const char *tag, struct __ns1__ToolBind_ *a, const char *type)
{
	size_t soap_flag_ns1__ToolBind_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ToolBind_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToolBind_, sizeof(struct __ns1__ToolBind_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToolBind_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToolBind_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ToolBind(soap, "ns1:ToolBind", &a->ns1__ToolBind_, ""))
				{	soap_flag_ns1__ToolBind_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ToolBind_ * SOAP_FMAC2 soap_instantiate___ns1__ToolBind_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ToolBind_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ToolBind_ *p;
	size_t k = sizeof(struct __ns1__ToolBind_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ToolBind_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ToolBind_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ToolBind_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ToolBind_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToolBind_(struct soap *soap, const struct __ns1__ToolBind_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ToolBind_(soap, tag ? tag : "-ns1:ToolBind", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolBind_ * SOAP_FMAC4 soap_get___ns1__ToolBind_(struct soap *soap, struct __ns1__ToolBind_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToolBind_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ToolBind(struct soap *soap, struct __ns1__ToolBind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ToolBind_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ToolBind(struct soap *soap, const struct __ns1__ToolBind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ToolBind(soap, &a->ns1__ToolBind_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ToolBind(struct soap *soap, const char *tag, int id, const struct __ns1__ToolBind *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ToolBind(soap, "ns1:ToolBind", -1, &a->ns1__ToolBind_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolBind * SOAP_FMAC4 soap_in___ns1__ToolBind(struct soap *soap, const char *tag, struct __ns1__ToolBind *a, const char *type)
{
	size_t soap_flag_ns1__ToolBind_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ToolBind*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ToolBind, sizeof(struct __ns1__ToolBind), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ToolBind(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ToolBind_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ToolBind(soap, "ns1:ToolBind", &a->ns1__ToolBind_, ""))
				{	soap_flag_ns1__ToolBind_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ToolBind * SOAP_FMAC2 soap_instantiate___ns1__ToolBind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ToolBind(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ToolBind *p;
	size_t k = sizeof(struct __ns1__ToolBind);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ToolBind, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ToolBind);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ToolBind, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ToolBind location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ToolBind(struct soap *soap, const struct __ns1__ToolBind *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ToolBind(soap, tag ? tag : "-ns1:ToolBind", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ToolBind * SOAP_FMAC4 soap_get___ns1__ToolBind(struct soap *soap, struct __ns1__ToolBind *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ToolBind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__State_(struct soap *soap, struct __ns1__State_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__State_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__State_(struct soap *soap, const struct __ns1__State_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__State(soap, &a->ns1__State_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__State_(struct soap *soap, const char *tag, int id, const struct __ns1__State_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__State(soap, "ns1:State", -1, &a->ns1__State_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__State_ * SOAP_FMAC4 soap_in___ns1__State_(struct soap *soap, const char *tag, struct __ns1__State_ *a, const char *type)
{
	size_t soap_flag_ns1__State_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__State_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__State_, sizeof(struct __ns1__State_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__State_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__State_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__State(soap, "ns1:State", &a->ns1__State_, ""))
				{	soap_flag_ns1__State_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__State_ * SOAP_FMAC2 soap_instantiate___ns1__State_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__State_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__State_ *p;
	size_t k = sizeof(struct __ns1__State_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__State_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__State_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__State_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__State_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__State_(struct soap *soap, const struct __ns1__State_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__State_(soap, tag ? tag : "-ns1:State", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__State_ * SOAP_FMAC4 soap_get___ns1__State_(struct soap *soap, struct __ns1__State_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__State_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__State(struct soap *soap, struct __ns1__State *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__State_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__State(struct soap *soap, const struct __ns1__State *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__State(soap, &a->ns1__State_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__State(struct soap *soap, const char *tag, int id, const struct __ns1__State *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__State(soap, "ns1:State", -1, &a->ns1__State_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__State * SOAP_FMAC4 soap_in___ns1__State(struct soap *soap, const char *tag, struct __ns1__State *a, const char *type)
{
	size_t soap_flag_ns1__State_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__State*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__State, sizeof(struct __ns1__State), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__State(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__State_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__State(soap, "ns1:State", &a->ns1__State_, ""))
				{	soap_flag_ns1__State_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__State * SOAP_FMAC2 soap_instantiate___ns1__State(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__State(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__State *p;
	size_t k = sizeof(struct __ns1__State);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__State, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__State);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__State, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__State location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__State(struct soap *soap, const struct __ns1__State *a, const char *tag, const char *type)
{
	if (soap_out___ns1__State(soap, tag ? tag : "-ns1:State", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__State * SOAP_FMAC4 soap_get___ns1__State(struct soap *soap, struct __ns1__State *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RecipeVersionExamine_(struct soap *soap, struct __ns1__RecipeVersionExamine_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RecipeVersionExamine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RecipeVersionExamine_(struct soap *soap, const struct __ns1__RecipeVersionExamine_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RecipeVersionExamine(soap, &a->ns1__RecipeVersionExamine_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RecipeVersionExamine_(struct soap *soap, const char *tag, int id, const struct __ns1__RecipeVersionExamine_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RecipeVersionExamine(soap, "ns1:RecipeVersionExamine", -1, &a->ns1__RecipeVersionExamine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RecipeVersionExamine_ * SOAP_FMAC4 soap_in___ns1__RecipeVersionExamine_(struct soap *soap, const char *tag, struct __ns1__RecipeVersionExamine_ *a, const char *type)
{
	size_t soap_flag_ns1__RecipeVersionExamine_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__RecipeVersionExamine_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RecipeVersionExamine_, sizeof(struct __ns1__RecipeVersionExamine_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RecipeVersionExamine_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RecipeVersionExamine_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__RecipeVersionExamine(soap, "ns1:RecipeVersionExamine", &a->ns1__RecipeVersionExamine_, ""))
				{	soap_flag_ns1__RecipeVersionExamine_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__RecipeVersionExamine_ * SOAP_FMAC2 soap_instantiate___ns1__RecipeVersionExamine_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RecipeVersionExamine_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__RecipeVersionExamine_ *p;
	size_t k = sizeof(struct __ns1__RecipeVersionExamine_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__RecipeVersionExamine_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__RecipeVersionExamine_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__RecipeVersionExamine_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__RecipeVersionExamine_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RecipeVersionExamine_(struct soap *soap, const struct __ns1__RecipeVersionExamine_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__RecipeVersionExamine_(soap, tag ? tag : "-ns1:RecipeVersionExamine", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RecipeVersionExamine_ * SOAP_FMAC4 soap_get___ns1__RecipeVersionExamine_(struct soap *soap, struct __ns1__RecipeVersionExamine_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RecipeVersionExamine_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RecipeVersionExamine(struct soap *soap, struct __ns1__RecipeVersionExamine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RecipeVersionExamine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RecipeVersionExamine(struct soap *soap, const struct __ns1__RecipeVersionExamine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RecipeVersionExamine(soap, &a->ns1__RecipeVersionExamine_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RecipeVersionExamine(struct soap *soap, const char *tag, int id, const struct __ns1__RecipeVersionExamine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RecipeVersionExamine(soap, "ns1:RecipeVersionExamine", -1, &a->ns1__RecipeVersionExamine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RecipeVersionExamine * SOAP_FMAC4 soap_in___ns1__RecipeVersionExamine(struct soap *soap, const char *tag, struct __ns1__RecipeVersionExamine *a, const char *type)
{
	size_t soap_flag_ns1__RecipeVersionExamine_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__RecipeVersionExamine*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RecipeVersionExamine, sizeof(struct __ns1__RecipeVersionExamine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RecipeVersionExamine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RecipeVersionExamine_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__RecipeVersionExamine(soap, "ns1:RecipeVersionExamine", &a->ns1__RecipeVersionExamine_, ""))
				{	soap_flag_ns1__RecipeVersionExamine_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__RecipeVersionExamine * SOAP_FMAC2 soap_instantiate___ns1__RecipeVersionExamine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RecipeVersionExamine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__RecipeVersionExamine *p;
	size_t k = sizeof(struct __ns1__RecipeVersionExamine);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__RecipeVersionExamine, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__RecipeVersionExamine);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__RecipeVersionExamine, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__RecipeVersionExamine location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RecipeVersionExamine(struct soap *soap, const struct __ns1__RecipeVersionExamine *a, const char *tag, const char *type)
{
	if (soap_out___ns1__RecipeVersionExamine(soap, tag ? tag : "-ns1:RecipeVersionExamine", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RecipeVersionExamine * SOAP_FMAC4 soap_get___ns1__RecipeVersionExamine(struct soap *soap, struct __ns1__RecipeVersionExamine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RecipeVersionExamine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRecipeList_(struct soap *soap, struct __ns1__GetRecipeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRecipeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRecipeList_(struct soap *soap, const struct __ns1__GetRecipeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRecipeList(soap, &a->ns1__GetRecipeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRecipeList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetRecipeList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRecipeList(soap, "ns1:GetRecipeList", -1, &a->ns1__GetRecipeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipeList_ * SOAP_FMAC4 soap_in___ns1__GetRecipeList_(struct soap *soap, const char *tag, struct __ns1__GetRecipeList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetRecipeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRecipeList_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRecipeList_, sizeof(struct __ns1__GetRecipeList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRecipeList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRecipeList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRecipeList(soap, "ns1:GetRecipeList", &a->ns1__GetRecipeList, ""))
				{	soap_flag_ns1__GetRecipeList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRecipeList_ * SOAP_FMAC2 soap_instantiate___ns1__GetRecipeList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRecipeList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRecipeList_ *p;
	size_t k = sizeof(struct __ns1__GetRecipeList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRecipeList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRecipeList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRecipeList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRecipeList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRecipeList_(struct soap *soap, const struct __ns1__GetRecipeList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRecipeList_(soap, tag ? tag : "-ns1:GetRecipeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipeList_ * SOAP_FMAC4 soap_get___ns1__GetRecipeList_(struct soap *soap, struct __ns1__GetRecipeList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRecipeList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRecipeList(struct soap *soap, struct __ns1__GetRecipeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRecipeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRecipeList(struct soap *soap, const struct __ns1__GetRecipeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRecipeList(soap, &a->ns1__GetRecipeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRecipeList(struct soap *soap, const char *tag, int id, const struct __ns1__GetRecipeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRecipeList(soap, "ns1:GetRecipeList", -1, &a->ns1__GetRecipeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipeList * SOAP_FMAC4 soap_in___ns1__GetRecipeList(struct soap *soap, const char *tag, struct __ns1__GetRecipeList *a, const char *type)
{
	size_t soap_flag_ns1__GetRecipeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRecipeList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRecipeList, sizeof(struct __ns1__GetRecipeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRecipeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRecipeList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRecipeList(soap, "ns1:GetRecipeList", &a->ns1__GetRecipeList, ""))
				{	soap_flag_ns1__GetRecipeList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRecipeList * SOAP_FMAC2 soap_instantiate___ns1__GetRecipeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRecipeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRecipeList *p;
	size_t k = sizeof(struct __ns1__GetRecipeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRecipeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRecipeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRecipeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRecipeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRecipeList(struct soap *soap, const struct __ns1__GetRecipeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRecipeList(soap, tag ? tag : "-ns1:GetRecipeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipeList * SOAP_FMAC4 soap_get___ns1__GetRecipeList(struct soap *soap, struct __ns1__GetRecipeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRecipeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRecipe_(struct soap *soap, struct __ns1__GetRecipe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRecipe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRecipe_(struct soap *soap, const struct __ns1__GetRecipe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRecipe(soap, &a->ns1__GetRecipe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRecipe_(struct soap *soap, const char *tag, int id, const struct __ns1__GetRecipe_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRecipe(soap, "ns1:GetRecipe", -1, &a->ns1__GetRecipe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipe_ * SOAP_FMAC4 soap_in___ns1__GetRecipe_(struct soap *soap, const char *tag, struct __ns1__GetRecipe_ *a, const char *type)
{
	size_t soap_flag_ns1__GetRecipe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRecipe_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRecipe_, sizeof(struct __ns1__GetRecipe_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRecipe_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRecipe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRecipe(soap, "ns1:GetRecipe", &a->ns1__GetRecipe, ""))
				{	soap_flag_ns1__GetRecipe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRecipe_ * SOAP_FMAC2 soap_instantiate___ns1__GetRecipe_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRecipe_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRecipe_ *p;
	size_t k = sizeof(struct __ns1__GetRecipe_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRecipe_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRecipe_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRecipe_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRecipe_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRecipe_(struct soap *soap, const struct __ns1__GetRecipe_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRecipe_(soap, tag ? tag : "-ns1:GetRecipe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipe_ * SOAP_FMAC4 soap_get___ns1__GetRecipe_(struct soap *soap, struct __ns1__GetRecipe_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRecipe_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRecipe(struct soap *soap, struct __ns1__GetRecipe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRecipe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRecipe(struct soap *soap, const struct __ns1__GetRecipe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRecipe(soap, &a->ns1__GetRecipe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRecipe(struct soap *soap, const char *tag, int id, const struct __ns1__GetRecipe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRecipe(soap, "ns1:GetRecipe", -1, &a->ns1__GetRecipe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipe * SOAP_FMAC4 soap_in___ns1__GetRecipe(struct soap *soap, const char *tag, struct __ns1__GetRecipe *a, const char *type)
{
	size_t soap_flag_ns1__GetRecipe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRecipe*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRecipe, sizeof(struct __ns1__GetRecipe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRecipe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRecipe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRecipe(soap, "ns1:GetRecipe", &a->ns1__GetRecipe, ""))
				{	soap_flag_ns1__GetRecipe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRecipe * SOAP_FMAC2 soap_instantiate___ns1__GetRecipe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRecipe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRecipe *p;
	size_t k = sizeof(struct __ns1__GetRecipe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRecipe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRecipe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRecipe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRecipe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRecipe(struct soap *soap, const struct __ns1__GetRecipe *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRecipe(soap, tag ? tag : "-ns1:GetRecipe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRecipe * SOAP_FMAC4 soap_get___ns1__GetRecipe(struct soap *soap, struct __ns1__GetRecipe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRecipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Recipe_(struct soap *soap, struct __ns1__Recipe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Recipe_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Recipe_(struct soap *soap, const struct __ns1__Recipe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Recipe(soap, &a->ns1__Recipe_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Recipe_(struct soap *soap, const char *tag, int id, const struct __ns1__Recipe_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Recipe(soap, "ns1:Recipe", -1, &a->ns1__Recipe_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Recipe_ * SOAP_FMAC4 soap_in___ns1__Recipe_(struct soap *soap, const char *tag, struct __ns1__Recipe_ *a, const char *type)
{
	size_t soap_flag_ns1__Recipe_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Recipe_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Recipe_, sizeof(struct __ns1__Recipe_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Recipe_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Recipe_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Recipe(soap, "ns1:Recipe", &a->ns1__Recipe_, ""))
				{	soap_flag_ns1__Recipe_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Recipe_ * SOAP_FMAC2 soap_instantiate___ns1__Recipe_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Recipe_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Recipe_ *p;
	size_t k = sizeof(struct __ns1__Recipe_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Recipe_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Recipe_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Recipe_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Recipe_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Recipe_(struct soap *soap, const struct __ns1__Recipe_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Recipe_(soap, tag ? tag : "-ns1:Recipe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Recipe_ * SOAP_FMAC4 soap_get___ns1__Recipe_(struct soap *soap, struct __ns1__Recipe_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Recipe_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Recipe(struct soap *soap, struct __ns1__Recipe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Recipe_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Recipe(struct soap *soap, const struct __ns1__Recipe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Recipe(soap, &a->ns1__Recipe_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Recipe(struct soap *soap, const char *tag, int id, const struct __ns1__Recipe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Recipe(soap, "ns1:Recipe", -1, &a->ns1__Recipe_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Recipe * SOAP_FMAC4 soap_in___ns1__Recipe(struct soap *soap, const char *tag, struct __ns1__Recipe *a, const char *type)
{
	size_t soap_flag_ns1__Recipe_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Recipe*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Recipe, sizeof(struct __ns1__Recipe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Recipe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Recipe_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Recipe(soap, "ns1:Recipe", &a->ns1__Recipe_, ""))
				{	soap_flag_ns1__Recipe_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Recipe * SOAP_FMAC2 soap_instantiate___ns1__Recipe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Recipe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Recipe *p;
	size_t k = sizeof(struct __ns1__Recipe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Recipe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Recipe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Recipe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Recipe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Recipe(struct soap *soap, const struct __ns1__Recipe *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Recipe(soap, tag ? tag : "-ns1:Recipe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Recipe * SOAP_FMAC4 soap_get___ns1__Recipe(struct soap *soap, struct __ns1__Recipe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Recipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundMore_(struct soap *soap, struct __ns1__OutboundMore_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundMore_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundMore_(struct soap *soap, const struct __ns1__OutboundMore_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundMore(soap, &a->ns1__OutboundMore_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundMore_(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundMore_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundMore(soap, "ns1:OutboundMore", -1, &a->ns1__OutboundMore_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundMore_ * SOAP_FMAC4 soap_in___ns1__OutboundMore_(struct soap *soap, const char *tag, struct __ns1__OutboundMore_ *a, const char *type)
{
	size_t soap_flag_ns1__OutboundMore_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundMore_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundMore_, sizeof(struct __ns1__OutboundMore_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundMore_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundMore_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundMore(soap, "ns1:OutboundMore", &a->ns1__OutboundMore_, ""))
				{	soap_flag_ns1__OutboundMore_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundMore_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundMore_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundMore_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundMore_ *p;
	size_t k = sizeof(struct __ns1__OutboundMore_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundMore_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundMore_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundMore_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundMore_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundMore_(struct soap *soap, const struct __ns1__OutboundMore_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundMore_(soap, tag ? tag : "-ns1:OutboundMore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundMore_ * SOAP_FMAC4 soap_get___ns1__OutboundMore_(struct soap *soap, struct __ns1__OutboundMore_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundMore_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundMore(struct soap *soap, struct __ns1__OutboundMore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundMore_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundMore(struct soap *soap, const struct __ns1__OutboundMore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundMore(soap, &a->ns1__OutboundMore_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundMore(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundMore(soap, "ns1:OutboundMore", -1, &a->ns1__OutboundMore_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundMore * SOAP_FMAC4 soap_in___ns1__OutboundMore(struct soap *soap, const char *tag, struct __ns1__OutboundMore *a, const char *type)
{
	size_t soap_flag_ns1__OutboundMore_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundMore*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundMore, sizeof(struct __ns1__OutboundMore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundMore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundMore_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundMore(soap, "ns1:OutboundMore", &a->ns1__OutboundMore_, ""))
				{	soap_flag_ns1__OutboundMore_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundMore * SOAP_FMAC2 soap_instantiate___ns1__OutboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundMore *p;
	size_t k = sizeof(struct __ns1__OutboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundMore);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundMore, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundMore(struct soap *soap, const struct __ns1__OutboundMore *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundMore(soap, tag ? tag : "-ns1:OutboundMore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundMore * SOAP_FMAC4 soap_get___ns1__OutboundMore(struct soap *soap, struct __ns1__OutboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundInSFCOutputQty_(struct soap *soap, struct __ns1__OutboundInSFCOutputQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundInSFCOutputQty_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundInSFCOutputQty_(struct soap *soap, const struct __ns1__OutboundInSFCOutputQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundInSFCOutputQty(soap, &a->ns1__OutboundInSFCOutputQty_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundInSFCOutputQty_(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundInSFCOutputQty_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundInSFCOutputQty(soap, "ns1:OutboundInSFCOutputQty", -1, &a->ns1__OutboundInSFCOutputQty_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInSFCOutputQty_ * SOAP_FMAC4 soap_in___ns1__OutboundInSFCOutputQty_(struct soap *soap, const char *tag, struct __ns1__OutboundInSFCOutputQty_ *a, const char *type)
{
	size_t soap_flag_ns1__OutboundInSFCOutputQty_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundInSFCOutputQty_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundInSFCOutputQty_, sizeof(struct __ns1__OutboundInSFCOutputQty_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundInSFCOutputQty_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundInSFCOutputQty_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundInSFCOutputQty(soap, "ns1:OutboundInSFCOutputQty", &a->ns1__OutboundInSFCOutputQty_, ""))
				{	soap_flag_ns1__OutboundInSFCOutputQty_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundInSFCOutputQty_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundInSFCOutputQty_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundInSFCOutputQty_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundInSFCOutputQty_ *p;
	size_t k = sizeof(struct __ns1__OutboundInSFCOutputQty_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundInSFCOutputQty_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundInSFCOutputQty_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundInSFCOutputQty_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundInSFCOutputQty_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundInSFCOutputQty_(struct soap *soap, const struct __ns1__OutboundInSFCOutputQty_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundInSFCOutputQty_(soap, tag ? tag : "-ns1:OutboundInSFCOutputQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInSFCOutputQty_ * SOAP_FMAC4 soap_get___ns1__OutboundInSFCOutputQty_(struct soap *soap, struct __ns1__OutboundInSFCOutputQty_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundInSFCOutputQty_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundInSFCOutputQty(struct soap *soap, struct __ns1__OutboundInSFCOutputQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundInSFCOutputQty_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundInSFCOutputQty(struct soap *soap, const struct __ns1__OutboundInSFCOutputQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundInSFCOutputQty(soap, &a->ns1__OutboundInSFCOutputQty_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundInSFCOutputQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundInSFCOutputQty(soap, "ns1:OutboundInSFCOutputQty", -1, &a->ns1__OutboundInSFCOutputQty_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_in___ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, struct __ns1__OutboundInSFCOutputQty *a, const char *type)
{
	size_t soap_flag_ns1__OutboundInSFCOutputQty_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundInSFCOutputQty*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundInSFCOutputQty, sizeof(struct __ns1__OutboundInSFCOutputQty), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundInSFCOutputQty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundInSFCOutputQty_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundInSFCOutputQty(soap, "ns1:OutboundInSFCOutputQty", &a->ns1__OutboundInSFCOutputQty_, ""))
				{	soap_flag_ns1__OutboundInSFCOutputQty_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundInSFCOutputQty * SOAP_FMAC2 soap_instantiate___ns1__OutboundInSFCOutputQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundInSFCOutputQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundInSFCOutputQty *p;
	size_t k = sizeof(struct __ns1__OutboundInSFCOutputQty);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundInSFCOutputQty, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundInSFCOutputQty);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundInSFCOutputQty, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundInSFCOutputQty location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundInSFCOutputQty(struct soap *soap, const struct __ns1__OutboundInSFCOutputQty *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundInSFCOutputQty(soap, tag ? tag : "-ns1:OutboundInSFCOutputQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInSFCOutputQty * SOAP_FMAC4 soap_get___ns1__OutboundInSFCOutputQty(struct soap *soap, struct __ns1__OutboundInSFCOutputQty *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundInSFCOutputQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundInLaminating_(struct soap *soap, struct __ns1__OutboundInLaminating_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundInLaminating_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundInLaminating_(struct soap *soap, const struct __ns1__OutboundInLaminating_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundInLaminating(soap, &a->ns1__OutboundInLaminating_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundInLaminating_(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundInLaminating_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundInLaminating(soap, "ns1:OutboundInLaminating", -1, &a->ns1__OutboundInLaminating_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInLaminating_ * SOAP_FMAC4 soap_in___ns1__OutboundInLaminating_(struct soap *soap, const char *tag, struct __ns1__OutboundInLaminating_ *a, const char *type)
{
	size_t soap_flag_ns1__OutboundInLaminating_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundInLaminating_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundInLaminating_, sizeof(struct __ns1__OutboundInLaminating_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundInLaminating_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundInLaminating_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundInLaminating(soap, "ns1:OutboundInLaminating", &a->ns1__OutboundInLaminating_, ""))
				{	soap_flag_ns1__OutboundInLaminating_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundInLaminating_ * SOAP_FMAC2 soap_instantiate___ns1__OutboundInLaminating_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundInLaminating_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundInLaminating_ *p;
	size_t k = sizeof(struct __ns1__OutboundInLaminating_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundInLaminating_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundInLaminating_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundInLaminating_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundInLaminating_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundInLaminating_(struct soap *soap, const struct __ns1__OutboundInLaminating_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundInLaminating_(soap, tag ? tag : "-ns1:OutboundInLaminating", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInLaminating_ * SOAP_FMAC4 soap_get___ns1__OutboundInLaminating_(struct soap *soap, struct __ns1__OutboundInLaminating_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundInLaminating_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutboundInLaminating(struct soap *soap, struct __ns1__OutboundInLaminating *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutboundInLaminating_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutboundInLaminating(struct soap *soap, const struct __ns1__OutboundInLaminating *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutboundInLaminating(soap, &a->ns1__OutboundInLaminating_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutboundInLaminating(struct soap *soap, const char *tag, int id, const struct __ns1__OutboundInLaminating *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutboundInLaminating(soap, "ns1:OutboundInLaminating", -1, &a->ns1__OutboundInLaminating_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInLaminating * SOAP_FMAC4 soap_in___ns1__OutboundInLaminating(struct soap *soap, const char *tag, struct __ns1__OutboundInLaminating *a, const char *type)
{
	size_t soap_flag_ns1__OutboundInLaminating_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutboundInLaminating*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutboundInLaminating, sizeof(struct __ns1__OutboundInLaminating), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutboundInLaminating(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutboundInLaminating_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutboundInLaminating(soap, "ns1:OutboundInLaminating", &a->ns1__OutboundInLaminating_, ""))
				{	soap_flag_ns1__OutboundInLaminating_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutboundInLaminating * SOAP_FMAC2 soap_instantiate___ns1__OutboundInLaminating(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutboundInLaminating(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutboundInLaminating *p;
	size_t k = sizeof(struct __ns1__OutboundInLaminating);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OutboundInLaminating, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OutboundInLaminating);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OutboundInLaminating, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutboundInLaminating location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutboundInLaminating(struct soap *soap, const struct __ns1__OutboundInLaminating *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutboundInLaminating(soap, tag ? tag : "-ns1:OutboundInLaminating", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutboundInLaminating * SOAP_FMAC4 soap_get___ns1__OutboundInLaminating(struct soap *soap, struct __ns1__OutboundInLaminating *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutboundInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Outbound_(struct soap *soap, struct __ns1__Outbound_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Outbound_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Outbound_(struct soap *soap, const struct __ns1__Outbound_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Outbound(soap, &a->ns1__Outbound_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Outbound_(struct soap *soap, const char *tag, int id, const struct __ns1__Outbound_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Outbound(soap, "ns1:Outbound", -1, &a->ns1__Outbound_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Outbound_ * SOAP_FMAC4 soap_in___ns1__Outbound_(struct soap *soap, const char *tag, struct __ns1__Outbound_ *a, const char *type)
{
	size_t soap_flag_ns1__Outbound_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Outbound_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Outbound_, sizeof(struct __ns1__Outbound_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Outbound_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Outbound_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Outbound(soap, "ns1:Outbound", &a->ns1__Outbound_, ""))
				{	soap_flag_ns1__Outbound_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Outbound_ * SOAP_FMAC2 soap_instantiate___ns1__Outbound_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Outbound_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Outbound_ *p;
	size_t k = sizeof(struct __ns1__Outbound_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Outbound_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Outbound_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Outbound_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Outbound_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Outbound_(struct soap *soap, const struct __ns1__Outbound_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Outbound_(soap, tag ? tag : "-ns1:Outbound", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Outbound_ * SOAP_FMAC4 soap_get___ns1__Outbound_(struct soap *soap, struct __ns1__Outbound_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Outbound_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Outbound(struct soap *soap, struct __ns1__Outbound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Outbound_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Outbound(struct soap *soap, const struct __ns1__Outbound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Outbound(soap, &a->ns1__Outbound_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Outbound(struct soap *soap, const char *tag, int id, const struct __ns1__Outbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Outbound(soap, "ns1:Outbound", -1, &a->ns1__Outbound_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Outbound * SOAP_FMAC4 soap_in___ns1__Outbound(struct soap *soap, const char *tag, struct __ns1__Outbound *a, const char *type)
{
	size_t soap_flag_ns1__Outbound_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Outbound*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Outbound, sizeof(struct __ns1__Outbound), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Outbound(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Outbound_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Outbound(soap, "ns1:Outbound", &a->ns1__Outbound_, ""))
				{	soap_flag_ns1__Outbound_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Outbound * SOAP_FMAC2 soap_instantiate___ns1__Outbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Outbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Outbound *p;
	size_t k = sizeof(struct __ns1__Outbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Outbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Outbound);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Outbound, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Outbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Outbound(struct soap *soap, const struct __ns1__Outbound *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Outbound(soap, tag ? tag : "-ns1:Outbound", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Outbound * SOAP_FMAC4 soap_get___ns1__Outbound(struct soap *soap, struct __ns1__Outbound *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Outbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OperatorLogin_(struct soap *soap, struct __ns1__OperatorLogin_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OperatorLogin_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OperatorLogin_(struct soap *soap, const struct __ns1__OperatorLogin_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OperatorLogin(soap, &a->ns1__OperatorLogin_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OperatorLogin_(struct soap *soap, const char *tag, int id, const struct __ns1__OperatorLogin_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OperatorLogin(soap, "ns1:OperatorLogin", -1, &a->ns1__OperatorLogin_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperatorLogin_ * SOAP_FMAC4 soap_in___ns1__OperatorLogin_(struct soap *soap, const char *tag, struct __ns1__OperatorLogin_ *a, const char *type)
{
	size_t soap_flag_ns1__OperatorLogin_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OperatorLogin_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OperatorLogin_, sizeof(struct __ns1__OperatorLogin_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OperatorLogin_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OperatorLogin_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OperatorLogin(soap, "ns1:OperatorLogin", &a->ns1__OperatorLogin_, ""))
				{	soap_flag_ns1__OperatorLogin_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OperatorLogin_ * SOAP_FMAC2 soap_instantiate___ns1__OperatorLogin_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OperatorLogin_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OperatorLogin_ *p;
	size_t k = sizeof(struct __ns1__OperatorLogin_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OperatorLogin_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OperatorLogin_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OperatorLogin_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OperatorLogin_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OperatorLogin_(struct soap *soap, const struct __ns1__OperatorLogin_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OperatorLogin_(soap, tag ? tag : "-ns1:OperatorLogin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperatorLogin_ * SOAP_FMAC4 soap_get___ns1__OperatorLogin_(struct soap *soap, struct __ns1__OperatorLogin_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OperatorLogin_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OperatorLogin(struct soap *soap, struct __ns1__OperatorLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OperatorLogin_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OperatorLogin(struct soap *soap, const struct __ns1__OperatorLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OperatorLogin(soap, &a->ns1__OperatorLogin_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OperatorLogin(struct soap *soap, const char *tag, int id, const struct __ns1__OperatorLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OperatorLogin(soap, "ns1:OperatorLogin", -1, &a->ns1__OperatorLogin_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperatorLogin * SOAP_FMAC4 soap_in___ns1__OperatorLogin(struct soap *soap, const char *tag, struct __ns1__OperatorLogin *a, const char *type)
{
	size_t soap_flag_ns1__OperatorLogin_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OperatorLogin*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OperatorLogin, sizeof(struct __ns1__OperatorLogin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OperatorLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OperatorLogin_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OperatorLogin(soap, "ns1:OperatorLogin", &a->ns1__OperatorLogin_, ""))
				{	soap_flag_ns1__OperatorLogin_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OperatorLogin * SOAP_FMAC2 soap_instantiate___ns1__OperatorLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OperatorLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OperatorLogin *p;
	size_t k = sizeof(struct __ns1__OperatorLogin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OperatorLogin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OperatorLogin);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OperatorLogin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OperatorLogin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OperatorLogin(struct soap *soap, const struct __ns1__OperatorLogin *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OperatorLogin(soap, tag ? tag : "-ns1:OperatorLogin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperatorLogin * SOAP_FMAC4 soap_get___ns1__OperatorLogin(struct soap *soap, struct __ns1__OperatorLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OperatorLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundMore_(struct soap *soap, struct __ns1__InboundMore_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundMore_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundMore_(struct soap *soap, const struct __ns1__InboundMore_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundMore(soap, &a->ns1__InboundMore_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundMore_(struct soap *soap, const char *tag, int id, const struct __ns1__InboundMore_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundMore(soap, "ns1:InboundMore", -1, &a->ns1__InboundMore_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundMore_ * SOAP_FMAC4 soap_in___ns1__InboundMore_(struct soap *soap, const char *tag, struct __ns1__InboundMore_ *a, const char *type)
{
	size_t soap_flag_ns1__InboundMore_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundMore_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundMore_, sizeof(struct __ns1__InboundMore_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundMore_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundMore_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundMore(soap, "ns1:InboundMore", &a->ns1__InboundMore_, ""))
				{	soap_flag_ns1__InboundMore_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundMore_ * SOAP_FMAC2 soap_instantiate___ns1__InboundMore_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundMore_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundMore_ *p;
	size_t k = sizeof(struct __ns1__InboundMore_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundMore_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundMore_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundMore_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundMore_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundMore_(struct soap *soap, const struct __ns1__InboundMore_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundMore_(soap, tag ? tag : "-ns1:InboundMore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundMore_ * SOAP_FMAC4 soap_get___ns1__InboundMore_(struct soap *soap, struct __ns1__InboundMore_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundMore_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundMore(struct soap *soap, struct __ns1__InboundMore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundMore_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundMore(struct soap *soap, const struct __ns1__InboundMore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundMore(soap, &a->ns1__InboundMore_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundMore(struct soap *soap, const char *tag, int id, const struct __ns1__InboundMore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundMore(soap, "ns1:InboundMore", -1, &a->ns1__InboundMore_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundMore * SOAP_FMAC4 soap_in___ns1__InboundMore(struct soap *soap, const char *tag, struct __ns1__InboundMore *a, const char *type)
{
	size_t soap_flag_ns1__InboundMore_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundMore*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundMore, sizeof(struct __ns1__InboundMore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundMore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundMore_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundMore(soap, "ns1:InboundMore", &a->ns1__InboundMore_, ""))
				{	soap_flag_ns1__InboundMore_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundMore * SOAP_FMAC2 soap_instantiate___ns1__InboundMore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundMore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundMore *p;
	size_t k = sizeof(struct __ns1__InboundMore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundMore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundMore);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundMore, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundMore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundMore(struct soap *soap, const struct __ns1__InboundMore *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundMore(soap, tag ? tag : "-ns1:InboundMore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundMore * SOAP_FMAC4 soap_get___ns1__InboundMore(struct soap *soap, struct __ns1__InboundMore *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInTwoInjection_(struct soap *soap, struct __ns1__InboundInTwoInjection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInTwoInjection_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInTwoInjection_(struct soap *soap, const struct __ns1__InboundInTwoInjection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInTwoInjection(soap, &a->ns1__InboundInTwoInjection_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInTwoInjection_(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInTwoInjection_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInTwoInjection(soap, "ns1:InboundInTwoInjection", -1, &a->ns1__InboundInTwoInjection_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInTwoInjection_ * SOAP_FMAC4 soap_in___ns1__InboundInTwoInjection_(struct soap *soap, const char *tag, struct __ns1__InboundInTwoInjection_ *a, const char *type)
{
	size_t soap_flag_ns1__InboundInTwoInjection_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInTwoInjection_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInTwoInjection_, sizeof(struct __ns1__InboundInTwoInjection_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInTwoInjection_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInTwoInjection_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInTwoInjection(soap, "ns1:InboundInTwoInjection", &a->ns1__InboundInTwoInjection_, ""))
				{	soap_flag_ns1__InboundInTwoInjection_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInTwoInjection_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInTwoInjection_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInTwoInjection_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInTwoInjection_ *p;
	size_t k = sizeof(struct __ns1__InboundInTwoInjection_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInTwoInjection_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInTwoInjection_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInTwoInjection_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInTwoInjection_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInTwoInjection_(struct soap *soap, const struct __ns1__InboundInTwoInjection_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInTwoInjection_(soap, tag ? tag : "-ns1:InboundInTwoInjection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInTwoInjection_ * SOAP_FMAC4 soap_get___ns1__InboundInTwoInjection_(struct soap *soap, struct __ns1__InboundInTwoInjection_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInTwoInjection_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInTwoInjection(struct soap *soap, struct __ns1__InboundInTwoInjection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInTwoInjection_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInTwoInjection(struct soap *soap, const struct __ns1__InboundInTwoInjection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInTwoInjection(soap, &a->ns1__InboundInTwoInjection_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInTwoInjection(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInTwoInjection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInTwoInjection(soap, "ns1:InboundInTwoInjection", -1, &a->ns1__InboundInTwoInjection_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInTwoInjection * SOAP_FMAC4 soap_in___ns1__InboundInTwoInjection(struct soap *soap, const char *tag, struct __ns1__InboundInTwoInjection *a, const char *type)
{
	size_t soap_flag_ns1__InboundInTwoInjection_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInTwoInjection*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInTwoInjection, sizeof(struct __ns1__InboundInTwoInjection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInTwoInjection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInTwoInjection_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInTwoInjection(soap, "ns1:InboundInTwoInjection", &a->ns1__InboundInTwoInjection_, ""))
				{	soap_flag_ns1__InboundInTwoInjection_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInTwoInjection * SOAP_FMAC2 soap_instantiate___ns1__InboundInTwoInjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInTwoInjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInTwoInjection *p;
	size_t k = sizeof(struct __ns1__InboundInTwoInjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInTwoInjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInTwoInjection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInTwoInjection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInTwoInjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInTwoInjection(struct soap *soap, const struct __ns1__InboundInTwoInjection *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInTwoInjection(soap, tag ? tag : "-ns1:InboundInTwoInjection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInTwoInjection * SOAP_FMAC4 soap_get___ns1__InboundInTwoInjection(struct soap *soap, struct __ns1__InboundInTwoInjection *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInTwoInjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInSFCContainer_(struct soap *soap, struct __ns1__InboundInSFCContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInSFCContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInSFCContainer_(struct soap *soap, const struct __ns1__InboundInSFCContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInSFCContainer(soap, &a->ns1__InboundInSFCContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInSFCContainer_(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInSFCContainer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInSFCContainer(soap, "ns1:InboundInSFCContainer", -1, &a->ns1__InboundInSFCContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInSFCContainer_ * SOAP_FMAC4 soap_in___ns1__InboundInSFCContainer_(struct soap *soap, const char *tag, struct __ns1__InboundInSFCContainer_ *a, const char *type)
{
	size_t soap_flag_ns1__InboundInSFCContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInSFCContainer_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInSFCContainer_, sizeof(struct __ns1__InboundInSFCContainer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInSFCContainer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInSFCContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInSFCContainer(soap, "ns1:InboundInSFCContainer", &a->ns1__InboundInSFCContainer_, ""))
				{	soap_flag_ns1__InboundInSFCContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInSFCContainer_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInSFCContainer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInSFCContainer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInSFCContainer_ *p;
	size_t k = sizeof(struct __ns1__InboundInSFCContainer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInSFCContainer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInSFCContainer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInSFCContainer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInSFCContainer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInSFCContainer_(struct soap *soap, const struct __ns1__InboundInSFCContainer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInSFCContainer_(soap, tag ? tag : "-ns1:InboundInSFCContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInSFCContainer_ * SOAP_FMAC4 soap_get___ns1__InboundInSFCContainer_(struct soap *soap, struct __ns1__InboundInSFCContainer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInSFCContainer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInSFCContainer(struct soap *soap, struct __ns1__InboundInSFCContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInSFCContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInSFCContainer(struct soap *soap, const struct __ns1__InboundInSFCContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInSFCContainer(soap, &a->ns1__InboundInSFCContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInSFCContainer(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInSFCContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInSFCContainer(soap, "ns1:InboundInSFCContainer", -1, &a->ns1__InboundInSFCContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInSFCContainer * SOAP_FMAC4 soap_in___ns1__InboundInSFCContainer(struct soap *soap, const char *tag, struct __ns1__InboundInSFCContainer *a, const char *type)
{
	size_t soap_flag_ns1__InboundInSFCContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInSFCContainer*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInSFCContainer, sizeof(struct __ns1__InboundInSFCContainer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInSFCContainer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInSFCContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInSFCContainer(soap, "ns1:InboundInSFCContainer", &a->ns1__InboundInSFCContainer_, ""))
				{	soap_flag_ns1__InboundInSFCContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInSFCContainer * SOAP_FMAC2 soap_instantiate___ns1__InboundInSFCContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInSFCContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInSFCContainer *p;
	size_t k = sizeof(struct __ns1__InboundInSFCContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInSFCContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInSFCContainer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInSFCContainer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInSFCContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInSFCContainer(struct soap *soap, const struct __ns1__InboundInSFCContainer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInSFCContainer(soap, tag ? tag : "-ns1:InboundInSFCContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInSFCContainer * SOAP_FMAC4 soap_get___ns1__InboundInSFCContainer(struct soap *soap, struct __ns1__InboundInSFCContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInSFCContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInContainer_(struct soap *soap, struct __ns1__InboundInContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInContainer_(struct soap *soap, const struct __ns1__InboundInContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInContainer(soap, &a->ns1__InboundInContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInContainer_(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInContainer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInContainer(soap, "ns1:InboundInContainer", -1, &a->ns1__InboundInContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInContainer_ * SOAP_FMAC4 soap_in___ns1__InboundInContainer_(struct soap *soap, const char *tag, struct __ns1__InboundInContainer_ *a, const char *type)
{
	size_t soap_flag_ns1__InboundInContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInContainer_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInContainer_, sizeof(struct __ns1__InboundInContainer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInContainer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInContainer(soap, "ns1:InboundInContainer", &a->ns1__InboundInContainer_, ""))
				{	soap_flag_ns1__InboundInContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInContainer_ * SOAP_FMAC2 soap_instantiate___ns1__InboundInContainer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInContainer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInContainer_ *p;
	size_t k = sizeof(struct __ns1__InboundInContainer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInContainer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInContainer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInContainer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInContainer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInContainer_(struct soap *soap, const struct __ns1__InboundInContainer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInContainer_(soap, tag ? tag : "-ns1:InboundInContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInContainer_ * SOAP_FMAC4 soap_get___ns1__InboundInContainer_(struct soap *soap, struct __ns1__InboundInContainer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInContainer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InboundInContainer(struct soap *soap, struct __ns1__InboundInContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InboundInContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InboundInContainer(struct soap *soap, const struct __ns1__InboundInContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InboundInContainer(soap, &a->ns1__InboundInContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InboundInContainer(struct soap *soap, const char *tag, int id, const struct __ns1__InboundInContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InboundInContainer(soap, "ns1:InboundInContainer", -1, &a->ns1__InboundInContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInContainer * SOAP_FMAC4 soap_in___ns1__InboundInContainer(struct soap *soap, const char *tag, struct __ns1__InboundInContainer *a, const char *type)
{
	size_t soap_flag_ns1__InboundInContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InboundInContainer*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InboundInContainer, sizeof(struct __ns1__InboundInContainer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InboundInContainer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InboundInContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InboundInContainer(soap, "ns1:InboundInContainer", &a->ns1__InboundInContainer_, ""))
				{	soap_flag_ns1__InboundInContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InboundInContainer * SOAP_FMAC2 soap_instantiate___ns1__InboundInContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InboundInContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InboundInContainer *p;
	size_t k = sizeof(struct __ns1__InboundInContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InboundInContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InboundInContainer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InboundInContainer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InboundInContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InboundInContainer(struct soap *soap, const struct __ns1__InboundInContainer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InboundInContainer(soap, tag ? tag : "-ns1:InboundInContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InboundInContainer * SOAP_FMAC4 soap_get___ns1__InboundInContainer(struct soap *soap, struct __ns1__InboundInContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InboundInContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Inbound_(struct soap *soap, struct __ns1__Inbound_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Inbound_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Inbound_(struct soap *soap, const struct __ns1__Inbound_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Inbound(soap, &a->ns1__Inbound_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Inbound_(struct soap *soap, const char *tag, int id, const struct __ns1__Inbound_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Inbound(soap, "ns1:Inbound", -1, &a->ns1__Inbound_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Inbound_ * SOAP_FMAC4 soap_in___ns1__Inbound_(struct soap *soap, const char *tag, struct __ns1__Inbound_ *a, const char *type)
{
	size_t soap_flag_ns1__Inbound_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Inbound_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Inbound_, sizeof(struct __ns1__Inbound_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Inbound_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Inbound_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Inbound(soap, "ns1:Inbound", &a->ns1__Inbound_, ""))
				{	soap_flag_ns1__Inbound_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Inbound_ * SOAP_FMAC2 soap_instantiate___ns1__Inbound_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Inbound_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Inbound_ *p;
	size_t k = sizeof(struct __ns1__Inbound_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Inbound_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Inbound_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Inbound_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Inbound_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Inbound_(struct soap *soap, const struct __ns1__Inbound_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Inbound_(soap, tag ? tag : "-ns1:Inbound", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Inbound_ * SOAP_FMAC4 soap_get___ns1__Inbound_(struct soap *soap, struct __ns1__Inbound_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Inbound_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Inbound(struct soap *soap, struct __ns1__Inbound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Inbound_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Inbound(struct soap *soap, const struct __ns1__Inbound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Inbound(soap, &a->ns1__Inbound_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Inbound(struct soap *soap, const char *tag, int id, const struct __ns1__Inbound *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Inbound(soap, "ns1:Inbound", -1, &a->ns1__Inbound_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Inbound * SOAP_FMAC4 soap_in___ns1__Inbound(struct soap *soap, const char *tag, struct __ns1__Inbound *a, const char *type)
{
	size_t soap_flag_ns1__Inbound_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Inbound*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Inbound, sizeof(struct __ns1__Inbound), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Inbound(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Inbound_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Inbound(soap, "ns1:Inbound", &a->ns1__Inbound_, ""))
				{	soap_flag_ns1__Inbound_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Inbound * SOAP_FMAC2 soap_instantiate___ns1__Inbound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Inbound(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Inbound *p;
	size_t k = sizeof(struct __ns1__Inbound);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Inbound, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Inbound);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Inbound, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Inbound location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Inbound(struct soap *soap, const struct __ns1__Inbound *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Inbound(soap, tag ? tag : "-ns1:Inbound", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Inbound * SOAP_FMAC4 soap_get___ns1__Inbound(struct soap *soap, struct __ns1__Inbound *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Inbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Heartbeat_(struct soap *soap, struct __ns1__Heartbeat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Heartbeat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Heartbeat_(struct soap *soap, const struct __ns1__Heartbeat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Heartbeat(soap, &a->ns1__Heartbeat_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Heartbeat_(struct soap *soap, const char *tag, int id, const struct __ns1__Heartbeat_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Heartbeat(soap, "ns1:Heartbeat", -1, &a->ns1__Heartbeat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Heartbeat_ * SOAP_FMAC4 soap_in___ns1__Heartbeat_(struct soap *soap, const char *tag, struct __ns1__Heartbeat_ *a, const char *type)
{
	size_t soap_flag_ns1__Heartbeat_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Heartbeat_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Heartbeat_, sizeof(struct __ns1__Heartbeat_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Heartbeat_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Heartbeat_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Heartbeat(soap, "ns1:Heartbeat", &a->ns1__Heartbeat_, ""))
				{	soap_flag_ns1__Heartbeat_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Heartbeat_ * SOAP_FMAC2 soap_instantiate___ns1__Heartbeat_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Heartbeat_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Heartbeat_ *p;
	size_t k = sizeof(struct __ns1__Heartbeat_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Heartbeat_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Heartbeat_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Heartbeat_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Heartbeat_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Heartbeat_(struct soap *soap, const struct __ns1__Heartbeat_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Heartbeat_(soap, tag ? tag : "-ns1:Heartbeat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Heartbeat_ * SOAP_FMAC4 soap_get___ns1__Heartbeat_(struct soap *soap, struct __ns1__Heartbeat_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Heartbeat_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Heartbeat(struct soap *soap, struct __ns1__Heartbeat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Heartbeat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Heartbeat(struct soap *soap, const struct __ns1__Heartbeat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Heartbeat(soap, &a->ns1__Heartbeat_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Heartbeat(struct soap *soap, const char *tag, int id, const struct __ns1__Heartbeat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Heartbeat(soap, "ns1:Heartbeat", -1, &a->ns1__Heartbeat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Heartbeat * SOAP_FMAC4 soap_in___ns1__Heartbeat(struct soap *soap, const char *tag, struct __ns1__Heartbeat *a, const char *type)
{
	size_t soap_flag_ns1__Heartbeat_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Heartbeat*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Heartbeat, sizeof(struct __ns1__Heartbeat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Heartbeat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Heartbeat_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Heartbeat(soap, "ns1:Heartbeat", &a->ns1__Heartbeat_, ""))
				{	soap_flag_ns1__Heartbeat_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Heartbeat * SOAP_FMAC2 soap_instantiate___ns1__Heartbeat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Heartbeat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Heartbeat *p;
	size_t k = sizeof(struct __ns1__Heartbeat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Heartbeat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Heartbeat);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Heartbeat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Heartbeat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Heartbeat(struct soap *soap, const struct __ns1__Heartbeat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Heartbeat(soap, tag ? tag : "-ns1:Heartbeat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Heartbeat * SOAP_FMAC4 soap_get___ns1__Heartbeat(struct soap *soap, struct __ns1__Heartbeat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Heartbeat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GenerateCellSFC_(struct soap *soap, struct __ns1__GenerateCellSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GenerateCellSFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GenerateCellSFC_(struct soap *soap, const struct __ns1__GenerateCellSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GenerateCellSFC(soap, &a->ns1__GenerateCellSFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GenerateCellSFC_(struct soap *soap, const char *tag, int id, const struct __ns1__GenerateCellSFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GenerateCellSFC(soap, "ns1:GenerateCellSFC", -1, &a->ns1__GenerateCellSFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GenerateCellSFC_ * SOAP_FMAC4 soap_in___ns1__GenerateCellSFC_(struct soap *soap, const char *tag, struct __ns1__GenerateCellSFC_ *a, const char *type)
{
	size_t soap_flag_ns1__GenerateCellSFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GenerateCellSFC_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GenerateCellSFC_, sizeof(struct __ns1__GenerateCellSFC_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GenerateCellSFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GenerateCellSFC_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GenerateCellSFC(soap, "ns1:GenerateCellSFC", &a->ns1__GenerateCellSFC_, ""))
				{	soap_flag_ns1__GenerateCellSFC_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GenerateCellSFC_ * SOAP_FMAC2 soap_instantiate___ns1__GenerateCellSFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GenerateCellSFC_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GenerateCellSFC_ *p;
	size_t k = sizeof(struct __ns1__GenerateCellSFC_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GenerateCellSFC_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GenerateCellSFC_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GenerateCellSFC_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GenerateCellSFC_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GenerateCellSFC_(struct soap *soap, const struct __ns1__GenerateCellSFC_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GenerateCellSFC_(soap, tag ? tag : "-ns1:GenerateCellSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GenerateCellSFC_ * SOAP_FMAC4 soap_get___ns1__GenerateCellSFC_(struct soap *soap, struct __ns1__GenerateCellSFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GenerateCellSFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GenerateCellSFC(struct soap *soap, struct __ns1__GenerateCellSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GenerateCellSFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GenerateCellSFC(struct soap *soap, const struct __ns1__GenerateCellSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GenerateCellSFC(soap, &a->ns1__GenerateCellSFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GenerateCellSFC(struct soap *soap, const char *tag, int id, const struct __ns1__GenerateCellSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GenerateCellSFC(soap, "ns1:GenerateCellSFC", -1, &a->ns1__GenerateCellSFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GenerateCellSFC * SOAP_FMAC4 soap_in___ns1__GenerateCellSFC(struct soap *soap, const char *tag, struct __ns1__GenerateCellSFC *a, const char *type)
{
	size_t soap_flag_ns1__GenerateCellSFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GenerateCellSFC*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GenerateCellSFC, sizeof(struct __ns1__GenerateCellSFC), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GenerateCellSFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GenerateCellSFC_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GenerateCellSFC(soap, "ns1:GenerateCellSFC", &a->ns1__GenerateCellSFC_, ""))
				{	soap_flag_ns1__GenerateCellSFC_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GenerateCellSFC * SOAP_FMAC2 soap_instantiate___ns1__GenerateCellSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GenerateCellSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GenerateCellSFC *p;
	size_t k = sizeof(struct __ns1__GenerateCellSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GenerateCellSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GenerateCellSFC);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GenerateCellSFC, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GenerateCellSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GenerateCellSFC(struct soap *soap, const struct __ns1__GenerateCellSFC *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GenerateCellSFC(soap, tag ? tag : "-ns1:GenerateCellSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GenerateCellSFC * SOAP_FMAC4 soap_get___ns1__GenerateCellSFC(struct soap *soap, struct __ns1__GenerateCellSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GenerateCellSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FillingData_(struct soap *soap, struct __ns1__FillingData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FillingData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FillingData_(struct soap *soap, const struct __ns1__FillingData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FillingData(soap, &a->ns1__FillingData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FillingData_(struct soap *soap, const char *tag, int id, const struct __ns1__FillingData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FillingData(soap, "ns1:FillingData", -1, &a->ns1__FillingData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FillingData_ * SOAP_FMAC4 soap_in___ns1__FillingData_(struct soap *soap, const char *tag, struct __ns1__FillingData_ *a, const char *type)
{
	size_t soap_flag_ns1__FillingData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FillingData_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FillingData_, sizeof(struct __ns1__FillingData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FillingData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FillingData_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FillingData(soap, "ns1:FillingData", &a->ns1__FillingData_, ""))
				{	soap_flag_ns1__FillingData_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FillingData_ * SOAP_FMAC2 soap_instantiate___ns1__FillingData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FillingData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FillingData_ *p;
	size_t k = sizeof(struct __ns1__FillingData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FillingData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FillingData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FillingData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FillingData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FillingData_(struct soap *soap, const struct __ns1__FillingData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FillingData_(soap, tag ? tag : "-ns1:FillingData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FillingData_ * SOAP_FMAC4 soap_get___ns1__FillingData_(struct soap *soap, struct __ns1__FillingData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FillingData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FillingData(struct soap *soap, struct __ns1__FillingData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FillingData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FillingData(struct soap *soap, const struct __ns1__FillingData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FillingData(soap, &a->ns1__FillingData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FillingData(struct soap *soap, const char *tag, int id, const struct __ns1__FillingData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FillingData(soap, "ns1:FillingData", -1, &a->ns1__FillingData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FillingData * SOAP_FMAC4 soap_in___ns1__FillingData(struct soap *soap, const char *tag, struct __ns1__FillingData *a, const char *type)
{
	size_t soap_flag_ns1__FillingData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FillingData*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FillingData, sizeof(struct __ns1__FillingData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FillingData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FillingData_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FillingData(soap, "ns1:FillingData", &a->ns1__FillingData_, ""))
				{	soap_flag_ns1__FillingData_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FillingData * SOAP_FMAC2 soap_instantiate___ns1__FillingData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FillingData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FillingData *p;
	size_t k = sizeof(struct __ns1__FillingData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FillingData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FillingData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FillingData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FillingData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FillingData(struct soap *soap, const struct __ns1__FillingData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FillingData(soap, tag ? tag : "-ns1:FillingData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FillingData * SOAP_FMAC4 soap_get___ns1__FillingData(struct soap *soap, struct __ns1__FillingData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FillingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FeedingDJInLaminating_(struct soap *soap, struct __ns1__FeedingDJInLaminating_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FeedingDJInLaminating = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FeedingDJInLaminating_(struct soap *soap, const struct __ns1__FeedingDJInLaminating_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FeedingDJInLaminating(soap, &a->ns1__FeedingDJInLaminating);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FeedingDJInLaminating_(struct soap *soap, const char *tag, int id, const struct __ns1__FeedingDJInLaminating_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FeedingDJInLaminating(soap, "ns1:FeedingDJInLaminating", -1, &a->ns1__FeedingDJInLaminating, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FeedingDJInLaminating_ * SOAP_FMAC4 soap_in___ns1__FeedingDJInLaminating_(struct soap *soap, const char *tag, struct __ns1__FeedingDJInLaminating_ *a, const char *type)
{
	size_t soap_flag_ns1__FeedingDJInLaminating = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FeedingDJInLaminating_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FeedingDJInLaminating_, sizeof(struct __ns1__FeedingDJInLaminating_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FeedingDJInLaminating_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FeedingDJInLaminating && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FeedingDJInLaminating(soap, "ns1:FeedingDJInLaminating", &a->ns1__FeedingDJInLaminating, ""))
				{	soap_flag_ns1__FeedingDJInLaminating--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FeedingDJInLaminating_ * SOAP_FMAC2 soap_instantiate___ns1__FeedingDJInLaminating_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FeedingDJInLaminating_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FeedingDJInLaminating_ *p;
	size_t k = sizeof(struct __ns1__FeedingDJInLaminating_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FeedingDJInLaminating_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FeedingDJInLaminating_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FeedingDJInLaminating_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FeedingDJInLaminating_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FeedingDJInLaminating_(struct soap *soap, const struct __ns1__FeedingDJInLaminating_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FeedingDJInLaminating_(soap, tag ? tag : "-ns1:FeedingDJInLaminating", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FeedingDJInLaminating_ * SOAP_FMAC4 soap_get___ns1__FeedingDJInLaminating_(struct soap *soap, struct __ns1__FeedingDJInLaminating_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FeedingDJInLaminating_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FeedingDJInLaminating(struct soap *soap, struct __ns1__FeedingDJInLaminating *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FeedingDJInLaminating = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FeedingDJInLaminating(struct soap *soap, const struct __ns1__FeedingDJInLaminating *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FeedingDJInLaminating(soap, &a->ns1__FeedingDJInLaminating);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, int id, const struct __ns1__FeedingDJInLaminating *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FeedingDJInLaminating(soap, "ns1:FeedingDJInLaminating", -1, &a->ns1__FeedingDJInLaminating, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FeedingDJInLaminating * SOAP_FMAC4 soap_in___ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, struct __ns1__FeedingDJInLaminating *a, const char *type)
{
	size_t soap_flag_ns1__FeedingDJInLaminating = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FeedingDJInLaminating*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FeedingDJInLaminating, sizeof(struct __ns1__FeedingDJInLaminating), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FeedingDJInLaminating(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FeedingDJInLaminating && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FeedingDJInLaminating(soap, "ns1:FeedingDJInLaminating", &a->ns1__FeedingDJInLaminating, ""))
				{	soap_flag_ns1__FeedingDJInLaminating--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FeedingDJInLaminating * SOAP_FMAC2 soap_instantiate___ns1__FeedingDJInLaminating(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FeedingDJInLaminating(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FeedingDJInLaminating *p;
	size_t k = sizeof(struct __ns1__FeedingDJInLaminating);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FeedingDJInLaminating, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FeedingDJInLaminating);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FeedingDJInLaminating, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FeedingDJInLaminating location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FeedingDJInLaminating(struct soap *soap, const struct __ns1__FeedingDJInLaminating *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FeedingDJInLaminating(soap, tag ? tag : "-ns1:FeedingDJInLaminating", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FeedingDJInLaminating * SOAP_FMAC4 soap_get___ns1__FeedingDJInLaminating(struct soap *soap, struct __ns1__FeedingDJInLaminating *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FeedingDJInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Feeding_(struct soap *soap, struct __ns1__Feeding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Feeding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Feeding_(struct soap *soap, const struct __ns1__Feeding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Feeding(soap, &a->ns1__Feeding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Feeding_(struct soap *soap, const char *tag, int id, const struct __ns1__Feeding_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Feeding(soap, "ns1:Feeding", -1, &a->ns1__Feeding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Feeding_ * SOAP_FMAC4 soap_in___ns1__Feeding_(struct soap *soap, const char *tag, struct __ns1__Feeding_ *a, const char *type)
{
	size_t soap_flag_ns1__Feeding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Feeding_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Feeding_, sizeof(struct __ns1__Feeding_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Feeding_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Feeding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Feeding(soap, "ns1:Feeding", &a->ns1__Feeding, ""))
				{	soap_flag_ns1__Feeding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Feeding_ * SOAP_FMAC2 soap_instantiate___ns1__Feeding_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Feeding_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Feeding_ *p;
	size_t k = sizeof(struct __ns1__Feeding_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Feeding_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Feeding_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Feeding_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Feeding_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Feeding_(struct soap *soap, const struct __ns1__Feeding_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Feeding_(soap, tag ? tag : "-ns1:Feeding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Feeding_ * SOAP_FMAC4 soap_get___ns1__Feeding_(struct soap *soap, struct __ns1__Feeding_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Feeding_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Feeding(struct soap *soap, struct __ns1__Feeding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Feeding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Feeding(struct soap *soap, const struct __ns1__Feeding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Feeding(soap, &a->ns1__Feeding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Feeding(struct soap *soap, const char *tag, int id, const struct __ns1__Feeding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Feeding(soap, "ns1:Feeding", -1, &a->ns1__Feeding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Feeding * SOAP_FMAC4 soap_in___ns1__Feeding(struct soap *soap, const char *tag, struct __ns1__Feeding *a, const char *type)
{
	size_t soap_flag_ns1__Feeding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Feeding*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Feeding, sizeof(struct __ns1__Feeding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Feeding(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Feeding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Feeding(soap, "ns1:Feeding", &a->ns1__Feeding, ""))
				{	soap_flag_ns1__Feeding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Feeding * SOAP_FMAC2 soap_instantiate___ns1__Feeding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Feeding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Feeding *p;
	size_t k = sizeof(struct __ns1__Feeding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Feeding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Feeding);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Feeding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Feeding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Feeding(struct soap *soap, const struct __ns1__Feeding *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Feeding(soap, tag ? tag : "-ns1:Feeding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Feeding * SOAP_FMAC4 soap_get___ns1__Feeding(struct soap *soap, struct __ns1__Feeding *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Feeding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExamineExists_(struct soap *soap, struct __ns1__ExamineExists_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExamineExists = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExamineExists_(struct soap *soap, const struct __ns1__ExamineExists_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExamineExists(soap, &a->ns1__ExamineExists);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExamineExists_(struct soap *soap, const char *tag, int id, const struct __ns1__ExamineExists_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExamineExists(soap, "ns1:ExamineExists", -1, &a->ns1__ExamineExists, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExamineExists_ * SOAP_FMAC4 soap_in___ns1__ExamineExists_(struct soap *soap, const char *tag, struct __ns1__ExamineExists_ *a, const char *type)
{
	size_t soap_flag_ns1__ExamineExists = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExamineExists_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExamineExists_, sizeof(struct __ns1__ExamineExists_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExamineExists_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExamineExists && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExamineExists(soap, "ns1:ExamineExists", &a->ns1__ExamineExists, ""))
				{	soap_flag_ns1__ExamineExists--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExamineExists_ * SOAP_FMAC2 soap_instantiate___ns1__ExamineExists_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExamineExists_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExamineExists_ *p;
	size_t k = sizeof(struct __ns1__ExamineExists_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExamineExists_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExamineExists_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExamineExists_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExamineExists_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExamineExists_(struct soap *soap, const struct __ns1__ExamineExists_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExamineExists_(soap, tag ? tag : "-ns1:ExamineExists", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExamineExists_ * SOAP_FMAC4 soap_get___ns1__ExamineExists_(struct soap *soap, struct __ns1__ExamineExists_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExamineExists_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExamineExists(struct soap *soap, struct __ns1__ExamineExists *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExamineExists = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExamineExists(struct soap *soap, const struct __ns1__ExamineExists *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExamineExists(soap, &a->ns1__ExamineExists);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExamineExists(struct soap *soap, const char *tag, int id, const struct __ns1__ExamineExists *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExamineExists(soap, "ns1:ExamineExists", -1, &a->ns1__ExamineExists, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExamineExists * SOAP_FMAC4 soap_in___ns1__ExamineExists(struct soap *soap, const char *tag, struct __ns1__ExamineExists *a, const char *type)
{
	size_t soap_flag_ns1__ExamineExists = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExamineExists*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExamineExists, sizeof(struct __ns1__ExamineExists), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExamineExists(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExamineExists && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExamineExists(soap, "ns1:ExamineExists", &a->ns1__ExamineExists, ""))
				{	soap_flag_ns1__ExamineExists--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExamineExists * SOAP_FMAC2 soap_instantiate___ns1__ExamineExists(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExamineExists(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExamineExists *p;
	size_t k = sizeof(struct __ns1__ExamineExists);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExamineExists, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExamineExists);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExamineExists, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExamineExists location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExamineExists(struct soap *soap, const struct __ns1__ExamineExists *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExamineExists(soap, tag ? tag : "-ns1:ExamineExists", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExamineExists * SOAP_FMAC4 soap_get___ns1__ExamineExists(struct soap *soap, struct __ns1__ExamineExists *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExamineExists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EquipmentProductProcessParam_(struct soap *soap, struct __ns1__EquipmentProductProcessParam_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EquipmentProductProcessParam_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EquipmentProductProcessParam_(struct soap *soap, const struct __ns1__EquipmentProductProcessParam_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EquipmentProductProcessParam(soap, &a->ns1__EquipmentProductProcessParam_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EquipmentProductProcessParam_(struct soap *soap, const char *tag, int id, const struct __ns1__EquipmentProductProcessParam_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EquipmentProductProcessParam(soap, "ns1:EquipmentProductProcessParam", -1, &a->ns1__EquipmentProductProcessParam_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProductProcessParam_ * SOAP_FMAC4 soap_in___ns1__EquipmentProductProcessParam_(struct soap *soap, const char *tag, struct __ns1__EquipmentProductProcessParam_ *a, const char *type)
{
	size_t soap_flag_ns1__EquipmentProductProcessParam_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EquipmentProductProcessParam_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EquipmentProductProcessParam_, sizeof(struct __ns1__EquipmentProductProcessParam_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EquipmentProductProcessParam_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EquipmentProductProcessParam_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EquipmentProductProcessParam(soap, "ns1:EquipmentProductProcessParam", &a->ns1__EquipmentProductProcessParam_, ""))
				{	soap_flag_ns1__EquipmentProductProcessParam_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EquipmentProductProcessParam_ * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProductProcessParam_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EquipmentProductProcessParam_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EquipmentProductProcessParam_ *p;
	size_t k = sizeof(struct __ns1__EquipmentProductProcessParam_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__EquipmentProductProcessParam_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EquipmentProductProcessParam_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EquipmentProductProcessParam_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EquipmentProductProcessParam_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EquipmentProductProcessParam_(struct soap *soap, const struct __ns1__EquipmentProductProcessParam_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EquipmentProductProcessParam_(soap, tag ? tag : "-ns1:EquipmentProductProcessParam", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProductProcessParam_ * SOAP_FMAC4 soap_get___ns1__EquipmentProductProcessParam_(struct soap *soap, struct __ns1__EquipmentProductProcessParam_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EquipmentProductProcessParam_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EquipmentProductProcessParam(struct soap *soap, struct __ns1__EquipmentProductProcessParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EquipmentProductProcessParam_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EquipmentProductProcessParam(struct soap *soap, const struct __ns1__EquipmentProductProcessParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EquipmentProductProcessParam(soap, &a->ns1__EquipmentProductProcessParam_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, int id, const struct __ns1__EquipmentProductProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EquipmentProductProcessParam(soap, "ns1:EquipmentProductProcessParam", -1, &a->ns1__EquipmentProductProcessParam_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_in___ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, struct __ns1__EquipmentProductProcessParam *a, const char *type)
{
	size_t soap_flag_ns1__EquipmentProductProcessParam_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EquipmentProductProcessParam*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EquipmentProductProcessParam, sizeof(struct __ns1__EquipmentProductProcessParam), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EquipmentProductProcessParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EquipmentProductProcessParam_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EquipmentProductProcessParam(soap, "ns1:EquipmentProductProcessParam", &a->ns1__EquipmentProductProcessParam_, ""))
				{	soap_flag_ns1__EquipmentProductProcessParam_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EquipmentProductProcessParam * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProductProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EquipmentProductProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EquipmentProductProcessParam *p;
	size_t k = sizeof(struct __ns1__EquipmentProductProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__EquipmentProductProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EquipmentProductProcessParam);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EquipmentProductProcessParam, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EquipmentProductProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EquipmentProductProcessParam(struct soap *soap, const struct __ns1__EquipmentProductProcessParam *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EquipmentProductProcessParam(soap, tag ? tag : "-ns1:EquipmentProductProcessParam", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProductProcessParam * SOAP_FMAC4 soap_get___ns1__EquipmentProductProcessParam(struct soap *soap, struct __ns1__EquipmentProductProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EquipmentProductProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EquipmentProcessParam_(struct soap *soap, struct __ns1__EquipmentProcessParam_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EquipmentProcessParam_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EquipmentProcessParam_(struct soap *soap, const struct __ns1__EquipmentProcessParam_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EquipmentProcessParam(soap, &a->ns1__EquipmentProcessParam_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EquipmentProcessParam_(struct soap *soap, const char *tag, int id, const struct __ns1__EquipmentProcessParam_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EquipmentProcessParam(soap, "ns1:EquipmentProcessParam", -1, &a->ns1__EquipmentProcessParam_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProcessParam_ * SOAP_FMAC4 soap_in___ns1__EquipmentProcessParam_(struct soap *soap, const char *tag, struct __ns1__EquipmentProcessParam_ *a, const char *type)
{
	size_t soap_flag_ns1__EquipmentProcessParam_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EquipmentProcessParam_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EquipmentProcessParam_, sizeof(struct __ns1__EquipmentProcessParam_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EquipmentProcessParam_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EquipmentProcessParam_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EquipmentProcessParam(soap, "ns1:EquipmentProcessParam", &a->ns1__EquipmentProcessParam_, ""))
				{	soap_flag_ns1__EquipmentProcessParam_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EquipmentProcessParam_ * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProcessParam_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EquipmentProcessParam_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EquipmentProcessParam_ *p;
	size_t k = sizeof(struct __ns1__EquipmentProcessParam_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__EquipmentProcessParam_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EquipmentProcessParam_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EquipmentProcessParam_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EquipmentProcessParam_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EquipmentProcessParam_(struct soap *soap, const struct __ns1__EquipmentProcessParam_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EquipmentProcessParam_(soap, tag ? tag : "-ns1:EquipmentProcessParam", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProcessParam_ * SOAP_FMAC4 soap_get___ns1__EquipmentProcessParam_(struct soap *soap, struct __ns1__EquipmentProcessParam_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EquipmentProcessParam_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EquipmentProcessParam(struct soap *soap, struct __ns1__EquipmentProcessParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EquipmentProcessParam_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EquipmentProcessParam(struct soap *soap, const struct __ns1__EquipmentProcessParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EquipmentProcessParam(soap, &a->ns1__EquipmentProcessParam_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EquipmentProcessParam(struct soap *soap, const char *tag, int id, const struct __ns1__EquipmentProcessParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EquipmentProcessParam(soap, "ns1:EquipmentProcessParam", -1, &a->ns1__EquipmentProcessParam_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProcessParam * SOAP_FMAC4 soap_in___ns1__EquipmentProcessParam(struct soap *soap, const char *tag, struct __ns1__EquipmentProcessParam *a, const char *type)
{
	size_t soap_flag_ns1__EquipmentProcessParam_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EquipmentProcessParam*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EquipmentProcessParam, sizeof(struct __ns1__EquipmentProcessParam), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EquipmentProcessParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EquipmentProcessParam_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EquipmentProcessParam(soap, "ns1:EquipmentProcessParam", &a->ns1__EquipmentProcessParam_, ""))
				{	soap_flag_ns1__EquipmentProcessParam_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EquipmentProcessParam * SOAP_FMAC2 soap_instantiate___ns1__EquipmentProcessParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EquipmentProcessParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EquipmentProcessParam *p;
	size_t k = sizeof(struct __ns1__EquipmentProcessParam);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__EquipmentProcessParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EquipmentProcessParam);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EquipmentProcessParam, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EquipmentProcessParam location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EquipmentProcessParam(struct soap *soap, const struct __ns1__EquipmentProcessParam *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EquipmentProcessParam(soap, tag ? tag : "-ns1:EquipmentProcessParam", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EquipmentProcessParam * SOAP_FMAC4 soap_get___ns1__EquipmentProcessParam(struct soap *soap, struct __ns1__EquipmentProcessParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EquipmentProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownReason_(struct soap *soap, struct __ns1__DownReason_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownReason_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownReason_(struct soap *soap, const struct __ns1__DownReason_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownReason(soap, &a->ns1__DownReason_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownReason_(struct soap *soap, const char *tag, int id, const struct __ns1__DownReason_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownReason(soap, "ns1:DownReason", -1, &a->ns1__DownReason_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownReason_ * SOAP_FMAC4 soap_in___ns1__DownReason_(struct soap *soap, const char *tag, struct __ns1__DownReason_ *a, const char *type)
{
	size_t soap_flag_ns1__DownReason_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownReason_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownReason_, sizeof(struct __ns1__DownReason_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownReason_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownReason_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownReason(soap, "ns1:DownReason", &a->ns1__DownReason_, ""))
				{	soap_flag_ns1__DownReason_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownReason_ * SOAP_FMAC2 soap_instantiate___ns1__DownReason_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownReason_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownReason_ *p;
	size_t k = sizeof(struct __ns1__DownReason_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownReason_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownReason_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownReason_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownReason_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownReason_(struct soap *soap, const struct __ns1__DownReason_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownReason_(soap, tag ? tag : "-ns1:DownReason", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownReason_ * SOAP_FMAC4 soap_get___ns1__DownReason_(struct soap *soap, struct __ns1__DownReason_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownReason_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownReason(struct soap *soap, struct __ns1__DownReason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownReason_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownReason(struct soap *soap, const struct __ns1__DownReason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownReason(soap, &a->ns1__DownReason_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownReason(struct soap *soap, const char *tag, int id, const struct __ns1__DownReason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownReason(soap, "ns1:DownReason", -1, &a->ns1__DownReason_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownReason * SOAP_FMAC4 soap_in___ns1__DownReason(struct soap *soap, const char *tag, struct __ns1__DownReason *a, const char *type)
{
	size_t soap_flag_ns1__DownReason_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownReason*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownReason, sizeof(struct __ns1__DownReason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownReason(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownReason_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownReason(soap, "ns1:DownReason", &a->ns1__DownReason_, ""))
				{	soap_flag_ns1__DownReason_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownReason * SOAP_FMAC2 soap_instantiate___ns1__DownReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownReason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownReason *p;
	size_t k = sizeof(struct __ns1__DownReason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownReason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownReason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownReason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownReason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownReason(struct soap *soap, const struct __ns1__DownReason *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownReason(soap, tag ? tag : "-ns1:DownReason", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownReason * SOAP_FMAC4 soap_get___ns1__DownReason(struct soap *soap, struct __ns1__DownReason *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CCDFileUploadComplete_(struct soap *soap, struct __ns1__CCDFileUploadComplete_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CCDFileUploadComplete_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CCDFileUploadComplete_(struct soap *soap, const struct __ns1__CCDFileUploadComplete_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CCDFileUploadComplete(soap, &a->ns1__CCDFileUploadComplete_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CCDFileUploadComplete_(struct soap *soap, const char *tag, int id, const struct __ns1__CCDFileUploadComplete_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CCDFileUploadComplete(soap, "ns1:CCDFileUploadComplete", -1, &a->ns1__CCDFileUploadComplete_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCDFileUploadComplete_ * SOAP_FMAC4 soap_in___ns1__CCDFileUploadComplete_(struct soap *soap, const char *tag, struct __ns1__CCDFileUploadComplete_ *a, const char *type)
{
	size_t soap_flag_ns1__CCDFileUploadComplete_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CCDFileUploadComplete_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CCDFileUploadComplete_, sizeof(struct __ns1__CCDFileUploadComplete_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CCDFileUploadComplete_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CCDFileUploadComplete_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CCDFileUploadComplete(soap, "ns1:CCDFileUploadComplete", &a->ns1__CCDFileUploadComplete_, ""))
				{	soap_flag_ns1__CCDFileUploadComplete_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CCDFileUploadComplete_ * SOAP_FMAC2 soap_instantiate___ns1__CCDFileUploadComplete_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CCDFileUploadComplete_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CCDFileUploadComplete_ *p;
	size_t k = sizeof(struct __ns1__CCDFileUploadComplete_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CCDFileUploadComplete_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CCDFileUploadComplete_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CCDFileUploadComplete_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CCDFileUploadComplete_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CCDFileUploadComplete_(struct soap *soap, const struct __ns1__CCDFileUploadComplete_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CCDFileUploadComplete_(soap, tag ? tag : "-ns1:CCDFileUploadComplete", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCDFileUploadComplete_ * SOAP_FMAC4 soap_get___ns1__CCDFileUploadComplete_(struct soap *soap, struct __ns1__CCDFileUploadComplete_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CCDFileUploadComplete_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CCDFileUploadComplete(struct soap *soap, struct __ns1__CCDFileUploadComplete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CCDFileUploadComplete_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CCDFileUploadComplete(struct soap *soap, const struct __ns1__CCDFileUploadComplete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CCDFileUploadComplete(soap, &a->ns1__CCDFileUploadComplete_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, int id, const struct __ns1__CCDFileUploadComplete *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CCDFileUploadComplete(soap, "ns1:CCDFileUploadComplete", -1, &a->ns1__CCDFileUploadComplete_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_in___ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, struct __ns1__CCDFileUploadComplete *a, const char *type)
{
	size_t soap_flag_ns1__CCDFileUploadComplete_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CCDFileUploadComplete*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CCDFileUploadComplete, sizeof(struct __ns1__CCDFileUploadComplete), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CCDFileUploadComplete(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CCDFileUploadComplete_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CCDFileUploadComplete(soap, "ns1:CCDFileUploadComplete", &a->ns1__CCDFileUploadComplete_, ""))
				{	soap_flag_ns1__CCDFileUploadComplete_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CCDFileUploadComplete * SOAP_FMAC2 soap_instantiate___ns1__CCDFileUploadComplete(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CCDFileUploadComplete(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CCDFileUploadComplete *p;
	size_t k = sizeof(struct __ns1__CCDFileUploadComplete);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CCDFileUploadComplete, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CCDFileUploadComplete);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CCDFileUploadComplete, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CCDFileUploadComplete location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CCDFileUploadComplete(struct soap *soap, const struct __ns1__CCDFileUploadComplete *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CCDFileUploadComplete(soap, tag ? tag : "-ns1:CCDFileUploadComplete", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCDFileUploadComplete * SOAP_FMAC4 soap_get___ns1__CCDFileUploadComplete(struct soap *soap, struct __ns1__CCDFileUploadComplete *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CCDFileUploadComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindSFC_(struct soap *soap, struct __ns1__BindSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindSFC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindSFC_(struct soap *soap, const struct __ns1__BindSFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindSFC(soap, &a->ns1__BindSFC);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindSFC_(struct soap *soap, const char *tag, int id, const struct __ns1__BindSFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindSFC(soap, "ns1:BindSFC", -1, &a->ns1__BindSFC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindSFC_ * SOAP_FMAC4 soap_in___ns1__BindSFC_(struct soap *soap, const char *tag, struct __ns1__BindSFC_ *a, const char *type)
{
	size_t soap_flag_ns1__BindSFC = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindSFC_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindSFC_, sizeof(struct __ns1__BindSFC_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindSFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindSFC && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindSFC(soap, "ns1:BindSFC", &a->ns1__BindSFC, ""))
				{	soap_flag_ns1__BindSFC--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindSFC_ * SOAP_FMAC2 soap_instantiate___ns1__BindSFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindSFC_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindSFC_ *p;
	size_t k = sizeof(struct __ns1__BindSFC_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindSFC_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindSFC_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindSFC_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindSFC_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindSFC_(struct soap *soap, const struct __ns1__BindSFC_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindSFC_(soap, tag ? tag : "-ns1:BindSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindSFC_ * SOAP_FMAC4 soap_get___ns1__BindSFC_(struct soap *soap, struct __ns1__BindSFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindSFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindSFC(struct soap *soap, struct __ns1__BindSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindSFC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindSFC(struct soap *soap, const struct __ns1__BindSFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindSFC(soap, &a->ns1__BindSFC);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindSFC(struct soap *soap, const char *tag, int id, const struct __ns1__BindSFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindSFC(soap, "ns1:BindSFC", -1, &a->ns1__BindSFC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindSFC * SOAP_FMAC4 soap_in___ns1__BindSFC(struct soap *soap, const char *tag, struct __ns1__BindSFC *a, const char *type)
{
	size_t soap_flag_ns1__BindSFC = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindSFC*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindSFC, sizeof(struct __ns1__BindSFC), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindSFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindSFC && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindSFC(soap, "ns1:BindSFC", &a->ns1__BindSFC, ""))
				{	soap_flag_ns1__BindSFC--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindSFC * SOAP_FMAC2 soap_instantiate___ns1__BindSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindSFC *p;
	size_t k = sizeof(struct __ns1__BindSFC);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindSFC);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindSFC, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindSFC location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindSFC(struct soap *soap, const struct __ns1__BindSFC *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindSFC(soap, tag ? tag : "-ns1:BindSFC", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindSFC * SOAP_FMAC4 soap_get___ns1__BindSFC(struct soap *soap, struct __ns1__BindSFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindContainer_(struct soap *soap, struct __ns1__BindContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindContainer_(struct soap *soap, const struct __ns1__BindContainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindContainer(soap, &a->ns1__BindContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindContainer_(struct soap *soap, const char *tag, int id, const struct __ns1__BindContainer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindContainer(soap, "ns1:BindContainer", -1, &a->ns1__BindContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindContainer_ * SOAP_FMAC4 soap_in___ns1__BindContainer_(struct soap *soap, const char *tag, struct __ns1__BindContainer_ *a, const char *type)
{
	size_t soap_flag_ns1__BindContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindContainer_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindContainer_, sizeof(struct __ns1__BindContainer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindContainer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindContainer(soap, "ns1:BindContainer", &a->ns1__BindContainer_, ""))
				{	soap_flag_ns1__BindContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindContainer_ * SOAP_FMAC2 soap_instantiate___ns1__BindContainer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindContainer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindContainer_ *p;
	size_t k = sizeof(struct __ns1__BindContainer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindContainer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindContainer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindContainer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindContainer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindContainer_(struct soap *soap, const struct __ns1__BindContainer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindContainer_(soap, tag ? tag : "-ns1:BindContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindContainer_ * SOAP_FMAC4 soap_get___ns1__BindContainer_(struct soap *soap, struct __ns1__BindContainer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindContainer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindContainer(struct soap *soap, struct __ns1__BindContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindContainer_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindContainer(struct soap *soap, const struct __ns1__BindContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindContainer(soap, &a->ns1__BindContainer_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindContainer(struct soap *soap, const char *tag, int id, const struct __ns1__BindContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindContainer(soap, "ns1:BindContainer", -1, &a->ns1__BindContainer_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindContainer * SOAP_FMAC4 soap_in___ns1__BindContainer(struct soap *soap, const char *tag, struct __ns1__BindContainer *a, const char *type)
{
	size_t soap_flag_ns1__BindContainer_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindContainer*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindContainer, sizeof(struct __ns1__BindContainer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindContainer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindContainer_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindContainer(soap, "ns1:BindContainer", &a->ns1__BindContainer_, ""))
				{	soap_flag_ns1__BindContainer_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindContainer * SOAP_FMAC2 soap_instantiate___ns1__BindContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindContainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindContainer *p;
	size_t k = sizeof(struct __ns1__BindContainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindContainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindContainer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindContainer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindContainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindContainer(struct soap *soap, const struct __ns1__BindContainer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindContainer(soap, tag ? tag : "-ns1:BindContainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindContainer * SOAP_FMAC4 soap_get___ns1__BindContainer(struct soap *soap, struct __ns1__BindContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Alarm_(struct soap *soap, struct __ns1__Alarm_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Alarm_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Alarm_(struct soap *soap, const struct __ns1__Alarm_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Alarm(soap, &a->ns1__Alarm_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Alarm_(struct soap *soap, const char *tag, int id, const struct __ns1__Alarm_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Alarm(soap, "ns1:Alarm", -1, &a->ns1__Alarm_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarm_ * SOAP_FMAC4 soap_in___ns1__Alarm_(struct soap *soap, const char *tag, struct __ns1__Alarm_ *a, const char *type)
{
	size_t soap_flag_ns1__Alarm_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Alarm_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Alarm_, sizeof(struct __ns1__Alarm_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Alarm_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Alarm_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Alarm(soap, "ns1:Alarm", &a->ns1__Alarm_, ""))
				{	soap_flag_ns1__Alarm_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Alarm_ * SOAP_FMAC2 soap_instantiate___ns1__Alarm_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Alarm_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Alarm_ *p;
	size_t k = sizeof(struct __ns1__Alarm_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Alarm_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Alarm_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Alarm_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Alarm_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Alarm_(struct soap *soap, const struct __ns1__Alarm_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Alarm_(soap, tag ? tag : "-ns1:Alarm", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarm_ * SOAP_FMAC4 soap_get___ns1__Alarm_(struct soap *soap, struct __ns1__Alarm_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Alarm_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Alarm(struct soap *soap, struct __ns1__Alarm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Alarm_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Alarm(struct soap *soap, const struct __ns1__Alarm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Alarm(soap, &a->ns1__Alarm_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Alarm(struct soap *soap, const char *tag, int id, const struct __ns1__Alarm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Alarm(soap, "ns1:Alarm", -1, &a->ns1__Alarm_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarm * SOAP_FMAC4 soap_in___ns1__Alarm(struct soap *soap, const char *tag, struct __ns1__Alarm *a, const char *type)
{
	size_t soap_flag_ns1__Alarm_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Alarm*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Alarm, sizeof(struct __ns1__Alarm), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Alarm(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Alarm_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Alarm(soap, "ns1:Alarm", &a->ns1__Alarm_, ""))
				{	soap_flag_ns1__Alarm_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Alarm * SOAP_FMAC2 soap_instantiate___ns1__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Alarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Alarm *p;
	size_t k = sizeof(struct __ns1__Alarm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Alarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Alarm);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Alarm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Alarm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Alarm(struct soap *soap, const struct __ns1__Alarm *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Alarm(soap, tag ? tag : "-ns1:Alarm", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarm * SOAP_FMAC4 soap_get___ns1__Alarm(struct soap *soap, struct __ns1__Alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginSoapHeader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginSoapHeader(soap, &a->ns1__LoginSoapHeader_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__LoginSoapHeader(soap, "ns1:LoginSoapHeader", -1, &a->ns1__LoginSoapHeader_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__LoginSoapHeader_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginSoapHeader_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginSoapHeader(soap, "ns1:LoginSoapHeader", &a->ns1__LoginSoapHeader_, "ns1:LoginSoapHeader"))
				{	soap_flag_ns1__LoginSoapHeader_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UnBindSFC(struct soap *soap, _ns1__UnBindSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UnBindSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UnBindSFC(struct soap *soap, const char *tag, int id, _ns1__UnBindSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UnBindSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UnBindSFC ? type : NULL);
}

SOAP_FMAC3 _ns1__UnBindSFC ** SOAP_FMAC4 soap_in_PointerTo_ns1__UnBindSFC(struct soap *soap, const char *tag, _ns1__UnBindSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UnBindSFC **)soap_malloc(soap, sizeof(_ns1__UnBindSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UnBindSFC *)soap_instantiate__ns1__UnBindSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UnBindSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UnBindSFC, sizeof(_ns1__UnBindSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UnBindSFC(struct soap *soap, _ns1__UnBindSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UnBindSFC(soap, tag ? tag : "ns1:UnBindSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UnBindSFC ** SOAP_FMAC4 soap_get_PointerTo_ns1__UnBindSFC(struct soap *soap, _ns1__UnBindSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UnBindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ToolLife(struct soap *soap, _ns1__ToolLife *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ToolLife))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ToolLife(struct soap *soap, const char *tag, int id, _ns1__ToolLife *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ToolLife, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ToolLife ? type : NULL);
}

SOAP_FMAC3 _ns1__ToolLife ** SOAP_FMAC4 soap_in_PointerTo_ns1__ToolLife(struct soap *soap, const char *tag, _ns1__ToolLife **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ToolLife **)soap_malloc(soap, sizeof(_ns1__ToolLife *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ToolLife *)soap_instantiate__ns1__ToolLife(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ToolLife **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ToolLife, sizeof(_ns1__ToolLife), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ToolLife(struct soap *soap, _ns1__ToolLife *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ToolLife(soap, tag ? tag : "ns1:ToolLife", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ToolLife ** SOAP_FMAC4 soap_get_PointerTo_ns1__ToolLife(struct soap *soap, _ns1__ToolLife **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ToolLife(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ToolBind(struct soap *soap, _ns1__ToolBind *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ToolBind))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ToolBind(struct soap *soap, const char *tag, int id, _ns1__ToolBind *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ToolBind, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ToolBind ? type : NULL);
}

SOAP_FMAC3 _ns1__ToolBind ** SOAP_FMAC4 soap_in_PointerTo_ns1__ToolBind(struct soap *soap, const char *tag, _ns1__ToolBind **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ToolBind **)soap_malloc(soap, sizeof(_ns1__ToolBind *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ToolBind *)soap_instantiate__ns1__ToolBind(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ToolBind **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ToolBind, sizeof(_ns1__ToolBind), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ToolBind(struct soap *soap, _ns1__ToolBind *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ToolBind(soap, tag ? tag : "ns1:ToolBind", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ToolBind ** SOAP_FMAC4 soap_get_PointerTo_ns1__ToolBind(struct soap *soap, _ns1__ToolBind **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ToolBind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__State(struct soap *soap, _ns1__State *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__State))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__State(struct soap *soap, const char *tag, int id, _ns1__State *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__State, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__State ? type : NULL);
}

SOAP_FMAC3 _ns1__State ** SOAP_FMAC4 soap_in_PointerTo_ns1__State(struct soap *soap, const char *tag, _ns1__State **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__State **)soap_malloc(soap, sizeof(_ns1__State *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__State *)soap_instantiate__ns1__State(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__State **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__State, sizeof(_ns1__State), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__State(struct soap *soap, _ns1__State *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__State(soap, tag ? tag : "ns1:State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__State ** SOAP_FMAC4 soap_get_PointerTo_ns1__State(struct soap *soap, _ns1__State **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RecipeVersionExamine(struct soap *soap, _ns1__RecipeVersionExamine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RecipeVersionExamine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RecipeVersionExamine(struct soap *soap, const char *tag, int id, _ns1__RecipeVersionExamine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RecipeVersionExamine, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__RecipeVersionExamine ? type : NULL);
}

SOAP_FMAC3 _ns1__RecipeVersionExamine ** SOAP_FMAC4 soap_in_PointerTo_ns1__RecipeVersionExamine(struct soap *soap, const char *tag, _ns1__RecipeVersionExamine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RecipeVersionExamine **)soap_malloc(soap, sizeof(_ns1__RecipeVersionExamine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RecipeVersionExamine *)soap_instantiate__ns1__RecipeVersionExamine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RecipeVersionExamine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RecipeVersionExamine, sizeof(_ns1__RecipeVersionExamine), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RecipeVersionExamine(struct soap *soap, _ns1__RecipeVersionExamine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RecipeVersionExamine(soap, tag ? tag : "ns1:RecipeVersionExamine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RecipeVersionExamine ** SOAP_FMAC4 soap_get_PointerTo_ns1__RecipeVersionExamine(struct soap *soap, _ns1__RecipeVersionExamine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RecipeVersionExamine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRecipeList(struct soap *soap, _ns1__GetRecipeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRecipeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRecipeList(struct soap *soap, const char *tag, int id, _ns1__GetRecipeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRecipeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetRecipeList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetRecipeList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRecipeList(struct soap *soap, const char *tag, _ns1__GetRecipeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRecipeList **)soap_malloc(soap, sizeof(_ns1__GetRecipeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRecipeList *)soap_instantiate__ns1__GetRecipeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetRecipeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRecipeList, sizeof(_ns1__GetRecipeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRecipeList(struct soap *soap, _ns1__GetRecipeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRecipeList(soap, tag ? tag : "ns1:GetRecipeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRecipeList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRecipeList(struct soap *soap, _ns1__GetRecipeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRecipeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRecipe(struct soap *soap, _ns1__GetRecipe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRecipe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRecipe(struct soap *soap, const char *tag, int id, _ns1__GetRecipe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRecipe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetRecipe ? type : NULL);
}

SOAP_FMAC3 _ns1__GetRecipe ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRecipe(struct soap *soap, const char *tag, _ns1__GetRecipe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRecipe **)soap_malloc(soap, sizeof(_ns1__GetRecipe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRecipe *)soap_instantiate__ns1__GetRecipe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetRecipe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRecipe, sizeof(_ns1__GetRecipe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRecipe(struct soap *soap, _ns1__GetRecipe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRecipe(soap, tag ? tag : "ns1:GetRecipe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRecipe ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRecipe(struct soap *soap, _ns1__GetRecipe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRecipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Recipe(struct soap *soap, _ns1__Recipe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Recipe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Recipe(struct soap *soap, const char *tag, int id, _ns1__Recipe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Recipe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Recipe ? type : NULL);
}

SOAP_FMAC3 _ns1__Recipe ** SOAP_FMAC4 soap_in_PointerTo_ns1__Recipe(struct soap *soap, const char *tag, _ns1__Recipe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Recipe **)soap_malloc(soap, sizeof(_ns1__Recipe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Recipe *)soap_instantiate__ns1__Recipe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Recipe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Recipe, sizeof(_ns1__Recipe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Recipe(struct soap *soap, _ns1__Recipe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Recipe(soap, tag ? tag : "ns1:Recipe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Recipe ** SOAP_FMAC4 soap_get_PointerTo_ns1__Recipe(struct soap *soap, _ns1__Recipe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Recipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OutboundMore(struct soap *soap, _ns1__OutboundMore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OutboundMore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OutboundMore(struct soap *soap, const char *tag, int id, _ns1__OutboundMore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OutboundMore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OutboundMore ? type : NULL);
}

SOAP_FMAC3 _ns1__OutboundMore ** SOAP_FMAC4 soap_in_PointerTo_ns1__OutboundMore(struct soap *soap, const char *tag, _ns1__OutboundMore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OutboundMore **)soap_malloc(soap, sizeof(_ns1__OutboundMore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OutboundMore *)soap_instantiate__ns1__OutboundMore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OutboundMore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OutboundMore, sizeof(_ns1__OutboundMore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OutboundMore(struct soap *soap, _ns1__OutboundMore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OutboundMore(soap, tag ? tag : "ns1:OutboundMore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OutboundMore ** SOAP_FMAC4 soap_get_PointerTo_ns1__OutboundMore(struct soap *soap, _ns1__OutboundMore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OutboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OutboundInSFCOutputQty(struct soap *soap, _ns1__OutboundInSFCOutputQty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OutboundInSFCOutputQty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, int id, _ns1__OutboundInSFCOutputQty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OutboundInSFCOutputQty, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OutboundInSFCOutputQty ? type : NULL);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQty ** SOAP_FMAC4 soap_in_PointerTo_ns1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, _ns1__OutboundInSFCOutputQty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OutboundInSFCOutputQty **)soap_malloc(soap, sizeof(_ns1__OutboundInSFCOutputQty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OutboundInSFCOutputQty *)soap_instantiate__ns1__OutboundInSFCOutputQty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OutboundInSFCOutputQty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OutboundInSFCOutputQty, sizeof(_ns1__OutboundInSFCOutputQty), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OutboundInSFCOutputQty(struct soap *soap, _ns1__OutboundInSFCOutputQty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OutboundInSFCOutputQty(soap, tag ? tag : "ns1:OutboundInSFCOutputQty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OutboundInSFCOutputQty ** SOAP_FMAC4 soap_get_PointerTo_ns1__OutboundInSFCOutputQty(struct soap *soap, _ns1__OutboundInSFCOutputQty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OutboundInSFCOutputQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OutboundInLaminating(struct soap *soap, _ns1__OutboundInLaminating *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OutboundInLaminating))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OutboundInLaminating(struct soap *soap, const char *tag, int id, _ns1__OutboundInLaminating *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OutboundInLaminating, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OutboundInLaminating ? type : NULL);
}

SOAP_FMAC3 _ns1__OutboundInLaminating ** SOAP_FMAC4 soap_in_PointerTo_ns1__OutboundInLaminating(struct soap *soap, const char *tag, _ns1__OutboundInLaminating **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OutboundInLaminating **)soap_malloc(soap, sizeof(_ns1__OutboundInLaminating *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OutboundInLaminating *)soap_instantiate__ns1__OutboundInLaminating(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OutboundInLaminating **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OutboundInLaminating, sizeof(_ns1__OutboundInLaminating), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OutboundInLaminating(struct soap *soap, _ns1__OutboundInLaminating *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OutboundInLaminating(soap, tag ? tag : "ns1:OutboundInLaminating", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OutboundInLaminating ** SOAP_FMAC4 soap_get_PointerTo_ns1__OutboundInLaminating(struct soap *soap, _ns1__OutboundInLaminating **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OutboundInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Outbound(struct soap *soap, _ns1__Outbound *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Outbound))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Outbound(struct soap *soap, const char *tag, int id, _ns1__Outbound *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Outbound, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Outbound ? type : NULL);
}

SOAP_FMAC3 _ns1__Outbound ** SOAP_FMAC4 soap_in_PointerTo_ns1__Outbound(struct soap *soap, const char *tag, _ns1__Outbound **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Outbound **)soap_malloc(soap, sizeof(_ns1__Outbound *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Outbound *)soap_instantiate__ns1__Outbound(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Outbound **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Outbound, sizeof(_ns1__Outbound), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Outbound(struct soap *soap, _ns1__Outbound *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Outbound(soap, tag ? tag : "ns1:Outbound", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Outbound ** SOAP_FMAC4 soap_get_PointerTo_ns1__Outbound(struct soap *soap, _ns1__Outbound **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Outbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OperatorLogin(struct soap *soap, _ns1__OperatorLogin *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OperatorLogin))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OperatorLogin(struct soap *soap, const char *tag, int id, _ns1__OperatorLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OperatorLogin, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OperatorLogin ? type : NULL);
}

SOAP_FMAC3 _ns1__OperatorLogin ** SOAP_FMAC4 soap_in_PointerTo_ns1__OperatorLogin(struct soap *soap, const char *tag, _ns1__OperatorLogin **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OperatorLogin **)soap_malloc(soap, sizeof(_ns1__OperatorLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OperatorLogin *)soap_instantiate__ns1__OperatorLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OperatorLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OperatorLogin, sizeof(_ns1__OperatorLogin), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OperatorLogin(struct soap *soap, _ns1__OperatorLogin *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OperatorLogin(soap, tag ? tag : "ns1:OperatorLogin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OperatorLogin ** SOAP_FMAC4 soap_get_PointerTo_ns1__OperatorLogin(struct soap *soap, _ns1__OperatorLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OperatorLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InboundMore(struct soap *soap, _ns1__InboundMore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InboundMore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InboundMore(struct soap *soap, const char *tag, int id, _ns1__InboundMore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InboundMore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InboundMore ? type : NULL);
}

SOAP_FMAC3 _ns1__InboundMore ** SOAP_FMAC4 soap_in_PointerTo_ns1__InboundMore(struct soap *soap, const char *tag, _ns1__InboundMore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InboundMore **)soap_malloc(soap, sizeof(_ns1__InboundMore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InboundMore *)soap_instantiate__ns1__InboundMore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InboundMore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InboundMore, sizeof(_ns1__InboundMore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InboundMore(struct soap *soap, _ns1__InboundMore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InboundMore(soap, tag ? tag : "ns1:InboundMore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InboundMore ** SOAP_FMAC4 soap_get_PointerTo_ns1__InboundMore(struct soap *soap, _ns1__InboundMore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InboundInTwoInjection(struct soap *soap, _ns1__InboundInTwoInjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InboundInTwoInjection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InboundInTwoInjection(struct soap *soap, const char *tag, int id, _ns1__InboundInTwoInjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InboundInTwoInjection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InboundInTwoInjection ? type : NULL);
}

SOAP_FMAC3 _ns1__InboundInTwoInjection ** SOAP_FMAC4 soap_in_PointerTo_ns1__InboundInTwoInjection(struct soap *soap, const char *tag, _ns1__InboundInTwoInjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InboundInTwoInjection **)soap_malloc(soap, sizeof(_ns1__InboundInTwoInjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InboundInTwoInjection *)soap_instantiate__ns1__InboundInTwoInjection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InboundInTwoInjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InboundInTwoInjection, sizeof(_ns1__InboundInTwoInjection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InboundInTwoInjection(struct soap *soap, _ns1__InboundInTwoInjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InboundInTwoInjection(soap, tag ? tag : "ns1:InboundInTwoInjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InboundInTwoInjection ** SOAP_FMAC4 soap_get_PointerTo_ns1__InboundInTwoInjection(struct soap *soap, _ns1__InboundInTwoInjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InboundInTwoInjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InboundInSFCContainer(struct soap *soap, _ns1__InboundInSFCContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InboundInSFCContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InboundInSFCContainer(struct soap *soap, const char *tag, int id, _ns1__InboundInSFCContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InboundInSFCContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InboundInSFCContainer ? type : NULL);
}

SOAP_FMAC3 _ns1__InboundInSFCContainer ** SOAP_FMAC4 soap_in_PointerTo_ns1__InboundInSFCContainer(struct soap *soap, const char *tag, _ns1__InboundInSFCContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InboundInSFCContainer **)soap_malloc(soap, sizeof(_ns1__InboundInSFCContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InboundInSFCContainer *)soap_instantiate__ns1__InboundInSFCContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InboundInSFCContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InboundInSFCContainer, sizeof(_ns1__InboundInSFCContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InboundInSFCContainer(struct soap *soap, _ns1__InboundInSFCContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InboundInSFCContainer(soap, tag ? tag : "ns1:InboundInSFCContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InboundInSFCContainer ** SOAP_FMAC4 soap_get_PointerTo_ns1__InboundInSFCContainer(struct soap *soap, _ns1__InboundInSFCContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InboundInSFCContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InboundInContainer(struct soap *soap, _ns1__InboundInContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InboundInContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InboundInContainer(struct soap *soap, const char *tag, int id, _ns1__InboundInContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InboundInContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InboundInContainer ? type : NULL);
}

SOAP_FMAC3 _ns1__InboundInContainer ** SOAP_FMAC4 soap_in_PointerTo_ns1__InboundInContainer(struct soap *soap, const char *tag, _ns1__InboundInContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InboundInContainer **)soap_malloc(soap, sizeof(_ns1__InboundInContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InboundInContainer *)soap_instantiate__ns1__InboundInContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InboundInContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InboundInContainer, sizeof(_ns1__InboundInContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InboundInContainer(struct soap *soap, _ns1__InboundInContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InboundInContainer(soap, tag ? tag : "ns1:InboundInContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InboundInContainer ** SOAP_FMAC4 soap_get_PointerTo_ns1__InboundInContainer(struct soap *soap, _ns1__InboundInContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InboundInContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Inbound(struct soap *soap, _ns1__Inbound *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Inbound))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Inbound(struct soap *soap, const char *tag, int id, _ns1__Inbound *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Inbound, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Inbound ? type : NULL);
}

SOAP_FMAC3 _ns1__Inbound ** SOAP_FMAC4 soap_in_PointerTo_ns1__Inbound(struct soap *soap, const char *tag, _ns1__Inbound **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Inbound **)soap_malloc(soap, sizeof(_ns1__Inbound *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Inbound *)soap_instantiate__ns1__Inbound(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Inbound **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Inbound, sizeof(_ns1__Inbound), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Inbound(struct soap *soap, _ns1__Inbound *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Inbound(soap, tag ? tag : "ns1:Inbound", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Inbound ** SOAP_FMAC4 soap_get_PointerTo_ns1__Inbound(struct soap *soap, _ns1__Inbound **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Inbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Heartbeat(struct soap *soap, _ns1__Heartbeat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Heartbeat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Heartbeat(struct soap *soap, const char *tag, int id, _ns1__Heartbeat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Heartbeat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Heartbeat ? type : NULL);
}

SOAP_FMAC3 _ns1__Heartbeat ** SOAP_FMAC4 soap_in_PointerTo_ns1__Heartbeat(struct soap *soap, const char *tag, _ns1__Heartbeat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Heartbeat **)soap_malloc(soap, sizeof(_ns1__Heartbeat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Heartbeat *)soap_instantiate__ns1__Heartbeat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Heartbeat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Heartbeat, sizeof(_ns1__Heartbeat), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Heartbeat(struct soap *soap, _ns1__Heartbeat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Heartbeat(soap, tag ? tag : "ns1:Heartbeat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Heartbeat ** SOAP_FMAC4 soap_get_PointerTo_ns1__Heartbeat(struct soap *soap, _ns1__Heartbeat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Heartbeat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GenerateCellSFC(struct soap *soap, _ns1__GenerateCellSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GenerateCellSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GenerateCellSFC(struct soap *soap, const char *tag, int id, _ns1__GenerateCellSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GenerateCellSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GenerateCellSFC ? type : NULL);
}

SOAP_FMAC3 _ns1__GenerateCellSFC ** SOAP_FMAC4 soap_in_PointerTo_ns1__GenerateCellSFC(struct soap *soap, const char *tag, _ns1__GenerateCellSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GenerateCellSFC **)soap_malloc(soap, sizeof(_ns1__GenerateCellSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GenerateCellSFC *)soap_instantiate__ns1__GenerateCellSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GenerateCellSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GenerateCellSFC, sizeof(_ns1__GenerateCellSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GenerateCellSFC(struct soap *soap, _ns1__GenerateCellSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GenerateCellSFC(soap, tag ? tag : "ns1:GenerateCellSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GenerateCellSFC ** SOAP_FMAC4 soap_get_PointerTo_ns1__GenerateCellSFC(struct soap *soap, _ns1__GenerateCellSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GenerateCellSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FillingData(struct soap *soap, _ns1__FillingData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FillingData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FillingData(struct soap *soap, const char *tag, int id, _ns1__FillingData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FillingData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__FillingData ? type : NULL);
}

SOAP_FMAC3 _ns1__FillingData ** SOAP_FMAC4 soap_in_PointerTo_ns1__FillingData(struct soap *soap, const char *tag, _ns1__FillingData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FillingData **)soap_malloc(soap, sizeof(_ns1__FillingData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FillingData *)soap_instantiate__ns1__FillingData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__FillingData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FillingData, sizeof(_ns1__FillingData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FillingData(struct soap *soap, _ns1__FillingData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__FillingData(soap, tag ? tag : "ns1:FillingData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FillingData ** SOAP_FMAC4 soap_get_PointerTo_ns1__FillingData(struct soap *soap, _ns1__FillingData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FillingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FeedingDJInLaminating(struct soap *soap, _ns1__FeedingDJInLaminating *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FeedingDJInLaminating))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, int id, _ns1__FeedingDJInLaminating *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FeedingDJInLaminating, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__FeedingDJInLaminating ? type : NULL);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminating ** SOAP_FMAC4 soap_in_PointerTo_ns1__FeedingDJInLaminating(struct soap *soap, const char *tag, _ns1__FeedingDJInLaminating **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FeedingDJInLaminating **)soap_malloc(soap, sizeof(_ns1__FeedingDJInLaminating *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FeedingDJInLaminating *)soap_instantiate__ns1__FeedingDJInLaminating(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__FeedingDJInLaminating **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FeedingDJInLaminating, sizeof(_ns1__FeedingDJInLaminating), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FeedingDJInLaminating(struct soap *soap, _ns1__FeedingDJInLaminating *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__FeedingDJInLaminating(soap, tag ? tag : "ns1:FeedingDJInLaminating", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FeedingDJInLaminating ** SOAP_FMAC4 soap_get_PointerTo_ns1__FeedingDJInLaminating(struct soap *soap, _ns1__FeedingDJInLaminating **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FeedingDJInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Feeding(struct soap *soap, _ns1__Feeding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Feeding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Feeding(struct soap *soap, const char *tag, int id, _ns1__Feeding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Feeding, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Feeding ? type : NULL);
}

SOAP_FMAC3 _ns1__Feeding ** SOAP_FMAC4 soap_in_PointerTo_ns1__Feeding(struct soap *soap, const char *tag, _ns1__Feeding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Feeding **)soap_malloc(soap, sizeof(_ns1__Feeding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Feeding *)soap_instantiate__ns1__Feeding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Feeding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Feeding, sizeof(_ns1__Feeding), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Feeding(struct soap *soap, _ns1__Feeding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Feeding(soap, tag ? tag : "ns1:Feeding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Feeding ** SOAP_FMAC4 soap_get_PointerTo_ns1__Feeding(struct soap *soap, _ns1__Feeding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Feeding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExamineExists(struct soap *soap, _ns1__ExamineExists *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExamineExists))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExamineExists(struct soap *soap, const char *tag, int id, _ns1__ExamineExists *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExamineExists, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ExamineExists ? type : NULL);
}

SOAP_FMAC3 _ns1__ExamineExists ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExamineExists(struct soap *soap, const char *tag, _ns1__ExamineExists **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExamineExists **)soap_malloc(soap, sizeof(_ns1__ExamineExists *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExamineExists *)soap_instantiate__ns1__ExamineExists(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExamineExists **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExamineExists, sizeof(_ns1__ExamineExists), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExamineExists(struct soap *soap, _ns1__ExamineExists *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExamineExists(soap, tag ? tag : "ns1:ExamineExists", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExamineExists ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExamineExists(struct soap *soap, _ns1__ExamineExists **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExamineExists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EquipmentProductProcessParam(struct soap *soap, _ns1__EquipmentProductProcessParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EquipmentProductProcessParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, int id, _ns1__EquipmentProductProcessParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EquipmentProductProcessParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__EquipmentProductProcessParam ? type : NULL);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParam ** SOAP_FMAC4 soap_in_PointerTo_ns1__EquipmentProductProcessParam(struct soap *soap, const char *tag, _ns1__EquipmentProductProcessParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EquipmentProductProcessParam **)soap_malloc(soap, sizeof(_ns1__EquipmentProductProcessParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EquipmentProductProcessParam *)soap_instantiate__ns1__EquipmentProductProcessParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EquipmentProductProcessParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EquipmentProductProcessParam, sizeof(_ns1__EquipmentProductProcessParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EquipmentProductProcessParam(struct soap *soap, _ns1__EquipmentProductProcessParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EquipmentProductProcessParam(soap, tag ? tag : "ns1:EquipmentProductProcessParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EquipmentProductProcessParam ** SOAP_FMAC4 soap_get_PointerTo_ns1__EquipmentProductProcessParam(struct soap *soap, _ns1__EquipmentProductProcessParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EquipmentProductProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EquipmentProcessParam(struct soap *soap, _ns1__EquipmentProcessParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EquipmentProcessParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EquipmentProcessParam(struct soap *soap, const char *tag, int id, _ns1__EquipmentProcessParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EquipmentProcessParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__EquipmentProcessParam ? type : NULL);
}

SOAP_FMAC3 _ns1__EquipmentProcessParam ** SOAP_FMAC4 soap_in_PointerTo_ns1__EquipmentProcessParam(struct soap *soap, const char *tag, _ns1__EquipmentProcessParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EquipmentProcessParam **)soap_malloc(soap, sizeof(_ns1__EquipmentProcessParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EquipmentProcessParam *)soap_instantiate__ns1__EquipmentProcessParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EquipmentProcessParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EquipmentProcessParam, sizeof(_ns1__EquipmentProcessParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EquipmentProcessParam(struct soap *soap, _ns1__EquipmentProcessParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EquipmentProcessParam(soap, tag ? tag : "ns1:EquipmentProcessParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EquipmentProcessParam ** SOAP_FMAC4 soap_get_PointerTo_ns1__EquipmentProcessParam(struct soap *soap, _ns1__EquipmentProcessParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EquipmentProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownReason(struct soap *soap, _ns1__DownReason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownReason))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownReason(struct soap *soap, const char *tag, int id, _ns1__DownReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownReason, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownReason ? type : NULL);
}

SOAP_FMAC3 _ns1__DownReason ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownReason(struct soap *soap, const char *tag, _ns1__DownReason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownReason **)soap_malloc(soap, sizeof(_ns1__DownReason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownReason *)soap_instantiate__ns1__DownReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownReason, sizeof(_ns1__DownReason), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownReason(struct soap *soap, _ns1__DownReason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownReason(soap, tag ? tag : "ns1:DownReason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownReason ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownReason(struct soap *soap, _ns1__DownReason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CCDFileUploadComplete(struct soap *soap, _ns1__CCDFileUploadComplete *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CCDFileUploadComplete))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, int id, _ns1__CCDFileUploadComplete *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CCDFileUploadComplete, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CCDFileUploadComplete ? type : NULL);
}

SOAP_FMAC3 _ns1__CCDFileUploadComplete ** SOAP_FMAC4 soap_in_PointerTo_ns1__CCDFileUploadComplete(struct soap *soap, const char *tag, _ns1__CCDFileUploadComplete **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CCDFileUploadComplete **)soap_malloc(soap, sizeof(_ns1__CCDFileUploadComplete *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CCDFileUploadComplete *)soap_instantiate__ns1__CCDFileUploadComplete(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CCDFileUploadComplete **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CCDFileUploadComplete, sizeof(_ns1__CCDFileUploadComplete), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CCDFileUploadComplete(struct soap *soap, _ns1__CCDFileUploadComplete *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CCDFileUploadComplete(soap, tag ? tag : "ns1:CCDFileUploadComplete", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CCDFileUploadComplete ** SOAP_FMAC4 soap_get_PointerTo_ns1__CCDFileUploadComplete(struct soap *soap, _ns1__CCDFileUploadComplete **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CCDFileUploadComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BindSFC(struct soap *soap, _ns1__BindSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BindSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BindSFC(struct soap *soap, const char *tag, int id, _ns1__BindSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BindSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BindSFC ? type : NULL);
}

SOAP_FMAC3 _ns1__BindSFC ** SOAP_FMAC4 soap_in_PointerTo_ns1__BindSFC(struct soap *soap, const char *tag, _ns1__BindSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BindSFC **)soap_malloc(soap, sizeof(_ns1__BindSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BindSFC *)soap_instantiate__ns1__BindSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BindSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BindSFC, sizeof(_ns1__BindSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BindSFC(struct soap *soap, _ns1__BindSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BindSFC(soap, tag ? tag : "ns1:BindSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BindSFC ** SOAP_FMAC4 soap_get_PointerTo_ns1__BindSFC(struct soap *soap, _ns1__BindSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BindSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BindContainer(struct soap *soap, _ns1__BindContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BindContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BindContainer(struct soap *soap, const char *tag, int id, _ns1__BindContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BindContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BindContainer ? type : NULL);
}

SOAP_FMAC3 _ns1__BindContainer ** SOAP_FMAC4 soap_in_PointerTo_ns1__BindContainer(struct soap *soap, const char *tag, _ns1__BindContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BindContainer **)soap_malloc(soap, sizeof(_ns1__BindContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BindContainer *)soap_instantiate__ns1__BindContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BindContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BindContainer, sizeof(_ns1__BindContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BindContainer(struct soap *soap, _ns1__BindContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BindContainer(soap, tag ? tag : "ns1:BindContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BindContainer ** SOAP_FMAC4 soap_get_PointerTo_ns1__BindContainer(struct soap *soap, _ns1__BindContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BindContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Alarm(struct soap *soap, _ns1__Alarm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Alarm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Alarm(struct soap *soap, const char *tag, int id, _ns1__Alarm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Alarm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Alarm ? type : NULL);
}

SOAP_FMAC3 _ns1__Alarm ** SOAP_FMAC4 soap_in_PointerTo_ns1__Alarm(struct soap *soap, const char *tag, _ns1__Alarm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Alarm **)soap_malloc(soap, sizeof(_ns1__Alarm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Alarm *)soap_instantiate__ns1__Alarm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Alarm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Alarm, sizeof(_ns1__Alarm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Alarm(struct soap *soap, _ns1__Alarm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Alarm(soap, tag ? tag : "ns1:Alarm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Alarm ** SOAP_FMAC4 soap_get_PointerTo_ns1__Alarm(struct soap *soap, _ns1__Alarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LoginSoapHeader(struct soap *soap, ns1__LoginSoapHeader *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LoginSoapHeader))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LoginSoapHeader(struct soap *soap, const char *tag, int id, ns1__LoginSoapHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LoginSoapHeader, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LoginSoapHeader ? type : NULL);
}

SOAP_FMAC3 ns1__LoginSoapHeader ** SOAP_FMAC4 soap_in_PointerTons1__LoginSoapHeader(struct soap *soap, const char *tag, ns1__LoginSoapHeader **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LoginSoapHeader **)soap_malloc(soap, sizeof(ns1__LoginSoapHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LoginSoapHeader *)soap_instantiate_ns1__LoginSoapHeader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LoginSoapHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LoginSoapHeader, sizeof(ns1__LoginSoapHeader), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LoginSoapHeader(struct soap *soap, ns1__LoginSoapHeader *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LoginSoapHeader(soap, tag ? tag : "ns1:LoginSoapHeader", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LoginSoapHeader ** SOAP_FMAC4 soap_get_PointerTons1__LoginSoapHeader(struct soap *soap, ns1__LoginSoapHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LoginSoapHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfRecipeListGetForEqu(struct soap *soap, ns1__ArrayOfRecipeListGetForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfRecipeListGetForEqu(struct soap *soap, const char *tag, int id, ns1__ArrayOfRecipeListGetForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfRecipeListGetForEqu ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfRecipeListGetForEqu(struct soap *soap, const char *tag, ns1__ArrayOfRecipeListGetForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfRecipeListGetForEqu **)soap_malloc(soap, sizeof(ns1__ArrayOfRecipeListGetForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfRecipeListGetForEqu *)soap_instantiate_ns1__ArrayOfRecipeListGetForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfRecipeListGetForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfRecipeListGetForEqu, sizeof(ns1__ArrayOfRecipeListGetForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfRecipeListGetForEqu(struct soap *soap, ns1__ArrayOfRecipeListGetForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfRecipeListGetForEqu(soap, tag ? tag : "ns1:ArrayOfRecipeListGetForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfRecipeListGetForEqu ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfRecipeListGetForEqu(struct soap *soap, ns1__ArrayOfRecipeListGetForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfRecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeGetForEqu(struct soap *soap, ns1__RecipeGetForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeGetForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeGetForEqu(struct soap *soap, const char *tag, int id, ns1__RecipeGetForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeGetForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeGetForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeGetForEqu ** SOAP_FMAC4 soap_in_PointerTons1__RecipeGetForEqu(struct soap *soap, const char *tag, ns1__RecipeGetForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeGetForEqu **)soap_malloc(soap, sizeof(ns1__RecipeGetForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeGetForEqu *)soap_instantiate_ns1__RecipeGetForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeGetForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeGetForEqu, sizeof(ns1__RecipeGetForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeGetForEqu(struct soap *soap, ns1__RecipeGetForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeGetForEqu(soap, tag ? tag : "ns1:RecipeGetForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeGetForEqu ** SOAP_FMAC4 soap_get_PointerTons1__RecipeGetForEqu(struct soap *soap, ns1__RecipeGetForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfRecipeParam(struct soap *soap, ns1__ArrayOfRecipeParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfRecipeParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfRecipeParam(struct soap *soap, const char *tag, int id, ns1__ArrayOfRecipeParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfRecipeParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfRecipeParam ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfRecipeParam ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfRecipeParam(struct soap *soap, const char *tag, ns1__ArrayOfRecipeParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfRecipeParam **)soap_malloc(soap, sizeof(ns1__ArrayOfRecipeParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfRecipeParam *)soap_instantiate_ns1__ArrayOfRecipeParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfRecipeParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfRecipeParam, sizeof(ns1__ArrayOfRecipeParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfRecipeParam(struct soap *soap, ns1__ArrayOfRecipeParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfRecipeParam(soap, tag ? tag : "ns1:ArrayOfRecipeParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfRecipeParam ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfRecipeParam(struct soap *soap, ns1__ArrayOfRecipeParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfRecipeParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfOutboundSFC(struct soap *soap, ns1__ArrayOfOutboundSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfOutboundSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfOutboundSFC(struct soap *soap, const char *tag, int id, ns1__ArrayOfOutboundSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfOutboundSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfOutboundSFC ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfOutboundSFC ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfOutboundSFC(struct soap *soap, const char *tag, ns1__ArrayOfOutboundSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfOutboundSFC **)soap_malloc(soap, sizeof(ns1__ArrayOfOutboundSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfOutboundSFC *)soap_instantiate_ns1__ArrayOfOutboundSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfOutboundSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfOutboundSFC, sizeof(ns1__ArrayOfOutboundSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfOutboundSFC(struct soap *soap, ns1__ArrayOfOutboundSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfOutboundSFC(soap, tag ? tag : "ns1:ArrayOfOutboundSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfOutboundSFC ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfOutboundSFC(struct soap *soap, ns1__ArrayOfOutboundSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfOutboundSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InboundInTwoInjectionForEqu(struct soap *soap, ns1__InboundInTwoInjectionForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InboundInTwoInjectionForEqu(struct soap *soap, const char *tag, int id, ns1__InboundInTwoInjectionForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InboundInTwoInjectionForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__InboundInTwoInjectionForEqu ** SOAP_FMAC4 soap_in_PointerTons1__InboundInTwoInjectionForEqu(struct soap *soap, const char *tag, ns1__InboundInTwoInjectionForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InboundInTwoInjectionForEqu **)soap_malloc(soap, sizeof(ns1__InboundInTwoInjectionForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InboundInTwoInjectionForEqu *)soap_instantiate_ns1__InboundInTwoInjectionForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InboundInTwoInjectionForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InboundInTwoInjectionForEqu, sizeof(ns1__InboundInTwoInjectionForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InboundInTwoInjectionForEqu(struct soap *soap, ns1__InboundInTwoInjectionForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InboundInTwoInjectionForEqu(soap, tag ? tag : "ns1:InboundInTwoInjectionForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InboundInTwoInjectionForEqu ** SOAP_FMAC4 soap_get_PointerTons1__InboundInTwoInjectionForEqu(struct soap *soap, ns1__InboundInTwoInjectionForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InboundInTwoInjectionForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfApiResponseSFCForScada(struct soap *soap, ns1__ArrayOfApiResponseSFCForScada *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfApiResponseSFCForScada(struct soap *soap, const char *tag, int id, ns1__ArrayOfApiResponseSFCForScada *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfApiResponseSFCForScada ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ArrayOfApiResponseSFCForScada **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfApiResponseSFCForScada **)soap_malloc(soap, sizeof(ns1__ArrayOfApiResponseSFCForScada *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfApiResponseSFCForScada *)soap_instantiate_ns1__ArrayOfApiResponseSFCForScada(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfApiResponseSFCForScada **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfApiResponseSFCForScada, sizeof(ns1__ArrayOfApiResponseSFCForScada), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfApiResponseSFCForScada(struct soap *soap, ns1__ArrayOfApiResponseSFCForScada *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfApiResponseSFCForScada(soap, tag ? tag : "ns1:ArrayOfApiResponseSFCForScada", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfApiResponseSFCForScada ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfApiResponseSFCForScada(struct soap *soap, ns1__ArrayOfApiResponseSFCForScada **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, ns1__ArrayOfEquipmentProductProcessParamSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, const char *tag, int id, ns1__ArrayOfEquipmentProductProcessParamSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfEquipmentProductProcessParamSFC ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, const char *tag, ns1__ArrayOfEquipmentProductProcessParamSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfEquipmentProductProcessParamSFC **)soap_malloc(soap, sizeof(ns1__ArrayOfEquipmentProductProcessParamSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfEquipmentProductProcessParamSFC *)soap_instantiate_ns1__ArrayOfEquipmentProductProcessParamSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfEquipmentProductProcessParamSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfEquipmentProductProcessParamSFC, sizeof(ns1__ArrayOfEquipmentProductProcessParamSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, ns1__ArrayOfEquipmentProductProcessParamSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, tag ? tag : "ns1:ArrayOfEquipmentProductProcessParamSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfEquipmentProductProcessParamSFC ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(struct soap *soap, ns1__ArrayOfEquipmentProductProcessParamSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfEquipmentProductProcessParamSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, ns1__ArrayOfCCDFileUploadCompleteSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, const char *tag, int id, ns1__ArrayOfCCDFileUploadCompleteSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfCCDFileUploadCompleteSFC ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, const char *tag, ns1__ArrayOfCCDFileUploadCompleteSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCCDFileUploadCompleteSFC **)soap_malloc(soap, sizeof(ns1__ArrayOfCCDFileUploadCompleteSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCCDFileUploadCompleteSFC *)soap_instantiate_ns1__ArrayOfCCDFileUploadCompleteSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfCCDFileUploadCompleteSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfCCDFileUploadCompleteSFC, sizeof(ns1__ArrayOfCCDFileUploadCompleteSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, ns1__ArrayOfCCDFileUploadCompleteSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, tag ? tag : "ns1:ArrayOfCCDFileUploadCompleteSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfCCDFileUploadCompleteSFC ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(struct soap *soap, ns1__ArrayOfCCDFileUploadCompleteSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCCDFileUploadCompleteSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfBindContainerSFC(struct soap *soap, ns1__ArrayOfBindContainerSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfBindContainerSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfBindContainerSFC(struct soap *soap, const char *tag, int id, ns1__ArrayOfBindContainerSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfBindContainerSFC ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfBindContainerSFC ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfBindContainerSFC(struct soap *soap, const char *tag, ns1__ArrayOfBindContainerSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfBindContainerSFC **)soap_malloc(soap, sizeof(ns1__ArrayOfBindContainerSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfBindContainerSFC *)soap_instantiate_ns1__ArrayOfBindContainerSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfBindContainerSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfBindContainerSFC, sizeof(ns1__ArrayOfBindContainerSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfBindContainerSFC(struct soap *soap, ns1__ArrayOfBindContainerSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfBindContainerSFC(soap, tag ? tag : "ns1:ArrayOfBindContainerSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfBindContainerSFC ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfBindContainerSFC(struct soap *soap, ns1__ArrayOfBindContainerSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfBindContainerSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UnBindSFCByScadaDTO(struct soap *soap, ns1__UnBindSFCByScadaDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UnBindSFCByScadaDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UnBindSFCByScadaDTO(struct soap *soap, const char *tag, int id, ns1__UnBindSFCByScadaDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__UnBindSFCByScadaDTO ? type : NULL);
}

SOAP_FMAC3 ns1__UnBindSFCByScadaDTO ** SOAP_FMAC4 soap_in_PointerTons1__UnBindSFCByScadaDTO(struct soap *soap, const char *tag, ns1__UnBindSFCByScadaDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UnBindSFCByScadaDTO **)soap_malloc(soap, sizeof(ns1__UnBindSFCByScadaDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UnBindSFCByScadaDTO *)soap_instantiate_ns1__UnBindSFCByScadaDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__UnBindSFCByScadaDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UnBindSFCByScadaDTO, sizeof(ns1__UnBindSFCByScadaDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UnBindSFCByScadaDTO(struct soap *soap, ns1__UnBindSFCByScadaDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__UnBindSFCByScadaDTO(soap, tag ? tag : "ns1:UnBindSFCByScadaDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UnBindSFCByScadaDTO ** SOAP_FMAC4 soap_get_PointerTons1__UnBindSFCByScadaDTO(struct soap *soap, ns1__UnBindSFCByScadaDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UnBindSFCByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ToolLife(struct soap *soap, ns1__ToolLife *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ToolLife))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ToolLife(struct soap *soap, const char *tag, int id, ns1__ToolLife *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ToolLife, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ToolLife ? type : NULL);
}

SOAP_FMAC3 ns1__ToolLife ** SOAP_FMAC4 soap_in_PointerTons1__ToolLife(struct soap *soap, const char *tag, ns1__ToolLife **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ToolLife **)soap_malloc(soap, sizeof(ns1__ToolLife *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ToolLife *)soap_instantiate_ns1__ToolLife(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ToolLife **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ToolLife, sizeof(ns1__ToolLife), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ToolLife(struct soap *soap, ns1__ToolLife *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ToolLife(soap, tag ? tag : "ns1:ToolLife", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ToolLife ** SOAP_FMAC4 soap_get_PointerTons1__ToolLife(struct soap *soap, ns1__ToolLife **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ToolLife(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ToolBind(struct soap *soap, ns1__ToolBind *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ToolBind))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ToolBind(struct soap *soap, const char *tag, int id, ns1__ToolBind *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ToolBind, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ToolBind ? type : NULL);
}

SOAP_FMAC3 ns1__ToolBind ** SOAP_FMAC4 soap_in_PointerTons1__ToolBind(struct soap *soap, const char *tag, ns1__ToolBind **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ToolBind **)soap_malloc(soap, sizeof(ns1__ToolBind *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ToolBind *)soap_instantiate_ns1__ToolBind(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ToolBind **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ToolBind, sizeof(ns1__ToolBind), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ToolBind(struct soap *soap, ns1__ToolBind *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ToolBind(soap, tag ? tag : "ns1:ToolBind", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ToolBind ** SOAP_FMAC4 soap_get_PointerTons1__ToolBind(struct soap *soap, ns1__ToolBind **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ToolBind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__State(struct soap *soap, ns1__State *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__State))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__State(struct soap *soap, const char *tag, int id, ns1__State *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__State, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__State ? type : NULL);
}

SOAP_FMAC3 ns1__State ** SOAP_FMAC4 soap_in_PointerTons1__State(struct soap *soap, const char *tag, ns1__State **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__State **)soap_malloc(soap, sizeof(ns1__State *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__State *)soap_instantiate_ns1__State(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__State **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__State, sizeof(ns1__State), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__State(struct soap *soap, ns1__State *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__State(soap, tag ? tag : "ns1:State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__State ** SOAP_FMAC4 soap_get_PointerTons1__State(struct soap *soap, ns1__State **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeVersionExamine(struct soap *soap, ns1__RecipeVersionExamine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeVersionExamine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeVersionExamine(struct soap *soap, const char *tag, int id, ns1__RecipeVersionExamine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeVersionExamine, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeVersionExamine ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeVersionExamine ** SOAP_FMAC4 soap_in_PointerTons1__RecipeVersionExamine(struct soap *soap, const char *tag, ns1__RecipeVersionExamine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeVersionExamine **)soap_malloc(soap, sizeof(ns1__RecipeVersionExamine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeVersionExamine *)soap_instantiate_ns1__RecipeVersionExamine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeVersionExamine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeVersionExamine, sizeof(ns1__RecipeVersionExamine), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeVersionExamine(struct soap *soap, ns1__RecipeVersionExamine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeVersionExamine(soap, tag ? tag : "ns1:RecipeVersionExamine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeVersionExamine ** SOAP_FMAC4 soap_get_PointerTons1__RecipeVersionExamine(struct soap *soap, ns1__RecipeVersionExamine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeVersionExamine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, const char *tag, int id, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu **)soap_malloc(soap, sizeof(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *)soap_instantiate_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfListOfRecipeListGetForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseDataForScadaOfListOfRecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeListGet(struct soap *soap, ns1__RecipeListGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeListGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeListGet(struct soap *soap, const char *tag, int id, ns1__RecipeListGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeListGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeListGet ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeListGet ** SOAP_FMAC4 soap_in_PointerTons1__RecipeListGet(struct soap *soap, const char *tag, ns1__RecipeListGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeListGet **)soap_malloc(soap, sizeof(ns1__RecipeListGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeListGet *)soap_instantiate_ns1__RecipeListGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeListGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeListGet, sizeof(ns1__RecipeListGet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeListGet(struct soap *soap, ns1__RecipeListGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeListGet(soap, tag ? tag : "ns1:RecipeListGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeListGet ** SOAP_FMAC4 soap_get_PointerTons1__RecipeListGet(struct soap *soap, ns1__RecipeListGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeListGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, const char *tag, int id, ns1__ApiResponseDataForScadaOfRecipeGetForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfRecipeGetForEqu ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfRecipeGetForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseDataForScadaOfRecipeGetForEqu **)soap_malloc(soap, sizeof(ns1__ApiResponseDataForScadaOfRecipeGetForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseDataForScadaOfRecipeGetForEqu *)soap_instantiate_ns1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfRecipeGetForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfRecipeGetForEqu, sizeof(ns1__ApiResponseDataForScadaOfRecipeGetForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfRecipeGetForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfRecipeGetForEqu ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfRecipeGetForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseDataForScadaOfRecipeGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeGet(struct soap *soap, ns1__RecipeGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeGet(struct soap *soap, const char *tag, int id, ns1__RecipeGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeGet ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeGet ** SOAP_FMAC4 soap_in_PointerTons1__RecipeGet(struct soap *soap, const char *tag, ns1__RecipeGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeGet **)soap_malloc(soap, sizeof(ns1__RecipeGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeGet *)soap_instantiate_ns1__RecipeGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeGet, sizeof(ns1__RecipeGet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeGet(struct soap *soap, ns1__RecipeGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeGet(soap, tag ? tag : "ns1:RecipeGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeGet ** SOAP_FMAC4 soap_get_PointerTons1__RecipeGet(struct soap *soap, ns1__RecipeGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Recipe(struct soap *soap, ns1__Recipe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Recipe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Recipe(struct soap *soap, const char *tag, int id, ns1__Recipe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Recipe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Recipe ? type : NULL);
}

SOAP_FMAC3 ns1__Recipe ** SOAP_FMAC4 soap_in_PointerTons1__Recipe(struct soap *soap, const char *tag, ns1__Recipe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Recipe **)soap_malloc(soap, sizeof(ns1__Recipe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Recipe *)soap_instantiate_ns1__Recipe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Recipe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Recipe, sizeof(ns1__Recipe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Recipe(struct soap *soap, ns1__Recipe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Recipe(soap, tag ? tag : "ns1:Recipe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Recipe ** SOAP_FMAC4 soap_get_PointerTons1__Recipe(struct soap *soap, ns1__Recipe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Recipe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OutboundMore(struct soap *soap, ns1__OutboundMore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OutboundMore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OutboundMore(struct soap *soap, const char *tag, int id, ns1__OutboundMore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OutboundMore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OutboundMore ? type : NULL);
}

SOAP_FMAC3 ns1__OutboundMore ** SOAP_FMAC4 soap_in_PointerTons1__OutboundMore(struct soap *soap, const char *tag, ns1__OutboundMore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OutboundMore **)soap_malloc(soap, sizeof(ns1__OutboundMore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OutboundMore *)soap_instantiate_ns1__OutboundMore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OutboundMore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OutboundMore, sizeof(ns1__OutboundMore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OutboundMore(struct soap *soap, ns1__OutboundMore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OutboundMore(soap, tag ? tag : "ns1:OutboundMore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OutboundMore ** SOAP_FMAC4 soap_get_PointerTons1__OutboundMore(struct soap *soap, ns1__OutboundMore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OutboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OutboundInSFCOutputQty(struct soap *soap, ns1__OutboundInSFCOutputQty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OutboundInSFCOutputQty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, int id, ns1__OutboundInSFCOutputQty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OutboundInSFCOutputQty, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OutboundInSFCOutputQty ? type : NULL);
}

SOAP_FMAC3 ns1__OutboundInSFCOutputQty ** SOAP_FMAC4 soap_in_PointerTons1__OutboundInSFCOutputQty(struct soap *soap, const char *tag, ns1__OutboundInSFCOutputQty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OutboundInSFCOutputQty **)soap_malloc(soap, sizeof(ns1__OutboundInSFCOutputQty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OutboundInSFCOutputQty *)soap_instantiate_ns1__OutboundInSFCOutputQty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OutboundInSFCOutputQty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OutboundInSFCOutputQty, sizeof(ns1__OutboundInSFCOutputQty), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OutboundInSFCOutputQty(struct soap *soap, ns1__OutboundInSFCOutputQty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OutboundInSFCOutputQty(soap, tag ? tag : "ns1:OutboundInSFCOutputQty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OutboundInSFCOutputQty ** SOAP_FMAC4 soap_get_PointerTons1__OutboundInSFCOutputQty(struct soap *soap, ns1__OutboundInSFCOutputQty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OutboundInSFCOutputQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OutboundInLaminating(struct soap *soap, ns1__OutboundInLaminating *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OutboundInLaminating))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OutboundInLaminating(struct soap *soap, const char *tag, int id, ns1__OutboundInLaminating *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OutboundInLaminating, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OutboundInLaminating ? type : NULL);
}

SOAP_FMAC3 ns1__OutboundInLaminating ** SOAP_FMAC4 soap_in_PointerTons1__OutboundInLaminating(struct soap *soap, const char *tag, ns1__OutboundInLaminating **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OutboundInLaminating **)soap_malloc(soap, sizeof(ns1__OutboundInLaminating *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OutboundInLaminating *)soap_instantiate_ns1__OutboundInLaminating(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OutboundInLaminating **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OutboundInLaminating, sizeof(ns1__OutboundInLaminating), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OutboundInLaminating(struct soap *soap, ns1__OutboundInLaminating *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OutboundInLaminating(soap, tag ? tag : "ns1:OutboundInLaminating", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OutboundInLaminating ** SOAP_FMAC4 soap_get_PointerTons1__OutboundInLaminating(struct soap *soap, ns1__OutboundInLaminating **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OutboundInLaminating(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Outbound(struct soap *soap, ns1__Outbound *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Outbound))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Outbound(struct soap *soap, const char *tag, int id, ns1__Outbound *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Outbound, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Outbound ? type : NULL);
}

SOAP_FMAC3 ns1__Outbound ** SOAP_FMAC4 soap_in_PointerTons1__Outbound(struct soap *soap, const char *tag, ns1__Outbound **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Outbound **)soap_malloc(soap, sizeof(ns1__Outbound *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Outbound *)soap_instantiate_ns1__Outbound(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Outbound **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Outbound, sizeof(ns1__Outbound), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Outbound(struct soap *soap, ns1__Outbound *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Outbound(soap, tag ? tag : "ns1:Outbound", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Outbound ** SOAP_FMAC4 soap_get_PointerTons1__Outbound(struct soap *soap, ns1__Outbound **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Outbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OperatorLogin(struct soap *soap, ns1__OperatorLogin *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OperatorLogin))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OperatorLogin(struct soap *soap, const char *tag, int id, ns1__OperatorLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OperatorLogin, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OperatorLogin ? type : NULL);
}

SOAP_FMAC3 ns1__OperatorLogin ** SOAP_FMAC4 soap_in_PointerTons1__OperatorLogin(struct soap *soap, const char *tag, ns1__OperatorLogin **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OperatorLogin **)soap_malloc(soap, sizeof(ns1__OperatorLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OperatorLogin *)soap_instantiate_ns1__OperatorLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OperatorLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OperatorLogin, sizeof(ns1__OperatorLogin), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OperatorLogin(struct soap *soap, ns1__OperatorLogin *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OperatorLogin(soap, tag ? tag : "ns1:OperatorLogin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OperatorLogin ** SOAP_FMAC4 soap_get_PointerTons1__OperatorLogin(struct soap *soap, ns1__OperatorLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OperatorLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InboundMore(struct soap *soap, ns1__InboundMore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InboundMore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InboundMore(struct soap *soap, const char *tag, int id, ns1__InboundMore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InboundMore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InboundMore ? type : NULL);
}

SOAP_FMAC3 ns1__InboundMore ** SOAP_FMAC4 soap_in_PointerTons1__InboundMore(struct soap *soap, const char *tag, ns1__InboundMore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InboundMore **)soap_malloc(soap, sizeof(ns1__InboundMore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InboundMore *)soap_instantiate_ns1__InboundMore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InboundMore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InboundMore, sizeof(ns1__InboundMore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InboundMore(struct soap *soap, ns1__InboundMore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InboundMore(soap, tag ? tag : "ns1:InboundMore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InboundMore ** SOAP_FMAC4 soap_get_PointerTons1__InboundMore(struct soap *soap, ns1__InboundMore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InboundMore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, const char *tag, int id, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu **)soap_malloc(soap, sizeof(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *)soap_instantiate_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu, sizeof(ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfInboundInTwoInjectionForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(struct soap *soap, ns1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseDataForScadaOfInboundInTwoInjectionForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InboundInTwoInjection(struct soap *soap, ns1__InboundInTwoInjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InboundInTwoInjection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InboundInTwoInjection(struct soap *soap, const char *tag, int id, ns1__InboundInTwoInjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InboundInTwoInjection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InboundInTwoInjection ? type : NULL);
}

SOAP_FMAC3 ns1__InboundInTwoInjection ** SOAP_FMAC4 soap_in_PointerTons1__InboundInTwoInjection(struct soap *soap, const char *tag, ns1__InboundInTwoInjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InboundInTwoInjection **)soap_malloc(soap, sizeof(ns1__InboundInTwoInjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InboundInTwoInjection *)soap_instantiate_ns1__InboundInTwoInjection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InboundInTwoInjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InboundInTwoInjection, sizeof(ns1__InboundInTwoInjection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InboundInTwoInjection(struct soap *soap, ns1__InboundInTwoInjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InboundInTwoInjection(soap, tag ? tag : "ns1:InboundInTwoInjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InboundInTwoInjection ** SOAP_FMAC4 soap_get_PointerTons1__InboundInTwoInjection(struct soap *soap, ns1__InboundInTwoInjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InboundInTwoInjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InboundInSFCContainer(struct soap *soap, ns1__InboundInSFCContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InboundInSFCContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InboundInSFCContainer(struct soap *soap, const char *tag, int id, ns1__InboundInSFCContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InboundInSFCContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InboundInSFCContainer ? type : NULL);
}

SOAP_FMAC3 ns1__InboundInSFCContainer ** SOAP_FMAC4 soap_in_PointerTons1__InboundInSFCContainer(struct soap *soap, const char *tag, ns1__InboundInSFCContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InboundInSFCContainer **)soap_malloc(soap, sizeof(ns1__InboundInSFCContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InboundInSFCContainer *)soap_instantiate_ns1__InboundInSFCContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InboundInSFCContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InboundInSFCContainer, sizeof(ns1__InboundInSFCContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InboundInSFCContainer(struct soap *soap, ns1__InboundInSFCContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InboundInSFCContainer(soap, tag ? tag : "ns1:InboundInSFCContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InboundInSFCContainer ** SOAP_FMAC4 soap_get_PointerTons1__InboundInSFCContainer(struct soap *soap, ns1__InboundInSFCContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InboundInSFCContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InboundInContainer(struct soap *soap, ns1__InboundInContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InboundInContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InboundInContainer(struct soap *soap, const char *tag, int id, ns1__InboundInContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InboundInContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InboundInContainer ? type : NULL);
}

SOAP_FMAC3 ns1__InboundInContainer ** SOAP_FMAC4 soap_in_PointerTons1__InboundInContainer(struct soap *soap, const char *tag, ns1__InboundInContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InboundInContainer **)soap_malloc(soap, sizeof(ns1__InboundInContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InboundInContainer *)soap_instantiate_ns1__InboundInContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InboundInContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InboundInContainer, sizeof(ns1__InboundInContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InboundInContainer(struct soap *soap, ns1__InboundInContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InboundInContainer(soap, tag ? tag : "ns1:InboundInContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InboundInContainer ** SOAP_FMAC4 soap_get_PointerTons1__InboundInContainer(struct soap *soap, ns1__InboundInContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InboundInContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Inbound(struct soap *soap, ns1__Inbound *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Inbound))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Inbound(struct soap *soap, const char *tag, int id, ns1__Inbound *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Inbound, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Inbound ? type : NULL);
}

SOAP_FMAC3 ns1__Inbound ** SOAP_FMAC4 soap_in_PointerTons1__Inbound(struct soap *soap, const char *tag, ns1__Inbound **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Inbound **)soap_malloc(soap, sizeof(ns1__Inbound *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Inbound *)soap_instantiate_ns1__Inbound(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Inbound **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Inbound, sizeof(ns1__Inbound), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Inbound(struct soap *soap, ns1__Inbound *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Inbound(soap, tag ? tag : "ns1:Inbound", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Inbound ** SOAP_FMAC4 soap_get_PointerTons1__Inbound(struct soap *soap, ns1__Inbound **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Inbound(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Heartbeat(struct soap *soap, ns1__Heartbeat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Heartbeat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Heartbeat(struct soap *soap, const char *tag, int id, ns1__Heartbeat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Heartbeat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Heartbeat ? type : NULL);
}

SOAP_FMAC3 ns1__Heartbeat ** SOAP_FMAC4 soap_in_PointerTons1__Heartbeat(struct soap *soap, const char *tag, ns1__Heartbeat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Heartbeat **)soap_malloc(soap, sizeof(ns1__Heartbeat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Heartbeat *)soap_instantiate_ns1__Heartbeat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Heartbeat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Heartbeat, sizeof(ns1__Heartbeat), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Heartbeat(struct soap *soap, ns1__Heartbeat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Heartbeat(soap, tag ? tag : "ns1:Heartbeat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Heartbeat ** SOAP_FMAC4 soap_get_PointerTons1__Heartbeat(struct soap *soap, ns1__Heartbeat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Heartbeat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseDataForScadaOfString(struct soap *soap, ns1__ApiResponseDataForScadaOfString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseDataForScadaOfString(struct soap *soap, const char *tag, int id, ns1__ApiResponseDataForScadaOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseDataForScadaOfString ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfString ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseDataForScadaOfString(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseDataForScadaOfString **)soap_malloc(soap, sizeof(ns1__ApiResponseDataForScadaOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseDataForScadaOfString *)soap_instantiate_ns1__ApiResponseDataForScadaOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfString, sizeof(ns1__ApiResponseDataForScadaOfString), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseDataForScadaOfString(struct soap *soap, ns1__ApiResponseDataForScadaOfString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfString(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfString ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseDataForScadaOfString(struct soap *soap, ns1__ApiResponseDataForScadaOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseDataForScadaOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenerateCellSFC(struct soap *soap, ns1__GenerateCellSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenerateCellSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenerateCellSFC(struct soap *soap, const char *tag, int id, ns1__GenerateCellSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenerateCellSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenerateCellSFC ? type : NULL);
}

SOAP_FMAC3 ns1__GenerateCellSFC ** SOAP_FMAC4 soap_in_PointerTons1__GenerateCellSFC(struct soap *soap, const char *tag, ns1__GenerateCellSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenerateCellSFC **)soap_malloc(soap, sizeof(ns1__GenerateCellSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenerateCellSFC *)soap_instantiate_ns1__GenerateCellSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenerateCellSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenerateCellSFC, sizeof(ns1__GenerateCellSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenerateCellSFC(struct soap *soap, ns1__GenerateCellSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenerateCellSFC(soap, tag ? tag : "ns1:GenerateCellSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenerateCellSFC ** SOAP_FMAC4 soap_get_PointerTons1__GenerateCellSFC(struct soap *soap, ns1__GenerateCellSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenerateCellSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FillingData(struct soap *soap, ns1__FillingData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FillingData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FillingData(struct soap *soap, const char *tag, int id, ns1__FillingData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FillingData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FillingData ? type : NULL);
}

SOAP_FMAC3 ns1__FillingData ** SOAP_FMAC4 soap_in_PointerTons1__FillingData(struct soap *soap, const char *tag, ns1__FillingData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FillingData **)soap_malloc(soap, sizeof(ns1__FillingData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FillingData *)soap_instantiate_ns1__FillingData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FillingData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FillingData, sizeof(ns1__FillingData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FillingData(struct soap *soap, ns1__FillingData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FillingData(soap, tag ? tag : "ns1:FillingData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FillingData ** SOAP_FMAC4 soap_get_PointerTons1__FillingData(struct soap *soap, ns1__FillingData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FillingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, ns1__FeedingDJInLaminatingByScadaDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, const char *tag, int id, ns1__FeedingDJInLaminatingByScadaDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO ? type : NULL);
}

SOAP_FMAC3 ns1__FeedingDJInLaminatingByScadaDTO ** SOAP_FMAC4 soap_in_PointerTons1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, const char *tag, ns1__FeedingDJInLaminatingByScadaDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FeedingDJInLaminatingByScadaDTO **)soap_malloc(soap, sizeof(ns1__FeedingDJInLaminatingByScadaDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FeedingDJInLaminatingByScadaDTO *)soap_instantiate_ns1__FeedingDJInLaminatingByScadaDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FeedingDJInLaminatingByScadaDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FeedingDJInLaminatingByScadaDTO, sizeof(ns1__FeedingDJInLaminatingByScadaDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, ns1__FeedingDJInLaminatingByScadaDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, tag ? tag : "ns1:FeedingDJInLaminatingByScadaDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FeedingDJInLaminatingByScadaDTO ** SOAP_FMAC4 soap_get_PointerTons1__FeedingDJInLaminatingByScadaDTO(struct soap *soap, ns1__FeedingDJInLaminatingByScadaDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FeedingDJInLaminatingByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FeedingByScadaDTO(struct soap *soap, ns1__FeedingByScadaDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FeedingByScadaDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FeedingByScadaDTO(struct soap *soap, const char *tag, int id, ns1__FeedingByScadaDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FeedingByScadaDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FeedingByScadaDTO ? type : NULL);
}

SOAP_FMAC3 ns1__FeedingByScadaDTO ** SOAP_FMAC4 soap_in_PointerTons1__FeedingByScadaDTO(struct soap *soap, const char *tag, ns1__FeedingByScadaDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FeedingByScadaDTO **)soap_malloc(soap, sizeof(ns1__FeedingByScadaDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FeedingByScadaDTO *)soap_instantiate_ns1__FeedingByScadaDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FeedingByScadaDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FeedingByScadaDTO, sizeof(ns1__FeedingByScadaDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FeedingByScadaDTO(struct soap *soap, ns1__FeedingByScadaDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FeedingByScadaDTO(soap, tag ? tag : "ns1:FeedingByScadaDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FeedingByScadaDTO ** SOAP_FMAC4 soap_get_PointerTons1__FeedingByScadaDTO(struct soap *soap, ns1__FeedingByScadaDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FeedingByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExamineExistsByScadaDTO(struct soap *soap, ns1__ExamineExistsByScadaDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExamineExistsByScadaDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExamineExistsByScadaDTO(struct soap *soap, const char *tag, int id, ns1__ExamineExistsByScadaDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ExamineExistsByScadaDTO ? type : NULL);
}

SOAP_FMAC3 ns1__ExamineExistsByScadaDTO ** SOAP_FMAC4 soap_in_PointerTons1__ExamineExistsByScadaDTO(struct soap *soap, const char *tag, ns1__ExamineExistsByScadaDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ExamineExistsByScadaDTO **)soap_malloc(soap, sizeof(ns1__ExamineExistsByScadaDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ExamineExistsByScadaDTO *)soap_instantiate_ns1__ExamineExistsByScadaDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ExamineExistsByScadaDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExamineExistsByScadaDTO, sizeof(ns1__ExamineExistsByScadaDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExamineExistsByScadaDTO(struct soap *soap, ns1__ExamineExistsByScadaDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ExamineExistsByScadaDTO(soap, tag ? tag : "ns1:ExamineExistsByScadaDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ExamineExistsByScadaDTO ** SOAP_FMAC4 soap_get_PointerTons1__ExamineExistsByScadaDTO(struct soap *soap, ns1__ExamineExistsByScadaDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExamineExistsByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, const char *tag, int id, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada **)soap_malloc(soap, sizeof(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *)soap_instantiate_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada, sizeof(ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag ? tag : "ns1:ApiResponseDataForScadaOfListOfApiResponseSFCForScada", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseDataForScadaOfListOfApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EquipmentProductProcessParam(struct soap *soap, ns1__EquipmentProductProcessParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EquipmentProductProcessParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EquipmentProductProcessParam(struct soap *soap, const char *tag, int id, ns1__EquipmentProductProcessParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EquipmentProductProcessParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__EquipmentProductProcessParam ? type : NULL);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParam ** SOAP_FMAC4 soap_in_PointerTons1__EquipmentProductProcessParam(struct soap *soap, const char *tag, ns1__EquipmentProductProcessParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EquipmentProductProcessParam **)soap_malloc(soap, sizeof(ns1__EquipmentProductProcessParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EquipmentProductProcessParam *)soap_instantiate_ns1__EquipmentProductProcessParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__EquipmentProductProcessParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EquipmentProductProcessParam, sizeof(ns1__EquipmentProductProcessParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EquipmentProductProcessParam(struct soap *soap, ns1__EquipmentProductProcessParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EquipmentProductProcessParam(soap, tag ? tag : "ns1:EquipmentProductProcessParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParam ** SOAP_FMAC4 soap_get_PointerTons1__EquipmentProductProcessParam(struct soap *soap, ns1__EquipmentProductProcessParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EquipmentProductProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EquipmentProcessParam(struct soap *soap, ns1__EquipmentProcessParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EquipmentProcessParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EquipmentProcessParam(struct soap *soap, const char *tag, int id, ns1__EquipmentProcessParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EquipmentProcessParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__EquipmentProcessParam ? type : NULL);
}

SOAP_FMAC3 ns1__EquipmentProcessParam ** SOAP_FMAC4 soap_in_PointerTons1__EquipmentProcessParam(struct soap *soap, const char *tag, ns1__EquipmentProcessParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EquipmentProcessParam **)soap_malloc(soap, sizeof(ns1__EquipmentProcessParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EquipmentProcessParam *)soap_instantiate_ns1__EquipmentProcessParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__EquipmentProcessParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EquipmentProcessParam, sizeof(ns1__EquipmentProcessParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EquipmentProcessParam(struct soap *soap, ns1__EquipmentProcessParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EquipmentProcessParam(soap, tag ? tag : "ns1:EquipmentProcessParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EquipmentProcessParam ** SOAP_FMAC4 soap_get_PointerTons1__EquipmentProcessParam(struct soap *soap, ns1__EquipmentProcessParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EquipmentProcessParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDownReason(struct soap *soap, ns1__ArrayOfDownReason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDownReason))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDownReason(struct soap *soap, const char *tag, int id, ns1__ArrayOfDownReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDownReason, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfDownReason ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfDownReason ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDownReason(struct soap *soap, const char *tag, ns1__ArrayOfDownReason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDownReason **)soap_malloc(soap, sizeof(ns1__ArrayOfDownReason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDownReason *)soap_instantiate_ns1__ArrayOfDownReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfDownReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDownReason, sizeof(ns1__ArrayOfDownReason), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDownReason(struct soap *soap, ns1__ArrayOfDownReason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfDownReason(soap, tag ? tag : "ns1:ArrayOfDownReason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDownReason ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDownReason(struct soap *soap, ns1__ArrayOfDownReason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCDFileUploadComplete(struct soap *soap, ns1__CCDFileUploadComplete *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CCDFileUploadComplete))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCDFileUploadComplete(struct soap *soap, const char *tag, int id, ns1__CCDFileUploadComplete *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CCDFileUploadComplete, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CCDFileUploadComplete ? type : NULL);
}

SOAP_FMAC3 ns1__CCDFileUploadComplete ** SOAP_FMAC4 soap_in_PointerTons1__CCDFileUploadComplete(struct soap *soap, const char *tag, ns1__CCDFileUploadComplete **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCDFileUploadComplete **)soap_malloc(soap, sizeof(ns1__CCDFileUploadComplete *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCDFileUploadComplete *)soap_instantiate_ns1__CCDFileUploadComplete(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCDFileUploadComplete **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CCDFileUploadComplete, sizeof(ns1__CCDFileUploadComplete), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCDFileUploadComplete(struct soap *soap, ns1__CCDFileUploadComplete *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCDFileUploadComplete(soap, tag ? tag : "ns1:CCDFileUploadComplete", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCDFileUploadComplete ** SOAP_FMAC4 soap_get_PointerTons1__CCDFileUploadComplete(struct soap *soap, ns1__CCDFileUploadComplete **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCDFileUploadComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BindSFCByScadaDTO(struct soap *soap, ns1__BindSFCByScadaDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BindSFCByScadaDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BindSFCByScadaDTO(struct soap *soap, const char *tag, int id, ns1__BindSFCByScadaDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BindSFCByScadaDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BindSFCByScadaDTO ? type : NULL);
}

SOAP_FMAC3 ns1__BindSFCByScadaDTO ** SOAP_FMAC4 soap_in_PointerTons1__BindSFCByScadaDTO(struct soap *soap, const char *tag, ns1__BindSFCByScadaDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BindSFCByScadaDTO **)soap_malloc(soap, sizeof(ns1__BindSFCByScadaDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BindSFCByScadaDTO *)soap_instantiate_ns1__BindSFCByScadaDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BindSFCByScadaDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BindSFCByScadaDTO, sizeof(ns1__BindSFCByScadaDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BindSFCByScadaDTO(struct soap *soap, ns1__BindSFCByScadaDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BindSFCByScadaDTO(soap, tag ? tag : "ns1:BindSFCByScadaDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BindSFCByScadaDTO ** SOAP_FMAC4 soap_get_PointerTons1__BindSFCByScadaDTO(struct soap *soap, ns1__BindSFCByScadaDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BindSFCByScadaDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BindContainer(struct soap *soap, ns1__BindContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BindContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BindContainer(struct soap *soap, const char *tag, int id, ns1__BindContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BindContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BindContainer ? type : NULL);
}

SOAP_FMAC3 ns1__BindContainer ** SOAP_FMAC4 soap_in_PointerTons1__BindContainer(struct soap *soap, const char *tag, ns1__BindContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BindContainer **)soap_malloc(soap, sizeof(ns1__BindContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BindContainer *)soap_instantiate_ns1__BindContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BindContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BindContainer, sizeof(ns1__BindContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BindContainer(struct soap *soap, ns1__BindContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BindContainer(soap, tag ? tag : "ns1:BindContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BindContainer ** SOAP_FMAC4 soap_get_PointerTons1__BindContainer(struct soap *soap, ns1__BindContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BindContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseForScada(struct soap *soap, ns1__ApiResponseForScada *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseForScada))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseForScada(struct soap *soap, const char *tag, int id, ns1__ApiResponseForScada *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseForScada, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseForScada ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseForScada ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseForScada(struct soap *soap, const char *tag, ns1__ApiResponseForScada **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseForScada **)soap_malloc(soap, sizeof(ns1__ApiResponseForScada *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseForScada *)soap_instantiate_ns1__ApiResponseForScada(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseForScada **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseForScada, sizeof(ns1__ApiResponseForScada), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseForScada(struct soap *soap, ns1__ApiResponseForScada *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseForScada(soap, tag ? tag : "ns1:ApiResponseForScada", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseForScada ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseForScada(struct soap *soap, ns1__ApiResponseForScada **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAlarm(struct soap *soap, ns1__ArrayOfAlarm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAlarm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAlarm(struct soap *soap, const char *tag, int id, ns1__ArrayOfAlarm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAlarm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfAlarm ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfAlarm ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAlarm(struct soap *soap, const char *tag, ns1__ArrayOfAlarm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAlarm **)soap_malloc(soap, sizeof(ns1__ArrayOfAlarm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAlarm *)soap_instantiate_ns1__ArrayOfAlarm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfAlarm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAlarm, sizeof(ns1__ArrayOfAlarm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAlarm(struct soap *soap, ns1__ArrayOfAlarm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfAlarm(soap, tag ? tag : "ns1:ArrayOfAlarm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAlarm ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAlarm(struct soap *soap, ns1__ArrayOfAlarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAlarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeListGetForEqu(struct soap *soap, ns1__RecipeListGetForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeListGetForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeListGetForEqu(struct soap *soap, const char *tag, int id, ns1__RecipeListGetForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeListGetForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeListGetForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeListGetForEqu ** SOAP_FMAC4 soap_in_PointerTons1__RecipeListGetForEqu(struct soap *soap, const char *tag, ns1__RecipeListGetForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeListGetForEqu **)soap_malloc(soap, sizeof(ns1__RecipeListGetForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeListGetForEqu *)soap_instantiate_ns1__RecipeListGetForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeListGetForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeListGetForEqu, sizeof(ns1__RecipeListGetForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeListGetForEqu(struct soap *soap, ns1__RecipeListGetForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeListGetForEqu(soap, tag ? tag : "ns1:RecipeListGetForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeListGetForEqu ** SOAP_FMAC4 soap_get_PointerTons1__RecipeListGetForEqu(struct soap *soap, ns1__RecipeListGetForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeListGetForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeGetParamForEqu(struct soap *soap, ns1__RecipeGetParamForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeGetParamForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeGetParamForEqu(struct soap *soap, const char *tag, int id, ns1__RecipeGetParamForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeGetParamForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeGetParamForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeGetParamForEqu ** SOAP_FMAC4 soap_in_PointerTons1__RecipeGetParamForEqu(struct soap *soap, const char *tag, ns1__RecipeGetParamForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeGetParamForEqu **)soap_malloc(soap, sizeof(ns1__RecipeGetParamForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeGetParamForEqu *)soap_instantiate_ns1__RecipeGetParamForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeGetParamForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeGetParamForEqu, sizeof(ns1__RecipeGetParamForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeGetParamForEqu(struct soap *soap, ns1__RecipeGetParamForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeGetParamForEqu(soap, tag ? tag : "ns1:RecipeGetParamForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeGetParamForEqu ** SOAP_FMAC4 soap_get_PointerTons1__RecipeGetParamForEqu(struct soap *soap, ns1__RecipeGetParamForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeGetParamForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfRecipeGetParamForEqu(struct soap *soap, ns1__ArrayOfRecipeGetParamForEqu *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfRecipeGetParamForEqu(struct soap *soap, const char *tag, int id, ns1__ArrayOfRecipeGetParamForEqu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfRecipeGetParamForEqu ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfRecipeGetParamForEqu(struct soap *soap, const char *tag, ns1__ArrayOfRecipeGetParamForEqu **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfRecipeGetParamForEqu **)soap_malloc(soap, sizeof(ns1__ArrayOfRecipeGetParamForEqu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfRecipeGetParamForEqu *)soap_instantiate_ns1__ArrayOfRecipeGetParamForEqu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfRecipeGetParamForEqu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfRecipeGetParamForEqu, sizeof(ns1__ArrayOfRecipeGetParamForEqu), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfRecipeGetParamForEqu(struct soap *soap, ns1__ArrayOfRecipeGetParamForEqu *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, tag ? tag : "ns1:ArrayOfRecipeGetParamForEqu", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfRecipeGetParamForEqu ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfRecipeGetParamForEqu(struct soap *soap, ns1__ArrayOfRecipeGetParamForEqu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfRecipeGetParamForEqu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipeParam(struct soap *soap, ns1__RecipeParam *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipeParam))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipeParam(struct soap *soap, const char *tag, int id, ns1__RecipeParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RecipeParam, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RecipeParam ? type : NULL);
}

SOAP_FMAC3 ns1__RecipeParam ** SOAP_FMAC4 soap_in_PointerTons1__RecipeParam(struct soap *soap, const char *tag, ns1__RecipeParam **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RecipeParam **)soap_malloc(soap, sizeof(ns1__RecipeParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RecipeParam *)soap_instantiate_ns1__RecipeParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipeParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RecipeParam, sizeof(ns1__RecipeParam), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipeParam(struct soap *soap, ns1__RecipeParam *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RecipeParam(soap, tag ? tag : "ns1:RecipeParam", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RecipeParam ** SOAP_FMAC4 soap_get_PointerTons1__RecipeParam(struct soap *soap, ns1__RecipeParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipeParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfString ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfString(soap, tag ? tag : "ns1:ArrayOfString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OutboundSFC(struct soap *soap, ns1__OutboundSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OutboundSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OutboundSFC(struct soap *soap, const char *tag, int id, ns1__OutboundSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OutboundSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OutboundSFC ? type : NULL);
}

SOAP_FMAC3 ns1__OutboundSFC ** SOAP_FMAC4 soap_in_PointerTons1__OutboundSFC(struct soap *soap, const char *tag, ns1__OutboundSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OutboundSFC **)soap_malloc(soap, sizeof(ns1__OutboundSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OutboundSFC *)soap_instantiate_ns1__OutboundSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OutboundSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OutboundSFC, sizeof(ns1__OutboundSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OutboundSFC(struct soap *soap, ns1__OutboundSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OutboundSFC(soap, tag ? tag : "ns1:OutboundSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OutboundSFC ** SOAP_FMAC4 soap_get_PointerTons1__OutboundSFC(struct soap *soap, ns1__OutboundSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OutboundSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseSFCForScada *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApiResponseSFCForScada))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApiResponseSFCForScada(struct soap *soap, const char *tag, int id, ns1__ApiResponseSFCForScada *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApiResponseSFCForScada, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApiResponseSFCForScada ? type : NULL);
}

SOAP_FMAC3 ns1__ApiResponseSFCForScada ** SOAP_FMAC4 soap_in_PointerTons1__ApiResponseSFCForScada(struct soap *soap, const char *tag, ns1__ApiResponseSFCForScada **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApiResponseSFCForScada **)soap_malloc(soap, sizeof(ns1__ApiResponseSFCForScada *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApiResponseSFCForScada *)soap_instantiate_ns1__ApiResponseSFCForScada(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApiResponseSFCForScada **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApiResponseSFCForScada, sizeof(ns1__ApiResponseSFCForScada), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseSFCForScada *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApiResponseSFCForScada(soap, tag ? tag : "ns1:ApiResponseSFCForScada", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApiResponseSFCForScada ** SOAP_FMAC4 soap_get_PointerTons1__ApiResponseSFCForScada(struct soap *soap, ns1__ApiResponseSFCForScada **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApiResponseSFCForScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfParamDTO(struct soap *soap, ns1__ArrayOfParamDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfParamDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfParamDTO(struct soap *soap, const char *tag, int id, ns1__ArrayOfParamDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfParamDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfParamDTO ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfParamDTO ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfParamDTO(struct soap *soap, const char *tag, ns1__ArrayOfParamDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfParamDTO **)soap_malloc(soap, sizeof(ns1__ArrayOfParamDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfParamDTO *)soap_instantiate_ns1__ArrayOfParamDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfParamDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfParamDTO, sizeof(ns1__ArrayOfParamDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfParamDTO(struct soap *soap, ns1__ArrayOfParamDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfParamDTO(soap, tag ? tag : "ns1:ArrayOfParamDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfParamDTO ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfParamDTO(struct soap *soap, ns1__ArrayOfParamDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfParamDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, ns1__EquipmentProductProcessParamSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, int id, ns1__EquipmentProductProcessParamSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__EquipmentProductProcessParamSFC ? type : NULL);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParamSFC ** SOAP_FMAC4 soap_in_PointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, ns1__EquipmentProductProcessParamSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EquipmentProductProcessParamSFC **)soap_malloc(soap, sizeof(ns1__EquipmentProductProcessParamSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EquipmentProductProcessParamSFC *)soap_instantiate_ns1__EquipmentProductProcessParamSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__EquipmentProductProcessParamSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, sizeof(ns1__EquipmentProductProcessParamSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, ns1__EquipmentProductProcessParamSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EquipmentProductProcessParamSFC(soap, tag ? tag : "ns1:EquipmentProductProcessParamSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EquipmentProductProcessParamSFC ** SOAP_FMAC4 soap_get_PointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, ns1__EquipmentProductProcessParamSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ParamDTO(struct soap *soap, ns1__ParamDTO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ParamDTO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ParamDTO(struct soap *soap, const char *tag, int id, ns1__ParamDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ParamDTO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ParamDTO ? type : NULL);
}

SOAP_FMAC3 ns1__ParamDTO ** SOAP_FMAC4 soap_in_PointerTons1__ParamDTO(struct soap *soap, const char *tag, ns1__ParamDTO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ParamDTO **)soap_malloc(soap, sizeof(ns1__ParamDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ParamDTO *)soap_instantiate_ns1__ParamDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ParamDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ParamDTO, sizeof(ns1__ParamDTO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ParamDTO(struct soap *soap, ns1__ParamDTO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ParamDTO(soap, tag ? tag : "ns1:ParamDTO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ParamDTO ** SOAP_FMAC4 soap_get_PointerTons1__ParamDTO(struct soap *soap, ns1__ParamDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ParamDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DownReason(struct soap *soap, ns1__DownReason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DownReason))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DownReason(struct soap *soap, const char *tag, int id, ns1__DownReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DownReason, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DownReason ? type : NULL);
}

SOAP_FMAC3 ns1__DownReason ** SOAP_FMAC4 soap_in_PointerTons1__DownReason(struct soap *soap, const char *tag, ns1__DownReason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DownReason **)soap_malloc(soap, sizeof(ns1__DownReason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DownReason *)soap_instantiate_ns1__DownReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DownReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DownReason, sizeof(ns1__DownReason), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DownReason(struct soap *soap, ns1__DownReason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DownReason(soap, tag ? tag : "ns1:DownReason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DownReason ** SOAP_FMAC4 soap_get_PointerTons1__DownReason(struct soap *soap, ns1__DownReason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DownReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, ns1__CCDFileUploadCompleteSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, int id, ns1__CCDFileUploadCompleteSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CCDFileUploadCompleteSFC ? type : NULL);
}

SOAP_FMAC3 ns1__CCDFileUploadCompleteSFC ** SOAP_FMAC4 soap_in_PointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, ns1__CCDFileUploadCompleteSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCDFileUploadCompleteSFC **)soap_malloc(soap, sizeof(ns1__CCDFileUploadCompleteSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCDFileUploadCompleteSFC *)soap_instantiate_ns1__CCDFileUploadCompleteSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCDFileUploadCompleteSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, sizeof(ns1__CCDFileUploadCompleteSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, ns1__CCDFileUploadCompleteSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCDFileUploadCompleteSFC(soap, tag ? tag : "ns1:CCDFileUploadCompleteSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCDFileUploadCompleteSFC ** SOAP_FMAC4 soap_get_PointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, ns1__CCDFileUploadCompleteSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BindContainerSFC(struct soap *soap, ns1__BindContainerSFC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BindContainerSFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BindContainerSFC(struct soap *soap, const char *tag, int id, ns1__BindContainerSFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BindContainerSFC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BindContainerSFC ? type : NULL);
}

SOAP_FMAC3 ns1__BindContainerSFC ** SOAP_FMAC4 soap_in_PointerTons1__BindContainerSFC(struct soap *soap, const char *tag, ns1__BindContainerSFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BindContainerSFC **)soap_malloc(soap, sizeof(ns1__BindContainerSFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BindContainerSFC *)soap_instantiate_ns1__BindContainerSFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BindContainerSFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BindContainerSFC, sizeof(ns1__BindContainerSFC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BindContainerSFC(struct soap *soap, ns1__BindContainerSFC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BindContainerSFC(soap, tag ? tag : "ns1:BindContainerSFC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BindContainerSFC ** SOAP_FMAC4 soap_get_PointerTons1__BindContainerSFC(struct soap *soap, ns1__BindContainerSFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BindContainerSFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_new_wstring(struct soap *soap, int n)
{
	wchar_t * *a = static_cast<wchar_t * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(wchar_t *)));
	for (wchar_t * *p = a; p && n--; ++p)
		soap_default_wstring(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_wstring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Alarm(struct soap *soap, ns1__Alarm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Alarm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Alarm(struct soap *soap, const char *tag, int id, ns1__Alarm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Alarm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Alarm ? type : NULL);
}

SOAP_FMAC3 ns1__Alarm ** SOAP_FMAC4 soap_in_PointerTons1__Alarm(struct soap *soap, const char *tag, ns1__Alarm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Alarm **)soap_malloc(soap, sizeof(ns1__Alarm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Alarm *)soap_instantiate_ns1__Alarm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Alarm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Alarm, sizeof(ns1__Alarm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Alarm(struct soap *soap, ns1__Alarm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Alarm(soap, tag ? tag : "ns1:Alarm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Alarm ** SOAP_FMAC4 soap_get_PointerTons1__Alarm(struct soap *soap, ns1__Alarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Alarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(struct soap *soap, std::vector<ns1__RecipeListGetForEqu *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(struct soap *soap, const std::vector<ns1__RecipeListGetForEqu *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RecipeListGetForEqu *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RecipeListGetForEqu(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(struct soap *soap, const char *tag, int id, const std::vector<ns1__RecipeListGetForEqu *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RecipeListGetForEqu *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RecipeListGetForEqu(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RecipeListGetForEqu *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(struct soap *soap, const char *tag, std::vector<ns1__RecipeListGetForEqu *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RecipeListGetForEqu *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RecipeListGetForEqu, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu, sizeof(ns1__RecipeListGetForEqu), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RecipeListGetForEqu(soap, tag, NULL, "ns1:RecipeListGetForEqu"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RecipeListGetForEqu(soap, tag, &n, "ns1:RecipeListGetForEqu"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RecipeListGetForEqu *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RecipeListGetForEqu *> *p;
	size_t k = sizeof(std::vector<ns1__RecipeListGetForEqu *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeListGetForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RecipeListGetForEqu *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RecipeListGetForEqu *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RecipeListGetForEqu *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(struct soap *soap, std::vector<ns1__RecipeGetParamForEqu *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(struct soap *soap, const std::vector<ns1__RecipeGetParamForEqu *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RecipeGetParamForEqu *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RecipeGetParamForEqu(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(struct soap *soap, const char *tag, int id, const std::vector<ns1__RecipeGetParamForEqu *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RecipeGetParamForEqu *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RecipeGetParamForEqu(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RecipeGetParamForEqu *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(struct soap *soap, const char *tag, std::vector<ns1__RecipeGetParamForEqu *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RecipeGetParamForEqu *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RecipeGetParamForEqu, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu, sizeof(ns1__RecipeGetParamForEqu), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RecipeGetParamForEqu(soap, tag, NULL, "ns1:RecipeGetParamForEqu"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RecipeGetParamForEqu(soap, tag, &n, "ns1:RecipeGetParamForEqu"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RecipeGetParamForEqu *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RecipeGetParamForEqu *> *p;
	size_t k = sizeof(std::vector<ns1__RecipeGetParamForEqu *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeGetParamForEqu, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RecipeGetParamForEqu *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RecipeGetParamForEqu *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RecipeGetParamForEqu *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__RecipeParam(struct soap *soap, std::vector<ns1__RecipeParam *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__RecipeParam(struct soap *soap, const std::vector<ns1__RecipeParam *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__RecipeParam *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__RecipeParam(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__RecipeParam(struct soap *soap, const char *tag, int id, const std::vector<ns1__RecipeParam *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__RecipeParam *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__RecipeParam(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__RecipeParam *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__RecipeParam(struct soap *soap, const char *tag, std::vector<ns1__RecipeParam *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__RecipeParam(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__RecipeParam *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__RecipeParam, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam, sizeof(ns1__RecipeParam), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__RecipeParam(soap, tag, NULL, "ns1:RecipeParam"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__RecipeParam(soap, tag, &n, "ns1:RecipeParam"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__RecipeParam *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__RecipeParam(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__RecipeParam *> *p;
	size_t k = sizeof(std::vector<ns1__RecipeParam *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__RecipeParam, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__RecipeParam *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__RecipeParam *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__RecipeParam *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__OutboundSFC(struct soap *soap, std::vector<ns1__OutboundSFC *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__OutboundSFC(struct soap *soap, const std::vector<ns1__OutboundSFC *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__OutboundSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__OutboundSFC(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__OutboundSFC(struct soap *soap, const char *tag, int id, const std::vector<ns1__OutboundSFC *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__OutboundSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__OutboundSFC(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__OutboundSFC *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__OutboundSFC(struct soap *soap, const char *tag, std::vector<ns1__OutboundSFC *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__OutboundSFC(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__OutboundSFC *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__OutboundSFC, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC, sizeof(ns1__OutboundSFC), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__OutboundSFC(soap, tag, NULL, "ns1:OutboundSFC"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__OutboundSFC(soap, tag, &n, "ns1:OutboundSFC"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__OutboundSFC *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__OutboundSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__OutboundSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__OutboundSFC *> *p;
	size_t k = sizeof(std::vector<ns1__OutboundSFC *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OutboundSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__OutboundSFC *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__OutboundSFC *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__OutboundSFC *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(struct soap *soap, std::vector<ns1__ApiResponseSFCForScada *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(struct soap *soap, const std::vector<ns1__ApiResponseSFCForScada *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ApiResponseSFCForScada *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ApiResponseSFCForScada(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(struct soap *soap, const char *tag, int id, const std::vector<ns1__ApiResponseSFCForScada *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ApiResponseSFCForScada *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ApiResponseSFCForScada(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ApiResponseSFCForScada *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(struct soap *soap, const char *tag, std::vector<ns1__ApiResponseSFCForScada *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ApiResponseSFCForScada *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ApiResponseSFCForScada, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada, sizeof(ns1__ApiResponseSFCForScada), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ApiResponseSFCForScada(soap, tag, NULL, "ns1:ApiResponseSFCForScada"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ApiResponseSFCForScada(soap, tag, &n, "ns1:ApiResponseSFCForScada"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ApiResponseSFCForScada *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ApiResponseSFCForScada *> *p;
	size_t k = sizeof(std::vector<ns1__ApiResponseSFCForScada *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ApiResponseSFCForScada, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ApiResponseSFCForScada *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ApiResponseSFCForScada *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ApiResponseSFCForScada *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, std::vector<ns1__EquipmentProductProcessParamSFC *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, const std::vector<ns1__EquipmentProductProcessParamSFC *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__EquipmentProductProcessParamSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__EquipmentProductProcessParamSFC(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, int id, const std::vector<ns1__EquipmentProductProcessParamSFC *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__EquipmentProductProcessParamSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__EquipmentProductProcessParamSFC *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, const char *tag, std::vector<ns1__EquipmentProductProcessParamSFC *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__EquipmentProductProcessParamSFC *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__EquipmentProductProcessParamSFC, SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC, sizeof(ns1__EquipmentProductProcessParamSFC), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, NULL, "ns1:EquipmentProductProcessParamSFC"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__EquipmentProductProcessParamSFC(soap, tag, &n, "ns1:EquipmentProductProcessParamSFC"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__EquipmentProductProcessParamSFC *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__EquipmentProductProcessParamSFC *> *p;
	size_t k = sizeof(std::vector<ns1__EquipmentProductProcessParamSFC *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__EquipmentProductProcessParamSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__EquipmentProductProcessParamSFC *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__EquipmentProductProcessParamSFC *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__EquipmentProductProcessParamSFC *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ParamDTO(struct soap *soap, std::vector<ns1__ParamDTO *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ParamDTO(struct soap *soap, const std::vector<ns1__ParamDTO *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ParamDTO *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ParamDTO(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ParamDTO(struct soap *soap, const char *tag, int id, const std::vector<ns1__ParamDTO *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ParamDTO *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ParamDTO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ParamDTO *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ParamDTO(struct soap *soap, const char *tag, std::vector<ns1__ParamDTO *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ParamDTO(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ParamDTO *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ParamDTO, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO, sizeof(ns1__ParamDTO), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ParamDTO(soap, tag, NULL, "ns1:ParamDTO"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ParamDTO(soap, tag, &n, "ns1:ParamDTO"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ParamDTO *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ParamDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ParamDTO(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ParamDTO *> *p;
	size_t k = sizeof(std::vector<ns1__ParamDTO *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ParamDTO, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ParamDTO *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ParamDTO *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ParamDTO *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DownReason(struct soap *soap, std::vector<ns1__DownReason *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DownReason(struct soap *soap, const std::vector<ns1__DownReason *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DownReason *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DownReason(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DownReason(struct soap *soap, const char *tag, int id, const std::vector<ns1__DownReason *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DownReason *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DownReason(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DownReason *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DownReason(struct soap *soap, const char *tag, std::vector<ns1__DownReason *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DownReason(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DownReason *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DownReason, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason, sizeof(ns1__DownReason), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DownReason(soap, tag, NULL, "ns1:DownReason"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DownReason(soap, tag, &n, "ns1:DownReason"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DownReason *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DownReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DownReason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DownReason *> *p;
	size_t k = sizeof(std::vector<ns1__DownReason *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DownReason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DownReason *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DownReason *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DownReason *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, std::vector<ns1__CCDFileUploadCompleteSFC *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, const std::vector<ns1__CCDFileUploadCompleteSFC *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__CCDFileUploadCompleteSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__CCDFileUploadCompleteSFC(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, int id, const std::vector<ns1__CCDFileUploadCompleteSFC *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__CCDFileUploadCompleteSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__CCDFileUploadCompleteSFC *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, const char *tag, std::vector<ns1__CCDFileUploadCompleteSFC *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__CCDFileUploadCompleteSFC *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__CCDFileUploadCompleteSFC, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC, sizeof(ns1__CCDFileUploadCompleteSFC), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, NULL, "ns1:CCDFileUploadCompleteSFC"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__CCDFileUploadCompleteSFC(soap, tag, &n, "ns1:CCDFileUploadCompleteSFC"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__CCDFileUploadCompleteSFC *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__CCDFileUploadCompleteSFC *> *p;
	size_t k = sizeof(std::vector<ns1__CCDFileUploadCompleteSFC *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CCDFileUploadCompleteSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__CCDFileUploadCompleteSFC *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__CCDFileUploadCompleteSFC *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__CCDFileUploadCompleteSFC *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__wstring(struct soap *soap, std::vector<std::wstring> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__wstring(struct soap *soap, const std::vector<std::wstring> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, int id, const std::vector<std::wstring> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::wstring> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__wstring(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, std::vector<std::wstring> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__wstring(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::wstring n;
		soap_default_std__wstring(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__wstring, SOAP_TYPE_std__vectorTemplateOfstd__wstring, sizeof(std::wstring), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__wstring(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::wstring));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::wstring));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::wstring));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__wstring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::wstring> *p;
	size_t k = sizeof(std::vector<std::wstring> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__wstring, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::wstring> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::wstring> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::wstring>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BindContainerSFC(struct soap *soap, std::vector<ns1__BindContainerSFC *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BindContainerSFC(struct soap *soap, const std::vector<ns1__BindContainerSFC *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__BindContainerSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BindContainerSFC(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BindContainerSFC(struct soap *soap, const char *tag, int id, const std::vector<ns1__BindContainerSFC *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__BindContainerSFC *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BindContainerSFC(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BindContainerSFC *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BindContainerSFC(struct soap *soap, const char *tag, std::vector<ns1__BindContainerSFC *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BindContainerSFC(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__BindContainerSFC *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__BindContainerSFC, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC, sizeof(ns1__BindContainerSFC), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__BindContainerSFC(soap, tag, NULL, "ns1:BindContainerSFC"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__BindContainerSFC(soap, tag, &n, "ns1:BindContainerSFC"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__BindContainerSFC *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__BindContainerSFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BindContainerSFC(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__BindContainerSFC *> *p;
	size_t k = sizeof(std::vector<ns1__BindContainerSFC *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BindContainerSFC, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__BindContainerSFC *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__BindContainerSFC *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__BindContainerSFC *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Alarm(struct soap *soap, std::vector<ns1__Alarm *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Alarm(struct soap *soap, const std::vector<ns1__Alarm *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Alarm *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Alarm(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Alarm(struct soap *soap, const char *tag, int id, const std::vector<ns1__Alarm *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Alarm *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Alarm(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Alarm *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Alarm(struct soap *soap, const char *tag, std::vector<ns1__Alarm *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Alarm(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Alarm *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Alarm, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm, sizeof(ns1__Alarm), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Alarm(soap, tag, NULL, "ns1:Alarm"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Alarm(soap, tag, &n, "ns1:Alarm"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Alarm *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Alarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Alarm *> *p;
	size_t k = sizeof(std::vector<ns1__Alarm *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Alarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Alarm *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Alarm *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Alarm *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
