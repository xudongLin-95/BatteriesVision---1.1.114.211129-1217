///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "DH_HalconEx.h"
#include <direct.h>

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 


void TupleExceptRepeat(const HTuple& src,HTuple* dst)
{
	HTuple TempTuple = HTuple();
	for (int i=0;i<src.Length();i++)
	{
		BOOL bExist = FALSE;
		for (int j=0;j<TempTuple.Length();j++)
		{
			if (TempTuple[j] == src[i])
			{
				bExist = TRUE;
			}
		}
		if (!bExist)
		{
			TempTuple.Append(src[i]);
		}
	}
	dst->Clear();
	dst->Append(TempTuple);
}

void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
	HTuple *hv_Directory)
{

	// Local control variables
	HTuple  hv_DirectoryTmp, hv_Substring;

	//This procedure gets a filename (with full path) as input
	//and returns the directory path, the base filename and the extension
	//in three different strings.
	//
	//In the output path the path separators will be replaced
	//by '/' in all cases.
	//
	//The procedure shows the possibilities of regular expressions in HALCON.
	//
	//Input parameters:
	//FileName: The input filename
	//
	//Output parameters:
	//BaseName: The filename without directory description and file extension
	//Extension: The file extension
	//Directory: The directory path
	//
	//Example:
	//basename('C:/images/part_01.png',...) returns
	//BaseName = 'part_01'
	//Extension = 'png'
	//Directory = 'C:\\images\\' (on Windows systems)
	//
	//Explanation of the regular expressions:
	//
	//'([^\\\\/]*?)(?:\\.[^.]*)?$':
	//To start at the end, the '$' matches the end of the string,
	//so it is best to read the expression from right to left.
	//The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
	//That means, that this part is matched, but not captured
	//in contrast to the first bracketed group ([^\\\\/], see below.)
	//\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
	//So (?:\\.[^.]*)? matches the file extension, if any.
	//The '?' at the end assures, that even if no extension exists,
	//a correct match is returned.
	//The first part in brackets ([^\\\\/]*?) is a capture group,
	//which means, that if a match is found, only the part in
	//brackets is returned as a result.
	//Because both HDevelop strings and regular expressions need a '\\'
	//to describe a backslash, inside regular expressions within HDevelop
	//a backslash has to be written as '\\\\'.
	//[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
	//[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
	//where the '?' after the '*' switches the greediness off,
	//that means, that the shortest possible match is returned.
	//This option is necessary to cut off the extension
	//but only if (?:\\.[^.]*)? is able to match one.
	//To summarize, the regular expression matches that part of
	//the input string, that follows after the last '/' or '\\' and
	//cuts off the extension (if any) after the last '.'.
	//
	//'\\.([^.]*)$':
	//This matches everything after the last '.' of the input string.
	//Because ([^.]) is a capturing group,
	//only the part after the dot is returned.
	//
	//'.*[\\\\/]':
	//This matches the longest substring with a '/' or a '\\' at the end.
	//
	TupleRegexpMatch(hv_FileName, ".*[\\\\/]", &hv_DirectoryTmp);
	TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen())-1, 
		&hv_Substring);
	TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", &(*hv_BaseName));
	TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", &(*hv_Extension));
	//
	//
	//Finally all found backslashes ('\\') are converted
	//to a slash to get consistent paths
	TupleRegexpReplace(hv_DirectoryTmp, (HTuple("\\\\").Append("replace_all")), "/", 
		&(*hv_Directory));
	return;
}

void TupleCountExceptRepeat(const HTuple& srcErrorType,const HTuple& srcBelongStrip,HTuple* dstErrorType,HTuple* dstBelongStrip)
{
	HTuple hvErrorType = HTuple();
	HTuple hvBelongStrip = HTuple();

	for (int i=0;i<srcBelongStrip.Length();i++)
	{
		BOOL bExist = FALSE;
		for (int j=0;j<hvBelongStrip.Length();j++)
		{
			if (hvBelongStrip[j] == srcBelongStrip[i])
			{
				bExist = TRUE;
			}
		}
		if (!bExist)
		{
			hvBelongStrip.Append(srcBelongStrip[i]);
			hvErrorType.Append(srcErrorType[i]);
		}
	}
	dstErrorType->Clear();
	dstErrorType->Append(hvErrorType);
	dstBelongStrip->Clear();
	dstBelongStrip->Append(hvBelongStrip);
}

DHInterface* LoadDHInterFaceDll(CString strDllName)
{
	CString strDll;
	strDll.Format("%s\\%s.dll",GetCurrentAppPath(),strDllName);
	HINSTANCE hDllLog = ::LoadLibrary(_T(strDll));
	if (hDllLog == NULL)
	{
		CString strMessage;
		strMessage.Format("Load %s.dll exceptional.\r\n加载%s.dll异常",strDllName,strDllName);
		AfxMessageBox(strMessage);
		::FreeLibrary(hDllLog);
		return NULL;
	}
	typedef DHInterface*(*pExport)(void);
	pExport Create;
	Create= (pExport)GetProcAddress(hDllLog,"Export");
	if(Create == NULL)
	{
		CString strMessage;
		strMessage.Format("Error to get functions from %s.dll.\r\n%s.dll获得函数地址报错",strDllName,strDllName);
		AfxMessageBox(strMessage);
		::FreeLibrary(hDllLog);
		return NULL;
	}
	return Create();
}

void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}


void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
	HTuple *hv_ImageFiles)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_HalconImages, hv_OS, hv_Directories;
	HTuple  hv_Index, hv_Length, hv_network_drive, hv_Substring;
	HTuple  hv_FileExists, hv_AllFiles, hv_i, hv_Selection;

	//This procedure returns all files in a given directory
	//with one of the suffixes specified in Extensions.
	//
	//input parameters:
	//ImageDirectory: as the name says
	//   If a tuple of directories is given, only the images in the first
	//   existing directory are returned.
	//   If a local directory is not found, the directory is searched
	//   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
	//   %HALCONROOT%/images is used instead.
	//Extensions: A string tuple containing the extensions to be found
	//   e.g. ['png','tif',jpg'] or others
	//If Extensions is set to 'default' or the empty string '',
	//   all image suffixes supported by HALCON are used.
	//Options: as in the operator list_files, except that the 'files'
	//   option is always used. Note that the 'directories' option
	//   has no effect but increases runtime, because only files are
	//   returned.
	//
	//output parameter:
	//ImageFiles: A tuple of all found image file names
	//
	if (0 != (HTuple(HTuple(hv_Extensions==HTuple()).TupleOr(hv_Extensions==HTuple(""))).TupleOr(hv_Extensions==HTuple("default"))))
	{
		hv_Extensions.Clear();
		hv_Extensions[0] = "ima";
		hv_Extensions[1] = "tif";
		hv_Extensions[2] = "tiff";
		hv_Extensions[3] = "gif";
		hv_Extensions[4] = "bmp";
		hv_Extensions[5] = "jpg";
		hv_Extensions[6] = "jpeg";
		hv_Extensions[7] = "jp2";
		hv_Extensions[8] = "jxr";
		hv_Extensions[9] = "png";
		hv_Extensions[10] = "pcx";
		hv_Extensions[11] = "ras";
		hv_Extensions[12] = "xwd";
		hv_Extensions[13] = "pbm";
		hv_Extensions[14] = "pnm";
		hv_Extensions[15] = "pgm";
		hv_Extensions[16] = "ppm";
		//
	}
	if (0 != (hv_ImageDirectory==HTuple("")))
	{
		hv_ImageDirectory = ".";
	}
	GetSystem("image_dir", &hv_HalconImages);
	GetSystem("operating_system", &hv_OS);
	if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
	{
		hv_HalconImages = hv_HalconImages.TupleSplit(";");
	}
	else
	{
		hv_HalconImages = hv_HalconImages.TupleSplit(":");
	}
	hv_Directories = hv_ImageDirectory;
	{
		HTuple end_val37 = (hv_HalconImages.TupleLength())-1;
		HTuple step_val37 = 1;
		for (hv_Index=0; hv_Index.Continue(end_val37, step_val37); hv_Index += step_val37)
		{
			hv_Directories = hv_Directories.TupleConcat((HTuple(hv_HalconImages[hv_Index])+"/")+hv_ImageDirectory);
		}
	}
	TupleStrlen(hv_Directories, &hv_Length);
	TupleGenConst(hv_Length.TupleLength(), 0, &hv_network_drive);
	if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
	{
		{
			HTuple end_val43 = (hv_Length.TupleLength())-1;
			HTuple step_val43 = 1;
			for (hv_Index=0; hv_Index.Continue(end_val43, step_val43); hv_Index += step_val43)
			{
				if (0 != ((HTuple(hv_Directories[hv_Index]).TupleStrlen())>1))
				{
					TupleStrFirstN(HTuple(hv_Directories[hv_Index]), 1, &hv_Substring);
					if (0 != (hv_Substring==HTuple("//")))
					{
						hv_network_drive[hv_Index] = 1;
					}
				}
			}
		}
	}
	(*hv_ImageFiles) = HTuple();
	{
		HTuple end_val53 = (hv_Directories.TupleLength())-1;
		HTuple step_val53 = 1;
		for (hv_Index=0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
		{
			FileExists(HTuple(hv_Directories[hv_Index]), &hv_FileExists);
			if (0 != hv_FileExists)
			{
				ListFiles(HTuple(hv_Directories[hv_Index]), HTuple("files").TupleConcat(hv_Options), 
					&hv_AllFiles);
				(*hv_ImageFiles) = HTuple();
				{
					HTuple end_val58 = (hv_Extensions.TupleLength())-1;
					HTuple step_val58 = 1;
					for (hv_i=0; hv_i.Continue(end_val58, step_val58); hv_i += step_val58)
					{
						TupleRegexpSelect(hv_AllFiles, ((".*"+HTuple(hv_Extensions[hv_i]))+"$").TupleConcat("ignore_case"), 
							&hv_Selection);
						(*hv_ImageFiles) = (*hv_ImageFiles).TupleConcat(hv_Selection);
					}
				}
				TupleRegexpReplace((*hv_ImageFiles), (HTuple("\\\\").Append("replace_all")), 
					"/", &(*hv_ImageFiles));
				if (0 != (HTuple(hv_network_drive[hv_Index])))
				{
					TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
						"/", &(*hv_ImageFiles));
					(*hv_ImageFiles) = "/"+(*hv_ImageFiles);
				}
				else
				{
					TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
						"/", &(*hv_ImageFiles));
				}
				return;
			}
		}
	}
	return;
}



// Local procedures 
void FastSortFileNames (HTuple hv_DirName, HTuple *hv_SortedFileNames)
{

  // Local control variables
  HTuple  hv_Length, hv_Last, hv_ImageFiles, hv_FileNameLength;
  HTuple  hv_DirNameLength, hv_FileCount, hv_Newtuple, hv_Substring;
  HTuple  hv_Number, hv_Sorted, hv_Dir, hv_Sum;

  TupleStrlen(hv_DirName, &hv_Length);
  TupleStrLastN(hv_DirName, hv_Length-1, &hv_Last);
  if (0 != (hv_Last!=HTuple("/")))
  {
   // TupleAdd(hv_DirName, "/", &hv_DirName);
  }


  list_image_files(hv_DirName, "hobj", HTuple(), &hv_ImageFiles);
  TupleStrlen(hv_ImageFiles, &hv_FileNameLength);
  TupleStrlen(hv_DirName, &hv_DirNameLength);
  TupleLength(hv_FileNameLength, &hv_FileCount);
  TupleGenConst(hv_FileCount, hv_DirNameLength, &hv_Newtuple);
  TupleSubstr(hv_ImageFiles, hv_Newtuple, hv_FileNameLength-6, &hv_Substring);
  TupleNumber(hv_Substring, &hv_Number);
  TupleSort(hv_Number, &hv_Sorted);
  TupleGenConst(hv_FileCount, hv_DirName, &hv_Dir);
  TupleAdd(hv_Dir, hv_Sorted, &hv_Sum);
  TupleAdd(hv_Sum, ".hobj", &(*hv_SortedFileNames));
  return;

}
void dev_open_window_fit_image (HObject ho_Image,const CStatic &IpWinStatic, HTuple *hv_WindowHandle)
{
	CRect       rect;	
	Hlong hwnd = (Hlong)IpWinStatic.m_hWnd;
	IpWinStatic.GetClientRect(&rect);
	try
	{
		HTuple Width,Height;
		GetImageSize(ho_Image,&Width,&Height);
		SetCheck("~father");
		OpenWindow(0,0,rect.Width(),rect.Height(),
			(Hlong)IpWinStatic.m_hWnd,"visible","",hv_WindowHandle);
		
		SetCheck("father");
		SetPart(*hv_WindowHandle,0,0,Height-1,Width-1);
		set_display_font(*hv_WindowHandle, 16, "mono", "true", "false");
		SetDraw(*hv_WindowHandle, "margin");
		SetColor(*hv_WindowHandle, "red");

	}catch(HException e)
	{
		AfxMessageBox(e.ErrorMessage().Text());
	}
}
// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContinueMessage, hv_Row, hv_Column;
  HTuple  hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight;

  //This procedure displays 'Press Run (F5) to continue' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  hv_ContinueMessage = "Press Run (F5) to continue";
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
      (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_BufferWindowHandle, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_Scale, hv_Exception;
  HTuple  hv_SubFamily, hv_Fonts, hv_SystemFonts, hv_Guess;
  HTuple  hv_I, hv_Index, hv_AllowedFontSizes, hv_Distances;
  HTuple  hv_Indices, hv_FontSelRegexp, hv_FontsCourier;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Set font on Windows systems
    try
    {
      //Check, if font scaling is switched on
      OpenWindow(0, 0, 256, 256, 0, "buffer", "", &hv_BufferWindowHandle);
      SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
      GetStringExtents(hv_BufferWindowHandle, "test_string", &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      //Expected width is 110
      hv_Scale = 110.0/hv_Width;
      hv_Size = (hv_Size*hv_Scale).TupleInt();
      CloseWindow(hv_BufferWindowHandle);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
    if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Font = "Courier New";
    }
    else if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Font = "Consolas";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "Times New Roman";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = 1;
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_Slant = 1;
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-"+hv_Font)+"-")+hv_Size)+"-*-")+hv_Slant)+"-*-*-")+hv_Bold)+"-");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Dar")))
  {
    //Set font on Mac OS X systems. Since OS X does not have a strict naming
    //scheme for font attributes, we use tables to determine the correct font
    //name.
    hv_SubFamily = 0;
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|1;
    }
    else if (0 != (hv_Slant!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|2;
    }
    else if (0 != (hv_Bold!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "Menlo-Regular";
      hv_Fonts[1] = "Menlo-Italic";
      hv_Fonts[2] = "Menlo-Bold";
      hv_Fonts[3] = "Menlo-BoldItalic";
    }
    else if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "CourierNewPSMT";
      hv_Fonts[1] = "CourierNewPS-ItalicMT";
      hv_Fonts[2] = "CourierNewPS-BoldMT";
      hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "ArialMT";
      hv_Fonts[1] = "Arial-ItalicMT";
      hv_Fonts[2] = "Arial-BoldMT";
      hv_Fonts[3] = "Arial-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "TimesNewRomanPSMT";
      hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
      hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
      hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
    }
    else
    {
      //Attempt to figure out which of the fonts installed on the system
      //the user could have meant.
      QueryFont(hv_WindowHandle, &hv_SystemFonts);
      hv_Fonts.Clear();
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font);
      hv_Guess.Append(hv_Font+"-Regular");
      hv_Guess.Append(hv_Font+"MT");
      {
      HTuple end_val100 = (hv_Guess.TupleLength())-1;
      HTuple step_val100 = 1;
      for (hv_I=0; hv_I.Continue(end_val100, step_val100); hv_I += step_val100)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[0] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Italic");
      hv_Guess.Append(hv_Font+"-ItalicMT");
      hv_Guess.Append(hv_Font+"-Oblique");
      {
      HTuple end_val109 = (hv_Guess.TupleLength())-1;
      HTuple step_val109 = 1;
      for (hv_I=0; hv_I.Continue(end_val109, step_val109); hv_I += step_val109)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[1] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Bold");
      hv_Guess.Append(hv_Font+"-BoldMT");
      {
      HTuple end_val118 = (hv_Guess.TupleLength())-1;
      HTuple step_val118 = 1;
      for (hv_I=0; hv_I.Continue(end_val118, step_val118); hv_I += step_val118)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[2] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-BoldItalic");
      hv_Guess.Append(hv_Font+"-BoldItalicMT");
      hv_Guess.Append(hv_Font+"-BoldOblique");
      {
      HTuple end_val127 = (hv_Guess.TupleLength())-1;
      HTuple step_val127 = 1;
      for (hv_I=0; hv_I.Continue(end_val127, step_val127); hv_I += step_val127)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[3] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
    }
    hv_Font = ((const HTuple&)hv_Fonts)[hv_SubFamily];
    try
    {
      SetFont(hv_WindowHandle, (hv_Font+"-")+hv_Size);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else
  {
    //Set font for UNIX systems
    hv_Size = hv_Size*1.25;
    hv_AllowedFontSizes.Clear();
    hv_AllowedFontSizes[0] = 11;
    hv_AllowedFontSizes[1] = 14;
    hv_AllowedFontSizes[2] = 17;
    hv_AllowedFontSizes[3] = 20;
    hv_AllowedFontSizes[4] = 25;
    hv_AllowedFontSizes[5] = 34;
    if (0 != ((hv_AllowedFontSizes.TupleFind(hv_Size))==-1))
    {
      hv_Distances = (hv_AllowedFontSizes-hv_Size).TupleAbs();
      TupleSortIndex(hv_Distances, &hv_Indices);
      hv_Size = ((const HTuple&)hv_AllowedFontSizes)[HTuple(hv_Indices[0])];
    }
    if (0 != (HTuple(hv_Font==HTuple("mono")).TupleOr(hv_Font==HTuple("Courier"))))
    {
      hv_Font = "courier";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "helvetica";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "times";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = "bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = "medium";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      if (0 != (hv_Font==HTuple("times")))
      {
        hv_Slant = "i";
      }
      else
      {
        hv_Slant = "o";
      }
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = "r";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font)+"-")+hv_Bold)+"-")+hv_Slant)+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple((hv_OS.TupleSubstr(0,4))==HTuple("Linux")).TupleAnd(hv_Font==HTuple("courier"))))
      {
        QueryFont(hv_WindowHandle, &hv_Fonts);
        hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold)+"-")+hv_Slant;
        hv_FontsCourier = (hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp)).TupleRegexpMatch(hv_FontSelRegexp);
        if (0 != ((hv_FontsCourier.TupleLength())==0))
        {
          hv_Exception = "Wrong font name";
          //throw (Exception)
        }
        else
        {
          try
          {
            SetFont(hv_WindowHandle, ((HTuple(hv_FontsCourier[0])+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
          }
          // catch (Exception) 
          catch (HalconCpp::HException &HDevExpDefaultException)
          {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            //throw (Exception)
          }
        }
      }
      //throw (Exception)
    }
  }
  // dev_set_preferences(...); only in hdevelop
  return;
}

// Local procedures 
void TileImages (HObject ho_Images, HObject *ho_TiledImage)
{

  // Local iconic variables
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_Number, hv_Width, hv_Height, hv_WholeHeight;
  HTuple  hv_OffsetRow, hv_SingleWidthConcat, hv_i, hv_SingleWidth;
  HTuple  hv_SingleHeight, hv_Sum, hv_OffsetCol, hv_OffsetDefault;

  CountObj(ho_Images, &hv_Number);
  GetImageSize(ho_Images, &hv_Width, &hv_Height);
  TupleSum(hv_Height, &hv_WholeHeight);
  //
  hv_OffsetRow = 0;
  hv_SingleWidthConcat = HTuple();
  {
  HTuple end_val6 = hv_Number-1;
  HTuple step_val6 = 1;
  for (hv_i=1; hv_i.Continue(end_val6, step_val6); hv_i += step_val6)
  {
    SelectObj(ho_Images, &ho_ObjectSelected, hv_i);
    GetImageSize(ho_ObjectSelected, &hv_SingleWidth, &hv_SingleHeight);
    hv_SingleWidthConcat = hv_SingleWidthConcat.TupleConcat(hv_SingleHeight);
    TupleSum(hv_SingleWidthConcat, &hv_Sum);
    hv_OffsetRow = hv_OffsetRow.TupleConcat(hv_Sum);
  }
  }
  //
  TupleGenConst(hv_Number, 0, &hv_OffsetCol);
  TupleGenConst(hv_Number, -1, &hv_OffsetDefault);
  //
  TileImagesOffset(ho_Images, &(*ho_TiledImage), hv_OffsetRow, hv_OffsetCol, hv_OffsetDefault, 
      hv_OffsetDefault, hv_OffsetDefault, hv_OffsetDefault, HTuple(hv_Width[0]), 
      hv_WholeHeight);
  //
  //
  return;
}

CString GetPrivateProfileCString(CString lpAppName,LPCTSTR lpKeyName,CString lpDefault,LPCTSTR lpFileName)
{
	CString strRead;
	GetPrivateProfileString(lpAppName,lpKeyName,lpDefault,strRead.GetBuffer(MAX_PATH),MAX_PATH,lpFileName);
	strRead.ReleaseBuffer();
	return strRead;
}

void WritePrivateProfileInt(CString lpAppName,CString lpKeyName,int Value, CString lpFileName)
{
	CString strIn;
	strIn.Format("%d",Value);
	WritePrivateProfileString(lpAppName,lpKeyName,strIn,lpFileName);
}

void WritePrivateProfileDouble(CString lpAppName,CString lpKeyName,double Value, CString lpFileName)
{
	CString strIn;
	strIn.Format("%f",Value);
	WritePrivateProfileString(lpAppName,lpKeyName,strIn,lpFileName);
}
double GetPrivateProfileDouble(LPCTSTR lpAppName, LPCTSTR lpKeyName, double nDefault, LPCTSTR lpFileName)
{
	CString strValue;
	GetPrivateProfileString(lpAppName,lpKeyName,"DefaultValue",strValue.GetBuffer(MAX_PATH),MAX_PATH,lpFileName);
	strValue.ReleaseBuffer();
	if (strValue == "DefaultValue")
	{
		return nDefault;
	}else
	{
		try
		{
			double dValue = atof(strValue);
			return dValue;
		}catch(...)
		{
			return nDefault;
		}

	}
}
CString GetCurrentAppPath()
{
	CString path; 
	GetModuleFileName(NULL,path.GetBufferSetLength(MAX_PATH+1),MAX_PATH); 
	path.ReleaseBuffer(); 
	int pos = path.ReverseFind('\\'); 
	path = path.Left(pos);
	return path;
}


BOOL IsDirectory(CString pstrPath)
{
	if ("" == pstrPath)
	{
		return FALSE;
	}
	/*去除路径末尾的反斜杠*/
	CString strPath = pstrPath;
	if (strPath.Right(1) == _T('\\'))
	{
		strPath.Delete(strPath.GetLength()-1);
	}

	CFileFind finder;
	BOOL bRet = finder.FindFile(strPath);
	if (!bRet)
	{
		return FALSE;
	}

	/*判断该路径是否是目录*/
	finder.FindNextFile();
	bRet = finder.IsDirectory();
	finder.Close();
	return bRet;
}
/*复制目录中的所有内容*/
BOOL CopyFolder(CString pstrSrcFolder, CString pstrDstFolder)
{
	if (("" == pstrSrcFolder) || ("" == pstrSrcFolder))
	{
		return FALSE;
	}

	/*检查源目录是否是合法目录*/
	if (!IsDirectory(pstrSrcFolder))
	{
		return FALSE;
	}

	/*把文件名称转换为CString类型，并确认目录的路径末尾为反斜杠*/
	CString strSrcFolder(pstrSrcFolder);
	if (strSrcFolder.Right(1) != _T('\\'))
	{
		strSrcFolder += _T("\\");
	}
	CString strDstFolder(pstrDstFolder);
	if (strDstFolder.Right(1) != _T("\\"))
	{
		strDstFolder += _T("\\");
	}

	/*如果是目录自身复制，直接返回复制成功*/
	if (0 == _tcscmp(strSrcFolder, strDstFolder))
	{
		return TRUE;
	}

	/*如果目的目录不存在,则创建目录*/
	if (!IsDirectory(strDstFolder))
	{
		if (!CreateDirectory(strDstFolder, NULL))
		{
			/*创建目的目录失败*/
			return FALSE;
		}
	}

	/*创建源目录中查找文件的通配符*/
	CString strWildcard(strSrcFolder);
	strWildcard += _T("*.*");

	/*打开文件查找，查看源目录中是否存在匹配的文件*/
	/*调用FindFile后，必须调用FindNextFile才能获得查找文件的信息*/
	CFileFind finder;
	BOOL bWorking = finder.FindFile(strWildcard);

	while (bWorking)
	{
		/*查找下一个文件*/
		bWorking = finder.FindNextFile();

		/*跳过当前目录“.”和上一级目录“..”*/
		if (finder.IsDots())
		{
			continue;
		}

		/*得到当前要复制的源文件的路径*/
		CString strSrcFile = finder.GetFilePath();

		/*得到要复制的目标文件的路径*/
		CString strDstFile(strDstFolder);
		strDstFile += finder.GetFileName();

		/*判断当前文件是否是目录,*/
		/*如果是目录，递归调用复制目录,*/
		/*否则，直接复制文件*/
		if (finder.IsDirectory())
		{
			if (!CopyFolder(strSrcFile, strDstFile))
			{
				finder.Close();
				return FALSE;
			}
		}
		else
		{
			if (!CopyFileA(strSrcFile, strDstFile, FALSE))
			{
				finder.Close();
				return FALSE;
			}
		}

	} /*while (bWorking)*/

	/*关闭文件查找*/
	finder.Close();

	return TRUE;

}
/*删除目录及目录中的所有内容*/
BOOL DeleteFolder(CString pstrFolder)
{
	if (("" == pstrFolder))
	{
		return FALSE;
	}
	if (!IsDirectory(pstrFolder))
	{
		return FALSE;
	}
	CString strWildcard(pstrFolder);
	if (strWildcard.Right(1) != _T('\\'))
	{
		strWildcard += _T("\\");
	}
	strWildcard += _T("*.*");
	CFileFind finder;
	BOOL bWorking = finder.FindFile(strWildcard);

	while (bWorking)
	{
		/*查找下一个文件*/
		bWorking = finder.FindNextFile();
		if (finder.IsDots())
		{
			continue;
		}

		CString strSubFile = finder.GetFilePath();
		if (finder.IsDirectory())
		{
			if (!DeleteFolder(strSubFile))
			{
				finder.Close();
				return FALSE;
			}
		}
		else
		{
			DeleteFile(HTuple(strSubFile));
		}

	}

	finder.Close();
	return RemoveDirectory(pstrFolder);
}
BOOL CreateMultilevelPath(CString pstrFolder) //p是路径可以是相对路径或是绝对路径
{
	char *p = pstrFolder.GetBuffer(pstrFolder.GetLength());
	pstrFolder.ReleaseBuffer();
	size_t i,len;
	len=strlen(p);
	for(i=0;i<len;i++)
	{
		if(p[i]=='\\' || p[i]=='/')
		{
			p[i]='\0';
			_mkdir(p);
			p[i]='\\';
		}
	}
	if(len>0)
		_mkdir(p);
	p = NULL;
	return TRUE;

}

int GetKeyValues(CStringArray& arrKey,CStringArray& arrValue, LPCTSTR lpSection,LPCTSTR lpfileName)
{
	int i; 
	int iPos=0;
	CString strKeyValue;
	int iMaxCount;
	TCHAR chKeyNames[MAX_PATH]={0}; //总的提出来的字符串
	TCHAR chKey[MAX_PATH]={0}; //提出来的一个键名
	GetPrivateProfileSection(lpSection,chKeyNames,MAX_PATH,lpfileName);
	for(i=0;i<MAX_PATH;i++)
	{
		if (chKeyNames[i]==0)
			if (chKeyNames[i]==chKeyNames[i+1])
				break;
	}
	iMaxCount=i+1; //要多一个0号元素。即找出全部字符串的结束部分。
	arrKey.RemoveAll();//清空原数组
	arrValue.RemoveAll();

	for(i=0;i<iMaxCount;i++)
	{
		chKey[iPos++]=chKeyNames[i];
		if(chKeyNames[i]==0)
		{
			strKeyValue=chKey;
			arrKey.Add(strKeyValue.Left(strKeyValue.Find("=")));
			arrValue.Add(strKeyValue.Mid(strKeyValue.Find("=")+1));
			memset(chKey,0,MAX_PATH);
			iPos=0;
		}

	}
	return (int)arrKey.GetSize();
}

void AdaptiveSize(HWND hWnd)//自适应UI
{
	LONG nSrcX(1366),nSrcY(768);
	LONG nDstX = GetSystemMetrics(SM_CXSCREEN);  
	LONG nDstY = GetSystemMetrics(SM_CYSCREEN);  
	float fsp[2];
	fsp[0]=(float)nDstX/nSrcX;  
	fsp[1]=(float)nDstY/nSrcY;  
	CPoint OldTLPoint,TLPoint; //左上角  
	CPoint OldBRPoint,BRPoint; //右下角  
	HWND  hwndChild=::GetWindow(hWnd,GW_CHILD);  //列出所有控件 
	CWnd* pWnd = CWnd::FromHandle(hWnd);
	int woc; 
	CRect Rect;
	while(hwndChild)      
	{      
		woc=::GetDlgCtrlID(hwndChild);//取得ID  
		pWnd->GetDlgItem(woc)->GetWindowRect(Rect);    
		pWnd->ScreenToClient(Rect);    
		OldTLPoint = Rect.TopLeft();    
		TLPoint.x = long(OldTLPoint.x*fsp[0]);    
		TLPoint.y = long(OldTLPoint.y*fsp[1]);    
		OldBRPoint = Rect.BottomRight();    
		BRPoint.x = long(OldBRPoint.x *fsp[0]);    
		BRPoint.y = long(OldBRPoint.y *fsp[1]);    
		Rect.SetRect(TLPoint,BRPoint);    
		pWnd->GetDlgItem(woc)->MoveWindow(Rect,TRUE);  
		hwndChild=::GetWindow(hwndChild, GW_HWNDNEXT);      
	}
}
